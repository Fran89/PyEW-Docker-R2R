<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mem_circ_queue.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>mem_circ_queue.c</h1><a href="mem__circ__queue_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> *   THIS FILE IS UNDER RCS - DO NOT MODIFY UNLESS YOU HAVE</span>
00004 <span class="comment"> *   CHECKED IT OUT USING THE COMMAND CHECKOUT.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *    $Id: mem__circ__queue_8c-source.html 2161 2006-05-19 16:55:03Z paulf $</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *    Revision history:</span>
00009 <span class="comment"> *     $Log$
00009 <span class="comment"> *     Revision 1.1  2006/05/19 16:55:02  paulf
00009 <span class="comment"> *     first inclusion
00009 <span class="comment"> *</span>
00010 <span class="comment"> *     Revision 1.2  2001/04/12 03:57:44  lombard</span>
00011 <span class="comment"> *     Added functions dumpqueue, undumpqueue and peekNextElement</span>
00012 <span class="comment"> *     to allow saving queue to disk and reloading.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *     Revision 1.1  2000/02/14 18:51:48  lucky</span>
00015 <span class="comment"> *     Initial revision</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> */</span>
00019 
00020 <span class="comment">/* </span>
00021 <span class="comment">This is son of in 'queue_max_size.c', which is son of queue, which Will got from</span>
00022 <span class="comment">Kelley and Pohl. These were clever linked list schemes which allocated as needed.</span>
00023 <span class="comment">This was too scary: the system could run out of memory and fail after running for</span>
00024 <span class="comment">a long time.</span>
00025 <span class="comment">        So, out with the cleverness, and in with brute force: this version pre-</span>
00026 <span class="comment">allocates the max amount of memory it will ever use at startup, and does the</span>
00027 <span class="comment">buffering in an array of message slots. The buffering is circular, as before:</span>
00028 <span class="comment">When we run out of message slots, we overwrite the oldest message.</span>
00029 <span class="comment">alex 2/8/98</span>
00030 <span class="comment">*/</span>
00031 
00032 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00033 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00034 <span class="preprocessor">#include &lt;string.h&gt;</span>
00035 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00036 <span class="preprocessor">#include &lt;<a class="code" href="earthworm_8h.html">earthworm.h</a>&gt;</span>
00037 <span class="preprocessor">#include &lt;time.h&gt;</span>
00038 <span class="preprocessor">#include &lt;<a class="code" href="mem__circ__queue_8h.html">mem_circ_queue.h</a>&gt;</span>
00039 
00040 <span class="comment">/* Internal Function Prototypes */</span>
00041 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="mem__circ__queue_8c.html#a0">inc_circular</a>( <a class="code" href="structQUEUE.html">QUEUE</a>* q, Q_POS * pQPos);
00042 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="mem__circ__queue_8c.html#a1">dec_circular</a>( <a class="code" href="structQUEUE.html">QUEUE</a>* q, Q_POS * pQPos);
00043 
00044 <span class="comment">/****************************************************************</span>
00045 <span class="comment">*                       initqueue                               *</span>
00046 <span class="comment">*  allocates the three queue regions                            *</span>
00047 <span class="comment">*       returns:                                                *</span>
00048 <span class="comment">*               -1 if we couldn't get the memory                *</span>
00049 <span class="comment">*               -2 if the amount implied is bigger than         *</span>
00050 <span class="comment">*                  a long                                       *</span>
00051 <span class="comment">*****************************************************************/</span>
<a name="l00052"></a><a class="code" href="mem__circ__queue_8c.html#a2">00052</a> <span class="keywordtype">int</span> <a class="code" href="mem__circ__queue_8c.html#a2">initqueue</a>( <a class="code" href="structQUEUE.html">QUEUE</a>* q, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> maxElements, 
00053                <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> elementMaxSize )
00054 {
00055   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>         temp;
00056   <a class="code" href="structQUEUE__ENTRY.html">QUEUE_ENTRY</a>*  pQE;
00057   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> StartingOffset, malloc_size;
00058 
00059   <span class="comment">/* First allocate the QUEUE structure</span>
00060 <span class="comment">   *************************************/</span>
00061   <span class="comment">/* this contains the pointers to the start of the message descriptor array</span>
00062 <span class="comment">     and the message storage area */</span>
00063   <span class="keywordflow">if</span> (q == (<a class="code" href="structQUEUE.html">QUEUE</a>*)NULL) <span class="keywordflow">return</span>(-1);
00064 
00065   <span class="comment">/* save some arguments to local variables</span>
00066 <span class="comment">   *****************************************/</span>
00067   q-&gt;<a class="code" href="structQUEUE.html#m4">MyMaxElements</a> = maxElements;
00068   q-&gt;<a class="code" href="structQUEUE.html#m3">MyMaxSize</a> = elementMaxSize;
00069   q-&gt;<a class="code" href="structQUEUE.html#m5">NumOfElements</a> = 0;
00070 
00071   <span class="comment">/* Is the total number of bytes within an unsigned long?</span>
00072 <span class="comment">   * I really hope so, because otherwise this is</span>
00073 <span class="comment">   * going to be a 4GB queue.</span>
00074 <span class="comment">   ********************************************/</span>
00075   temp =  q-&gt;<a class="code" href="structQUEUE.html#m4">MyMaxElements</a> * q-&gt;<a class="code" href="structQUEUE.html#m3">MyMaxSize</a>;
00076   temp = temp/maxElements;
00077   <span class="keywordflow">if</span> (temp != elementMaxSize) <span class="keywordflow">return</span> (-2);  
00078   
00079   <span class="comment">/* Allocate the array of queue entries</span>
00080 <span class="comment">   ***************************************************/</span>
00081   malloc_size= maxElements * (<span class="keyword">sizeof</span>(QUEUE_ENTRY) + elementMaxSize);
00082   q-&gt;<a class="code" href="structQUEUE.html#m0">pQE</a> = (<a class="code" href="structQUEUE__ENTRY.html">QUEUE_ENTRY</a>*)malloc(malloc_size);
00083   <span class="keywordflow">if</span> (q-&gt;<a class="code" href="structQUEUE.html#m0">pQE</a> == (<a class="code" href="structQUEUE__ENTRY.html">QUEUE_ENTRY</a>*)NULL) <span class="keywordflow">return</span>(-1);
00084   
00085   <span class="comment">/* Set DATA pointers for individual elements</span>
00086 <span class="comment">   **********************************************************************/</span>
00087   pQE= q-&gt;<a class="code" href="structQUEUE.html#m0">pQE</a>;   <span class="comment">/* element of the QUEUE structure which points to the array of buffer descriptors */</span>
00088   
00089   StartingOffset=((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) pQE) + (maxElements * <span class="keyword">sizeof</span>(QUEUE_ENTRY));
00090    
00091   <span class="keywordflow">for</span> (temp=0; temp&lt; maxElements; temp++)
00092   {
00093     <span class="comment">/*  For each element, set the data pointer */</span>
00094     pQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m2">d</a> = (<span class="keywordtype">char</span> *)(StartingOffset + (elementMaxSize * temp));
00095     pQE++;
00096   }
00097 
00098   <span class="comment">/* set in and out pointers to indicate empty queue</span>
00099 <span class="comment">   *************************************************/</span>
00100   q-&gt;<a class="code" href="structQUEUE.html#m1">first</a>=q-&gt;<a class="code" href="structQUEUE.html#m2">last</a>=0;
00101   <span class="comment">/* in  = out = first descriptor */</span>
00102 
00103   <span class="keywordflow">return</span>(0);
00104 }
00105 
00106 <span class="comment">/***********************************************************************</span>
00107 <span class="comment"> *                              dequeue                                *</span>
00108 <span class="comment"> *                                                                     *</span>
00109 <span class="comment"> *  Copies oldest message and its logo into caller's space.            *</span>
00110 <span class="comment"> *  Returns 0 if no error.                                             *</span>
00111 <span class="comment"> *  Returns -1 if the queue is empty.                                  *</span>
00112 <span class="comment"> ***********************************************************************/</span>
<a name="l00113"></a><a class="code" href="mem__circ__queue_8c.html#a3">00113</a> <span class="keywordtype">int</span> <a class="code" href="mem__circ__queue_8c.html#a3">dequeue</a>( <a class="code" href="structQUEUE.html">QUEUE</a> *q, DATA x, <span class="keywordtype">long</span>* size, <a class="code" href="structMSG__LOGO.html">MSG_LOGO</a>* userLogoPtr )
00114 {
00115   <a class="code" href="structQUEUE__ENTRY.html">QUEUE_ENTRY</a> * pFQE; <span class="comment">/* Pointer to first(oldest) queue entry */</span>
00116 
00117   <span class="keywordflow">if</span> (!(q-&gt;<a class="code" href="structQUEUE.html#m5">NumOfElements</a>) ) <span class="comment">/* then the queue is empty */</span>
00118     <span class="keywordflow">return</span>( -1 );
00119 
00120   <span class="comment">/* set shortcut for first queue element */</span>
00121   pFQE=&amp;(q-&gt;<a class="code" href="structQUEUE.html#m0">pQE</a>[q-&gt;<a class="code" href="structQUEUE.html#m1">first</a>]);
00122   
00123   <span class="comment">/* copy text of message to caller's memory </span>
00124 <span class="comment">   ******************************************/</span>
00125   memcpy( x, pFQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m2">d</a>, (size_t)(pFQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m0">length</a>) );
00126   
00127   <span class="comment">/* copy the logo</span>
00128 <span class="comment">   ***************/</span>
00129   userLogoPtr-&gt;<a class="code" href="structMSG__LOGO.html#m0">type</a>   = (pFQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m1">queueLogo</a>).type;
00130   userLogoPtr-&gt;<a class="code" href="structMSG__LOGO.html#m1">mod</a>    = (pFQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m1">queueLogo</a>).mod ;
00131   userLogoPtr-&gt;<a class="code" href="structMSG__LOGO.html#m2">instid</a> = (pFQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m1">queueLogo</a>).instid;
00132   
00133   *size  = pFQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m0">length</a>;  <span class="comment">/* message length */</span>
00134   
00135   <span class="comment">/* move the out pointer</span>
00136 <span class="comment">   **********************/</span>
00137   <a class="code" href="mem__circ__queue_8c.html#a0">inc_circular</a>(q, &amp;(q-&gt;<a class="code" href="structQUEUE.html#m1">first</a>) );   
00138   
00139   q-&gt;<a class="code" href="structQUEUE.html#m5">NumOfElements</a>--;  <span class="comment">/* we're dequeueing an element, so there is one less */</span>
00140   
00141   <span class="keywordflow">return</span>( 0 );
00142 }
00143 
00144 
00145 <span class="comment">/***********************************************************************</span>
00146 <span class="comment"> *                              enqueue                                *</span>
00147 <span class="comment"> *                                                                     *</span>
00148 <span class="comment"> *  moves message into circular buffer.                                *</span>
00149 <span class="comment"> *  Copies string x to the new element.                                *</span>
00150 <span class="comment"> *  Returns 0 if no error.                                             *</span>
00151 <span class="comment"> *  Returns -1 message too big                                         *</span>
00152 <span class="comment"> *  Returns -3 if we clobbered an unsent message (stepped on our tail) *</span>
00153 <span class="comment"> ***********************************************************************/</span>
<a name="l00154"></a><a class="code" href="mem__circ__queue_8c.html#a4">00154</a> <span class="keywordtype">int</span> <a class="code" href="mem__circ__queue_8c.html#a4">enqueue</a>( <a class="code" href="structQUEUE.html">QUEUE</a> *q, DATA x, <span class="keywordtype">long</span> size, <a class="code" href="structMSG__LOGO.html">MSG_LOGO</a> userLogo )
00155 {
00156   <span class="keywordtype">int</span> ourRet;
00157   <a class="code" href="structQUEUE__ENTRY.html">QUEUE_ENTRY</a> * pLQE;  <span class="comment">/* pointer to last(youngest) entry in queue */</span>
00158   
00159   ourRet=0 ; <span class="comment">/* presume all will go well */</span>
00160   
00161   <span class="comment">/* if message is larger than max, do nothing and return error</span>
00162 <span class="comment">   ************************************************************/</span>
00163   <span class="keywordflow">if</span> (size &gt; q-&gt;<a class="code" href="structQUEUE.html#m3">MyMaxSize</a>) <span class="keywordflow">return</span>(-1); 
00164   
00165   <span class="comment">/* set shortcut for last queue element */</span>
00166   pLQE=&amp;((q-&gt;<a class="code" href="structQUEUE.html#m0">pQE</a>)[q-&gt;<a class="code" href="structQUEUE.html#m2">last</a>]);
00167   
00168   <span class="comment">/* copy message text</span>
00169 <span class="comment">   *******************/</span>
00170   memcpy( pLQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m2">d</a>, x, size);
00171   
00172   <span class="comment">/* copy logo and size</span>
00173 <span class="comment">   *********************/</span>
00174   (pLQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m1">queueLogo</a>).type   = userLogo.<a class="code" href="structMSG__LOGO.html#m0">type</a>;
00175   (pLQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m1">queueLogo</a>).mod    = userLogo.<a class="code" href="structMSG__LOGO.html#m1">mod</a>;
00176   (pLQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m1">queueLogo</a>).instid = userLogo.<a class="code" href="structMSG__LOGO.html#m2">instid</a>;
00177   (pLQE)-&gt;length = size;
00178   
00179 
00180   <span class="comment">/* move to next buffer</span>
00181 <span class="comment">   *********************/</span>
00182   <a class="code" href="mem__circ__queue_8c.html#a0">inc_circular</a>(q, &amp;(q-&gt;<a class="code" href="structQUEUE.html#m2">last</a>) );   
00183   <span class="keywordflow">if</span>( q-&gt;<a class="code" href="structQUEUE.html#m5">NumOfElements</a> == q-&gt;<a class="code" href="structQUEUE.html#m4">MyMaxElements</a> ) <span class="comment">/* then the queue is full */</span>
00184   { <span class="comment">/* in that case we just overwrote the contents of the first(oldest)</span>
00185 <span class="comment">       message in the queue, so 'drive' the outpointer forward one */</span>
00186     <a class="code" href="mem__circ__queue_8c.html#a0">inc_circular</a>(q, &amp;(q-&gt;<a class="code" href="structQUEUE.html#m1">first</a>) );
00187     q-&gt;<a class="code" href="structQUEUE.html#m5">NumOfElements</a>--;  <span class="comment">/* we're overwriting an element, so there is one less */</span>
00188     ourRet = -3;   <span class="comment">/* meaning we're over-writing messages */</span>
00189   }
00190 
00191   q-&gt;<a class="code" href="structQUEUE.html#m5">NumOfElements</a>++;  <span class="comment">/* we're adding an element, so there is one more */</span>
00192 
00193   <span class="keywordflow">return</span>( ourRet );
00194 }
00195 
00196 <span class="comment">/* to move supplied pointer to the next buffer descriptor structure </span>
00197 <span class="comment"> * - in a circular way */</span>
<a name="l00198"></a><a class="code" href="mem__circ__queue_8c.html#a0">00198</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="mem__circ__queue_8c.html#a0">inc_circular</a>( <a class="code" href="structQUEUE.html">QUEUE</a>* q, Q_POS * pQPos)
00199 {
00200   (*pQPos)++;
00201   <span class="keywordflow">if</span>(*pQPos &gt;= q-&gt;<a class="code" href="structQUEUE.html#m4">MyMaxElements</a>)
00202     *pQPos=0;
00203 }
00204 
00205 <span class="comment">/* to move supplied pointer to the prev buffer descriptor structure </span>
00206 <span class="comment"> * - in a circular way */</span>
<a name="l00207"></a><a class="code" href="mem__circ__queue_8c.html#a1">00207</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="mem__circ__queue_8c.html#a1">dec_circular</a>( <a class="code" href="structQUEUE.html">QUEUE</a>* q, Q_POS * pQPos)
00208 {
00209   (*pQPos)--;
00210   <span class="keywordflow">if</span>((*pQPos) &lt;  0)
00211     *pQPos= (q-&gt;<a class="code" href="structQUEUE.html#m4">MyMaxElements</a>)-1;
00212 }
00213 
00214 
<a name="l00215"></a><a class="code" href="mem__circ__queue_8c.html#a5">00215</a> <span class="keywordtype">int</span> <a class="code" href="priority__queue_8c.html#a5">getNumOfElementsInQueue</a>( <a class="code" href="structQUEUE.html">QUEUE</a> * q)
00216 {
00217   <span class="keywordflow">return</span>(q-&gt;<a class="code" href="structQUEUE.html#m5">NumOfElements</a>);
00218 }
00219 
<a name="l00220"></a><a class="code" href="mem__circ__queue_8c.html#a6">00220</a> <a class="code" href="mem__circ__queue_8h.html#a1">Q_POS</a> <a class="code" href="mem__circ__queue_8c.html#a6">getNext</a>(<a class="code" href="structQUEUE.html">QUEUE</a> * q, <span class="keywordtype">int</span> QueuePosition)
00221 {
00222   <a class="code" href="mem__circ__queue_8h.html#a1">Q_POS</a> temp;
00223   
00224   temp=QueuePosition;
00225   <span class="keywordflow">if</span>(temp &lt; 0 || temp &gt;= q-&gt;<a class="code" href="structQUEUE.html#m4">MyMaxElements</a>)
00226     <span class="keywordflow">return</span>(-1);
00227   <span class="keywordflow">else</span>
00228   {
00229     <a class="code" href="mem__circ__queue_8c.html#a0">inc_circular</a>(q,&amp;temp);
00230     <span class="keywordflow">return</span>(temp);
00231   }
00232 }
00233 
00234 
<a name="l00235"></a><a class="code" href="mem__circ__queue_8c.html#a7">00235</a> <a class="code" href="mem__circ__queue_8h.html#a1">Q_POS</a> <a class="code" href="mem__circ__queue_8c.html#a7">getPrev</a>(<a class="code" href="structQUEUE.html">QUEUE</a> * q, <span class="keywordtype">int</span> QueuePosition)
00236 {
00237   <a class="code" href="mem__circ__queue_8h.html#a1">Q_POS</a> temp;
00238   
00239   temp=QueuePosition;
00240   <span class="keywordflow">if</span>(temp &lt; 0 || temp &gt;= q-&gt;<a class="code" href="structQUEUE.html#m4">MyMaxElements</a>)
00241     <span class="keywordflow">return</span>(-1);
00242   <span class="keywordflow">else</span>
00243   {
00244     <a class="code" href="mem__circ__queue_8c.html#a1">dec_circular</a>(q,&amp;temp);
00245     <span class="keywordflow">return</span>(temp);
00246   }
00247 }
00248 
<a name="l00249"></a><a class="code" href="mem__circ__queue_8c.html#a8">00249</a> <a class="code" href="mem__circ__queue_8h.html#a1">Q_POS</a> <a class="code" href="mem__circ__queue_8c.html#a8">getPosFirst</a>(<a class="code" href="structQUEUE.html">QUEUE</a> * q)
00250 {
00251   <span class="keywordflow">return</span>(q-&gt;<a class="code" href="structQUEUE.html#m1">first</a>);
00252 }
00253 
00254 
<a name="l00255"></a><a class="code" href="mem__circ__queue_8c.html#a9">00255</a> <a class="code" href="mem__circ__queue_8h.html#a1">Q_POS</a> <a class="code" href="mem__circ__queue_8c.html#a9">getPosLast</a>(<a class="code" href="structQUEUE.html">QUEUE</a> * q)
00256 {
00257   <span class="keywordflow">return</span>(q-&gt;<a class="code" href="structQUEUE.html#m2">last</a>);
00258 }
00259 
00260 <span class="comment">/*</span>
00261 <span class="comment"> * dumpqueue: dump the contents of a queue to a file to be used for restarts</span>
00262 <span class="comment"> *     returns: 0 on success</span>
00263 <span class="comment"> *             -1 on errors opening or writing file; file is deleted</span>
00264 <span class="comment"> */</span>
<a name="l00265"></a><a class="code" href="mem__circ__queue_8c.html#a10">00265</a> <span class="keywordtype">int</span> <a class="code" href="mem__circ__queue_8c.html#a10">dumpqueue</a>( <a class="code" href="structQUEUE.html">QUEUE</a> *q, <span class="keywordtype">char</span> *filename)
00266 {
00267   <a class="code" href="structQUEUE__ENTRY.html">QUEUE_ENTRY</a> *pQE;
00268   FILE *fp;
00269   <span class="keywordtype">long</span> i;
00270   <a class="code" href="mem__circ__queue_8h.html#a1">Q_POS</a> p;
00271   <span class="keywordtype">int</span> ret = 0;
00272   time_t timestamp;
00273   
00274   <span class="keywordflow">if</span> ( (fp = fopen(filename, <span class="stringliteral">"wb"</span>)) == (FILE *)NULL)
00275     <span class="keywordflow">return</span>( -1 );
00276   
00277   timestamp = time(0);
00278   <span class="keywordflow">if</span> (fwrite(&amp;timestamp, <span class="keyword">sizeof</span>(time_t), 1, fp) &lt; 1)
00279   {
00280     ret = -1;
00281     <span class="keywordflow">goto</span> Cleanup;
00282   }
00283   <span class="keywordflow">if</span> (fwrite(&amp;q-&gt;<a class="code" href="structQUEUE.html#m5">NumOfElements</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>), 1, fp) &lt; 1)
00284   {
00285     ret = -1;
00286     <span class="keywordflow">goto</span> Cleanup;
00287   }
00288   <span class="comment">/* Loop through all the queue entries */</span>
00289   p = q-&gt;<a class="code" href="structQUEUE.html#m1">first</a>;
00290   <span class="keywordflow">for</span> (i = 0l; i &lt; q-&gt;<a class="code" href="structQUEUE.html#m5">NumOfElements</a>; i++, <a class="code" href="mem__circ__queue_8c.html#a0">inc_circular</a>(q, &amp;p))
00291   {
00292     pQE = &amp;(q-&gt;<a class="code" href="structQUEUE.html#m0">pQE</a>[p]);
00293     <span class="keywordflow">if</span> (fwrite(&amp;pQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m1">queueLogo</a>, <span class="keyword">sizeof</span>(<a class="code" href="structMSG__LOGO.html">MSG_LOGO</a>), 1, fp) &lt; 1)
00294     {
00295       ret = -1;
00296       <span class="keywordflow">goto</span> Cleanup;
00297     }
00298     <span class="keywordflow">if</span> (fwrite(&amp;pQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m0">length</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>), 1, fp) &lt; 1)
00299     {
00300       ret = -1;
00301       <span class="keywordflow">goto</span> Cleanup;
00302     }
00303     <span class="keywordflow">if</span> ((long)fwrite(pQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m2">d</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), pQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m0">length</a>, fp) &lt; pQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m0">length</a>)
00304     {
00305       ret = -1;
00306       <span class="keywordflow">goto</span> Cleanup;
00307     }
00308   }
00309   <span class="keywordflow">if</span> (fwrite(&amp;timestamp, <span class="keyword">sizeof</span>(time_t), 1, fp) &lt; 1)
00310   {
00311     ret = -1;
00312     <span class="keywordflow">goto</span> Cleanup;
00313   }
00314   
00315  Cleanup:
00316   fclose(fp);
00317   <span class="keywordflow">if</span> (ret &lt; 0)
00318     unlink(filename);
00319 
00320   <span class="keywordflow">return</span>( ret );
00321 }
00322 
00323     
00324 <span class="comment">/*</span>
00325 <span class="comment"> * undumpqueue: read a queue file previously written by dumpqueue().</span>
00326 <span class="comment"> *              Contents of file will be inserted into the specified queue.</span>
00327 <span class="comment"> *              The queue is assumed to be empty on entry to this function.</span>
00328 <span class="comment"> *   Returns: 0 on success</span>
00329 <span class="comment"> *           +1 if dump file does not exist</span>
00330 <span class="comment"> *           -1 on errors opening or reading file</span>
00331 <span class="comment"> *           -2 if there are more entries in the file than will fit in queue</span>
00332 <span class="comment"> *           -3 if file entry is larger than will fit in queue</span>
00333 <span class="comment"> *           -4 if timestamps at each end of file don't match</span>
00334 <span class="comment"> */</span>
<a name="l00335"></a><a class="code" href="mem__circ__queue_8c.html#a11">00335</a> <span class="keywordtype">int</span> <a class="code" href="mem__circ__queue_8c.html#a11">undumpqueue</a>( <a class="code" href="structQUEUE.html">QUEUE</a> *q, <span class="keywordtype">char</span> *filename)
00336 {
00337   <a class="code" href="structQUEUE__ENTRY.html">QUEUE_ENTRY</a> *pQE;
00338   FILE *fp;
00339   <span class="keywordtype">long</span> i, num_entries;
00340   <span class="keywordtype">int</span> ret = 0;
00341   time_t timestamp1, timestamp2;
00342   
00343   <span class="keywordflow">if</span> ( (fp = fopen(filename, <span class="stringliteral">"rb"</span>)) == (FILE *)NULL)
00344   {
00345     <span class="keywordflow">if</span> (errno == ENOENT)
00346       <span class="keywordflow">return</span>( +1);
00347     <span class="keywordflow">else</span>
00348       <span class="keywordflow">return</span>( -1 );
00349   }
00350   
00351   <span class="keywordflow">if</span> (fread(&amp;timestamp1, <span class="keyword">sizeof</span>(time_t), 1, fp) &lt; 1)
00352   {
00353     ret = -1;
00354     <span class="keywordflow">goto</span> Cleanup;
00355   }
00356 
00357   <span class="keywordflow">if</span> (fread(&amp;num_entries, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>), 1, fp) &lt; 1)
00358   {
00359     ret = -1;
00360     <span class="keywordflow">goto</span> Cleanup;
00361   }
00362   <span class="keywordflow">if</span> (num_entries &gt; q-&gt;<a class="code" href="structQUEUE.html#m4">MyMaxElements</a>)
00363   {
00364     ret = -2;
00365     <span class="keywordflow">goto</span> Cleanup;
00366   }
00367   
00368   <span class="keywordflow">for</span> (i = 0l; i &lt; num_entries; i++)
00369   {
00370     pQE = &amp;(q-&gt;<a class="code" href="structQUEUE.html#m0">pQE</a>[q-&gt;<a class="code" href="structQUEUE.html#m2">last</a>]);
00371     <span class="keywordflow">if</span> (fread(&amp;pQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m1">queueLogo</a>, <span class="keyword">sizeof</span>(<a class="code" href="structMSG__LOGO.html">MSG_LOGO</a>), 1, fp) &lt; 1)
00372     {
00373       ret = -1;
00374       <span class="keywordflow">goto</span> Cleanup;
00375     }
00376     <span class="keywordflow">if</span> (fread(&amp;pQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m0">length</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">long</span>), 1, fp) &lt; 1)
00377     {
00378       ret = -1;
00379       <span class="keywordflow">goto</span> Cleanup;
00380     }
00381     <span class="keywordflow">if</span> (pQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m0">length</a> &gt; q-&gt;<a class="code" href="structQUEUE.html#m3">MyMaxSize</a>)
00382     {
00383       ret = -3;
00384       <span class="keywordflow">goto</span> Cleanup;
00385     }
00386     <span class="keywordflow">if</span> ((long)fread(pQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m2">d</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), pQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m0">length</a>, fp) &lt; pQE-&gt;<a class="code" href="structQUEUE__ENTRY.html#m0">length</a>)
00387     {
00388       ret = -1;
00389       <span class="keywordflow">goto</span> Cleanup;
00390     }
00391     <a class="code" href="mem__circ__queue_8c.html#a0">inc_circular</a>(q, &amp;q-&gt;<a class="code" href="structQUEUE.html#m2">last</a>);
00392     q-&gt;<a class="code" href="structQUEUE.html#m5">NumOfElements</a>++;
00393   }
00394   
00395   <span class="keywordflow">if</span> (fread(&amp;timestamp2, <span class="keyword">sizeof</span>(time_t), 1, fp) &lt; 1)
00396   {
00397     ret = -1;
00398     <span class="keywordflow">goto</span> Cleanup;
00399   }
00400   <span class="keywordflow">if</span> (timestamp2 != timestamp1)
00401   { <span class="comment">/* Timestamps don't match; can't trust file, so reset the queue to empty */</span>
00402     q-&gt;<a class="code" href="structQUEUE.html#m2">last</a> = q-&gt;<a class="code" href="structQUEUE.html#m1">first</a> = 0;
00403     q-&gt;<a class="code" href="structQUEUE.html#m5">NumOfElements</a> = 0;
00404     ret = -4;
00405   }
00406   
00407  Cleanup:
00408   fclose(fp);
00409 
00410   <span class="keywordflow">return</span>( ret );
00411 }
00412 
00413 <span class="comment">/*</span>
00414 <span class="comment"> * peekNextElement: return a pointer to the next element without changing it.</span>
00415 <span class="comment"> *    Returns: pointer to data on success</span>
00416 <span class="comment"> *             NULL if there are no elements in the queue</span>
00417 <span class="comment"> */</span>
<a name="l00418"></a><a class="code" href="mem__circ__queue_8c.html#a12">00418</a> <a class="code" href="mem__circ__queue_8h.html#a0">DATA</a> <a class="code" href="mem__circ__queue_8c.html#a12">peekNextElement</a>( <a class="code" href="structQUEUE.html">QUEUE</a> *q )
00419 {
00420   <span class="keywordflow">if</span> (q-&gt;<a class="code" href="structQUEUE.html#m5">NumOfElements</a> &gt; 0)
00421     <span class="keywordflow">return</span>( q-&gt;<a class="code" href="structQUEUE.html#m0">pQE</a>[q-&gt;<a class="code" href="structQUEUE.html#m1">first</a>].d );
00422   <span class="keywordflow">else</span>
00423     <span class="keywordflow">return</span>( NULL );
00424 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue May 6 09:16:04 2003 for Earthworm Libs by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc3 </small></address>
</body>
</html>
