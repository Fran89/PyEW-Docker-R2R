<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>request_template.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>request_template.cpp</h1><a href="request__template_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * request_template.cpp -- Example of a request message class for use</span>
00003 <span class="comment"> *                         in the mutable server model.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *                       In addition to passport handling, this example</span>
00006 <span class="comment"> *                       class is expected to also handle an integer and</span>
00007 <span class="comment"> *                       a char string of undetermined length (to demonstrate</span>
00008 <span class="comment"> *                       memory allocation and cleanup).</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="comment">// START WITH THE CLASS DECLARATION IN THE .h FILE.</span>
00012 
00013 <span class="comment">//******************************************************************************</span>
00014 <span class="comment">// STEP 1: Do a global replacement of the string "RequestTemplate"</span>
00015 <span class="comment">//         with the name of the new class</span>
00016 <span class="comment">//******************************************************************************</span>
00017 
00018  
00019 <span class="comment">//******************************************************************************</span>
00020 <span class="comment">// STEP 2: Replace the name of the include file for the class declaration</span>
00021 <span class="comment">//</span>
00022 <span class="comment">//******************************************************************************</span>
00023 <span class="preprocessor">#include "<a class="code" href="request__template_8h.html">request_template.h</a>"</span>
00024 
00025 
00026 <span class="comment">// THIS INCLUDE IS USED FOR THIS EXAMPLE, AND MAY NOT BE NEEDED FOR REAL</span>
00027 <span class="comment">// IMPLEMENTATIONS.</span>
00028 <span class="preprocessor">#include &lt;string.h&gt;</span>
00029 
00030 <span class="comment">//******************************************************************************</span>
00031 <span class="comment">// STEP 3: Update the constructor to initialize all variables that were</span>
00032 <span class="comment">//         declared in the .h (Base classes will initialize their own </span>
00033 <span class="comment">//         variables as needed).</span>
00034 <span class="comment">//</span>
00035 <span class="comment">//******************************************************************************</span>
00036 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00037"></a><a class="code" href="classRequestTemplate.html#a0">00037</a> <a class="code" href="classRequestTemplate.html#a0">RequestTemplate::RequestTemplate</a>()
00038 {
00039    <span class="comment">// Any pointers that will reference memory allocated by this class</span>
00040    <span class="comment">// MUST be NULLified here.</span>
00041    <a class="code" href="classRequestTemplate.html#n0">MyInt</a> = 0;
00042    <a class="code" href="classRequestTemplate.html#n1">MyCharPointer</a> = NULL; <span class="comment">// allocated in SetMyString()</span>
00043    <a class="code" href="classRequestTemplate.html#n2">MyStringLength</a> = -1;  <span class="comment">// indicates not even end-of-string  </span>
00044 }
00045 
00046 <span class="comment">//******************************************************************************</span>
00047 <span class="comment">// STEP 4: If the destructor declaration was included in the .h file,</span>
00048 <span class="comment">//         implement it here, otherwise remove this method.</span>
00049 <span class="comment">//</span>
00050 <span class="comment">//******************************************************************************</span>
00051 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00052"></a><a class="code" href="classRequestTemplate.html#a1">00052</a> <a class="code" href="classRequestTemplate.html#a1">RequestTemplate::~RequestTemplate</a>()
00053 {
00054    <span class="keywordflow">if</span> ( <a class="code" href="classRequestTemplate.html#n1">MyCharPointer</a> != NULL )
00055    {
00056       <span class="keyword">delete</span> [] <a class="code" href="classRequestTemplate.html#n1">MyCharPointer</a>;
00057    }
00058    <span class="comment">// The class can't be used after destruction, so there is no need</span>
00059    <span class="comment">// to set MyCharPointer back to NULL.</span>
00060 }
00061 
00062 <span class="comment">//******************************************************************************</span>
00063 <span class="comment">// STEP 5: Implement the accessor methods declared for this specific class:</span>
00064 <span class="comment">//         (there are four of them for this example)</span>
00065 <span class="comment">//</span>
00066 <span class="comment">//******************************************************************************</span>
00067 
00068 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00069"></a><a class="code" href="classRequestTemplate.html#a2">00069</a> <span class="keywordtype">void</span> <a class="code" href="classRequestTemplate.html#a2">RequestTemplate::SetMyInteger</a>( <span class="keywordtype">int</span> p_int ) { <a class="code" href="classRequestTemplate.html#n0">MyInt</a> = p_int; }
00070 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00071"></a><a class="code" href="classRequestTemplate.html#a3">00071</a> <span class="keywordtype">bool</span> <a class="code" href="classRequestTemplate.html#a3">RequestTemplate::SetMyString</a>( <span class="keyword">const</span> <span class="keywordtype">char</span> * p_str )
00072 {
00073    <span class="keywordtype">bool</span> return_status = <span class="keyword">true</span>;  <span class="comment">// assume good, unless error encountered</span>
00074    
00075    <span class="keywordflow">if</span> (   p_str == NULL
00076        || <a class="code" href="classRequestTemplate.html#n2">MyStringLength</a> &lt; strlen(p_str)
00077       )
00078    {
00079       <span class="comment">// Attempting to set the string to NULL</span>
00080       <span class="comment">// Or the buffer is not large enough to contain it</span>
00081       
00082       <span class="comment">// Drop any unrequired memory</span>
00083       
00084       <span class="keywordflow">if</span> ( <a class="code" href="classRequestTemplate.html#n1">MyCharPointer</a> != NULL )
00085       {
00086          <span class="keyword">delete</span> [] <a class="code" href="classRequestTemplate.html#n1">MyCharPointer</a>;
00087          
00088          <span class="comment">// MUST set the pointer to NULL to prevent a second</span>
00089          <span class="comment">// attempt to deallocate when the destructor is called.</span>
00090          <a class="code" href="classRequestTemplate.html#n1">MyCharPointer</a> = NULL;
00091       }
00092       
00093       <a class="code" href="classRequestTemplate.html#n2">MyStringLength</a> = -1;
00094    }
00095    
00096    
00097    <span class="keywordflow">if</span> ( p_str != NULL )
00098    {
00099       <span class="comment">// Attempting to set the string to something</span>
00100       <span class="comment">//</span>
00101      
00102       <span class="comment">// [re]-allocate the buffer if needed</span>
00103       
00104       <span class="keywordflow">if</span> ( <a class="code" href="classRequestTemplate.html#n1">MyCharPointer</a> == NULL )
00105       {
00106          <a class="code" href="classRequestTemplate.html#n2">MyStringLength</a> = strlen(p_str);
00107          
00108          <span class="keywordflow">if</span> ( (<a class="code" href="classRequestTemplate.html#n1">MyCharPointer</a> = <span class="keyword">new</span> <span class="keywordtype">char</span>[ <a class="code" href="classRequestTemplate.html#n2">MyStringLength</a> + 1 ]) == NULL )
00109          {
00110             <span class="comment">// failed to get buffer memory</span>
00111             return_status = <span class="keyword">false</span>;
00112          }
00113       }
00114       
00115       <span class="keywordflow">if</span> ( <a class="code" href="classRequestTemplate.html#n1">MyCharPointer</a> != NULL )
00116       {
00117          <span class="comment">// Have a buffer, assume it is of sufficient length.</span>
00118          <span class="comment">// Copy the string into the memory</span>
00119          
00120          strcpy( MyCharPointer, p_str );
00121       }
00122    }
00123    
00124    <span class="keywordflow">return</span> return_status;
00125 }
00126 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00127"></a><a class="code" href="classRequestTemplate.html#a4">00127</a> <span class="keywordtype">int</span> <a class="code" href="classRequestTemplate.html#a4">RequestTemplate::GetMyInteger</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classRequestTemplate.html#n0">MyInt</a>; }
00128 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00129"></a><a class="code" href="classRequestTemplate.html#a5">00129</a> <span class="keywordtype">char</span> * <a class="code" href="classRequestTemplate.html#a5">RequestTemplate::GetMyString</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classRequestTemplate.html#n1">MyCharPointer</a>; }
00130 
00131 <span class="comment">//******************************************************************************</span>
00132 <span class="comment">// STEP 6: Implement the virtual methods that were declared but not defined</span>
00133 <span class="comment">//         in the Base classes from which this one is derived.</span>
00134 <span class="comment">//         (Deriving from MutableServerRequest means there are three, there may</span>
00135 <span class="comment">//         be a different number for a different base class).</span>
00136 <span class="comment">//</span>
00137 <span class="comment">//******************************************************************************</span>
00138 
00139 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00140"></a><a class="code" href="classRequestTemplate.html#b0">00140</a> <span class="keywordtype">long</span> <a class="code" href="classRequestTemplate.html#b0">RequestTemplate::BufferInitAlloc</a>()
00141 {
00142    <span class="keywordtype">long</span> ExpectedBufferLength = 0;
00143    
00144    <span class="comment">// First, call the immediate base class's method to get the buffer length</span>
00145    <span class="comment">// required by all base classes.</span>
00146    <span class="comment">// </span>
00147    <span class="comment">// THIS CALL MUST BE INCLUDED IN THIS METHOD,</span>
00148    <span class="comment">// AND IT MUST BE CALLED FOR THE CLASS FROM WHICH THIS ONE IS DERIVED.</span>
00149    <span class="comment">//</span>
00150    ExpectedBufferLength = <a class="code" href="classMutableServerRequest.html#b0">MutableServerRequest::BufferInitAlloc</a>();
00151   
00152   
00153    <span class="comment">// NOW, ADD THE ADDITIONAL BUFFER LENGTH NEEDED BY THIS CLASS</span>
00154    <span class="comment">//</span>
00155    <span class="comment">// FOR SIMPLE MESSAGE CLASSES, THIS METHOD MIGHT BE SIMPLER.</span>
00156    <span class="comment">// THE MAIN PURPOSE OF THE METHOD IS HELP REDUCE MEMORY REALLOCATIONS</span>
00157    <span class="comment">// WHEN THE FINAL LENGTH OF THE MESSAGE IS UNKNOWN AT CODE TIME.</span>
00158    <span class="comment">// FOR EXAMPLE, FOR MESSAGES THAT MIGHT HAVE ANY NUMBER OF DATA VALUES</span>
00159    <span class="comment">// (i.e. like a message with zero or n passport lines).</span>
00160    <span class="comment">//</span>
00161    
00162    
00163    <span class="comment">// For this example, assume that MyInt won't be more than 15 digits:</span>
00164    
00165    ExpectedBufferLength += 15;
00166    
00167    <span class="comment">// Presuming that the int and string values for this class will be</span>
00168    <span class="comment">// separated by '\n', add the length needed for that single char:</span>
00169    
00170    ExpectedBufferLength += 1;
00171    
00172    <span class="comment">// Add then length of the string, if the string is not NULL</span>
00173    
00174    <span class="keywordflow">if</span> ( <a class="code" href="classRequestTemplate.html#n1">MyCharPointer</a> != NULL )
00175    {
00176       ExpectedBufferLength += strlen( MyCharPointer );
00177    }
00178 
00179    <span class="comment">// For this example, assume that we will always have an empty line</span>
00180    <span class="comment">// even if the string contents are NULL</span>
00181    ExpectedBufferLength += 1;  <span class="comment">// '\n'</span>
00182 
00183    
00184    <span class="keywordflow">return</span> ExpectedBufferLength;
00185 }
00186 <span class="comment">//------------------------------------------------------------------------------</span>
<a name="l00187"></a><a class="code" href="classRequestTemplate.html#b1">00187</a> <span class="keywordtype">void</span> <a class="code" href="classRequestTemplate.html#b1">RequestTemplate::FormatDerivativeData</a>()
00188 {
00189    <span class="comment">// First, prepare the leading part of the buffer....that is, prepare</span>
00190    <span class="comment">// the buffer part used by the base class(es):</span>
00191    <span class="comment">//</span>
00192    <span class="comment">// THIS CALL MUST BE PERFORMED AT THE START OF THIS METHOD,</span>
00193    <span class="comment">// AND IT MUST BE CALLED FOR THE CLASS FROM WHICH THIS ONE IS DERIVED.</span>
00194    <span class="comment">//</span>
00195    <a class="code" href="classMutableServerRequest.html#b1">MutableServerRequest::FormatDerivativeData</a>();
00196    
00197    <span class="comment">// NOW FORMAT AND APPEND THE BUFFER CONTENTS FOR THIS CLASS.</span>
00198    
00199    <span class="comment">// For this example, we've got an int and possibly a char string.</span>
00200    <span class="comment">// Each of which will be on a "line" terminated with '\n'</span>
00201    
00202    <span class="comment">// THE ACTUAL BUFFER IS IMPLEMENTED WITH A C++ basic_string TYPE.</span>
00203    <span class="comment">// A CHAR VALUE MAY BE APPENDED TO THE BUFFER WITH += AS SHOWN:</span>
00204    
00205    <span class="keywordtype">char</span> _myint[18];  
00206    
00207    <span class="comment">// format the MyInt line (including the line terminator)</span>
00208    <span class="comment">//</span>
00209    sprintf( _myint, <span class="stringliteral">"%d\n MyInt );</span>
00210 <span class="stringliteral">   </span>
00211 <span class="stringliteral">   MessageBuffer += _myint;</span>
00212 <span class="stringliteral"></span>
00213 <span class="stringliteral">   // Add the string, if it is not null</span>
00214 <span class="stringliteral">   </span>
00215 <span class="stringliteral">   if ( MyCharPointer != NULL )</span>
00216 <span class="stringliteral">   {</span>
00217 <span class="stringliteral">      MessageBuffer += MyCharPointer;</span>
00218 <span class="stringliteral">   }</span>
00219 <span class="stringliteral">   </span>
00220 <span class="stringliteral">   // Terminate the string line</span>
00221 <span class="stringliteral">   </span>
00222 <span class="stringliteral">   MessageBuffer += "</span>\n<span class="stringliteral">";</span>
00223 <span class="stringliteral">   </span>
00224 <span class="stringliteral">   // THE BASE CLASS PROCESSING WILL TERMINATE THE ENTIRE MESSAGE</span>
00225 <span class="stringliteral">   // WITH AN ADDITIONAL '\N'</span>
00226 <span class="stringliteral">   </span>
00227 <span class="stringliteral">}</span>
00228 <span class="stringliteral">//------------------------------------------------------------------------------</span>
00229 <span class="stringliteral">void RequestTemplate::ParseDerivativeData()</span>
00230 <span class="stringliteral">{</span>
00231 <span class="stringliteral">   // First, parse the leading part of the buffer....that is,</span>
00232 <span class="stringliteral">   // the buffer part used by the base class(es):</span>
00233 <span class="stringliteral">   //</span>
00234 <span class="stringliteral">   // THIS CALL MUST BE PERFORMED AT THE START OF THIS METHOD,</span>
00235 <span class="stringliteral">   // AND IT MUST BE CALLED FOR THE CLASS FROM WHICH THIS ONE IS DERIVED.</span>
00236 <span class="stringliteral">   //</span>
00237 <span class="stringliteral">   MutableServerRequest::ParseDerivativeData();</span>
00238 <span class="stringliteral"></span>
00239 <span class="stringliteral">   long _index;            // end of line index</span>
00240 <span class="stringliteral">   std::string _readline;  // work buffer</span>
00241 <span class="stringliteral">   </span>
00242 <span class="stringliteral">   // NOW PARSE THE PORTION OF THE BUFFER RELEVANT TO THIS MESSAGE CLASS</span>
00243 <span class="stringliteral"></span>
00244 <span class="stringliteral">   // NOTE THAT ALL ERRORS ARE REPORTED BY THROWING A worm_exception OBJECT.</span>
00245 <span class="stringliteral">   // THERE ARE TWO WAYS TO FORMAT THE ERROR MESSAGE CONTAINED THEREIN, BOTH</span>
00246 <span class="stringliteral">   // ARE DEMONSTRATE HEREIN.</span>
00247 <span class="stringliteral">   // </span>
00248 <span class="stringliteral">   // FYI, THE worm_exception IS CAUGHT AND REPORTED BY THE SERVER</span>
00249 <span class="stringliteral"></span>
00250 <span class="stringliteral">   </span>
00251 <span class="stringliteral">   // - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
00252 <span class="stringliteral">   // Handle the example's first data line</span>
00253 <span class="stringliteral"></span>
00254 <span class="stringliteral"></span>
00255 <span class="stringliteral">   // Find the end of the next line in the buffer</span>
00256 <span class="stringliteral">   //</span>
00257 <span class="stringliteral">   if ( (_index = MessageBuffer.find("</span>\n<span class="stringliteral">")) == MessageBuffer.npos )</span>
00258 <span class="stringliteral">   {</span>
00259 <span class="stringliteral">      // First way to throw a worm_exception object</span>
00260 <span class="stringliteral">      throw worm_exception("</span>Unterminated message <span class="keywordflow">while</span> parsing <a class="code" href="classRequestTemplate.html">RequestTemplate</a> MyInt line<span class="stringliteral">");</span>
00261 <span class="stringliteral">   }   </span>
00262 <span class="stringliteral">   </span>
00263 <span class="stringliteral">   // extract the line from the buffer</span>
00264 <span class="stringliteral">   //</span>
00265 <span class="stringliteral">   _readline = MessageBuffer.substr( 0 , _index );</span>
00266 <span class="stringliteral">   </span>
00267 <span class="stringliteral"></span>
00268 <span class="stringliteral">   // Remove the line from the buffer</span>
00269 <span class="stringliteral">   //</span>
00270 <span class="stringliteral">   MessageBuffer.erase( 0 , _index + 1 );</span>
00271 <span class="stringliteral">   </span>
00272 <span class="stringliteral">   </span>
00273 <span class="stringliteral">   // Parse the line's value  (MyInt)</span>
00274 <span class="stringliteral">   //</span>
00275 <span class="stringliteral">   if ( sscanf( _readline.c_str(), "</span>%d<span class="stringliteral">", &amp;MyInt ) != 1 )</span>
00276 <span class="stringliteral">   {</span>
00277 <span class="stringliteral">      // Second way to throw a worm_exception object -- append string (int, float) value</span>
00278 <span class="stringliteral">      worm_exception my_exception("</span>RequestTemplate::ParseDerivativeData() Error: <span class="stringliteral">");</span>
00279 <span class="stringliteral">                     my_exception += "</span>Failed to parse MyInt value<span class="stringliteral">";</span>
00280 <span class="stringliteral">      throw my_exception;</span>
00281 <span class="stringliteral">   }</span>
00282 <span class="stringliteral">   </span>
00283 <span class="stringliteral">   </span>
00284 <span class="stringliteral">   // - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
00285 <span class="stringliteral">   // Handle the example's second data line</span>
00286 <span class="stringliteral">   //    (the string value [which may be empty])</span>
00287 <span class="stringliteral">   </span>
00288 <span class="stringliteral">   // Find then end of the next line in the buffer</span>
00289 <span class="stringliteral">   //</span>
00290 <span class="stringliteral">   if ( (_index = MessageBuffer.find("</span>\n<span class="stringliteral">")) == MessageBuffer.npos )</span>
00291 <span class="stringliteral">   {</span>
00292 <span class="stringliteral">      throw worm_exception("</span>Unterminated message <span class="keywordflow">while</span> parsing <a class="code" href="classRequestTemplate.html">RequestTemplate</a> MyString line<span class="stringliteral">");</span>
00293 <span class="stringliteral">   }</span>
00294 <span class="stringliteral"></span>
00295 <span class="stringliteral">   // extract the line from the buffer</span>
00296 <span class="stringliteral">   //</span>
00297 <span class="stringliteral">   _readline = MessageBuffer.substr( 0 , _index );</span>
00298 <span class="stringliteral"></span>
00299 <span class="stringliteral">   // Remove the line from the buffer</span>
00300 <span class="stringliteral">   //</span>
00301 <span class="stringliteral">   MessageBuffer.erase( 0 , _index + 1 );</span>
00302 <span class="stringliteral"></span>
00303 <span class="stringliteral">   // Set the string value</span>
00304 <span class="stringliteral">   //</span>
00305 <span class="stringliteral">   if ( _readline.size() == 0 )</span>
00306 <span class="stringliteral">   {</span>
00307 <span class="stringliteral">      // empty line      </span>
00308 <span class="stringliteral">      SetMyString( NULL );</span>
00309 <span class="stringliteral">   }</span>
00310 <span class="stringliteral">   else</span>
00311 <span class="stringliteral">   {</span>
00312 <span class="stringliteral">      // something in the line</span>
00313 <span class="stringliteral">      SetMyString( _readline.c_str() );</span>
00314 <span class="stringliteral">   }</span>
00315 <span class="stringliteral">   </span>
00316 <span class="stringliteral">   // Any remaining buffer (resulting from further class derivation or</span>
00317 <span class="stringliteral">   // just the end-of-message '\n') parse elsewhere</span>
00318 <span class="stringliteral">}</span>
00319 <span class="stringliteral">//------------------------------------------------------------------------------</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue May 6 09:16:07 2003 for Earthworm Libs by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc3 </small></address>
</body>
</html>
