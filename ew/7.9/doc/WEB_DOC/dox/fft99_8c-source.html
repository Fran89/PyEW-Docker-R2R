<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>fft99.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>fft99.c</h1><a href="fft99_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *   THIS FILE IS UNDER RCS - DO NOT MODIFY UNLESS YOU HAVE</span>
00003 <span class="comment"> *   CHECKED IT OUT USING THE COMMAND CHECKOUT.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *    $Id: fft99_8c-source.html 2161 2006-05-19 16:55:03Z paulf $</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *    Revision history:</span>
00008 <span class="comment"> *     $Log$
00008 <span class="comment"> *     Revision 1.1  2006/05/19 16:55:01  paulf
00008 <span class="comment"> *     first inclusion
00008 <span class="comment"> *</span>
00009 <span class="comment"> *     Revision 1.1  2001/03/31 00:46:48  lombard</span>
00010 <span class="comment"> *     Initial revision</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> */</span>
00015 
00016 <span class="comment">/* fft99.f -- translated by f2c (version 19991025).*/</span>
00017 <span class="comment">/*</span>
00018 <span class="comment"> * Hand-editted after f2c to make it look a little more like C.</span>
00019 <span class="comment"> * But there is no hiding the fact that this was once Fortran.</span>
00020 <span class="comment"> * Read the comments with caution! Pete Lombard, January 2001</span>
00021 <span class="comment"> */</span>
00022 <span class="preprocessor">#include &lt;math.h&gt;</span>
00023 <span class="preprocessor">#include "<a class="code" href="fft99_8h.html">fft99.h</a>"</span>
00024 
00025 <span class="comment">/* Internal function prototypes */</span>
00026 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a0">fact</a>(<span class="keywordtype">long</span> n, <span class="keywordtype">long</span> *ifax);
00027 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a1">cftrig</a>(<span class="keywordtype">long</span> n, <span class="keywordtype">double</span> *trigs);
00028 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a2">vpassm</a>(<span class="keywordtype">double</span> *a, <span class="keywordtype">double</span> *b, <span class="keywordtype">double</span> *c, <span class="keywordtype">double</span> *d, 
00029                    <span class="keywordtype">double</span> *trigs, <span class="keywordtype">long</span> inc1, <span class="keywordtype">long</span> inc2, <span class="keywordtype">long</span> inc3, <span class="keywordtype">long</span> inc4, 
00030                    <span class="keywordtype">long</span> lot, <span class="keywordtype">long</span> n, <span class="keywordtype">long</span> ifac, <span class="keywordtype">long</span> la);
00031 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a3">fft99a</a>(<span class="keywordtype">double</span> *a, <span class="keywordtype">double</span> *work, <span class="keywordtype">double</span> *trigs, <span class="keywordtype">long</span> inc, <span class="keywordtype">long</span> jump,
00032                    <span class="keywordtype">long</span> n, <span class="keywordtype">long</span> lot);
00033 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a4">fft99b</a>(<span class="keywordtype">double</span> *work, <span class="keywordtype">double</span> *a, <span class="keywordtype">double</span> *trigs, <span class="keywordtype">long</span> inc, <span class="keywordtype">long</span> jump,
00034                    <span class="keywordtype">long</span> n, <span class="keywordtype">long</span> lot);
00035 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a5">fax</a>(<span class="keywordtype">long</span> *ifax, <span class="keywordtype">long</span> n);
00036 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a6">fftrig</a>(<span class="keywordtype">double</span> *trigs, <span class="keywordtype">long</span> n);
00037 
00038 
00039 <span class="comment">/* Function definitions */</span>
<a name="l00040"></a><a class="code" href="fft99_8c.html#a7">00040</a> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a7">cfft99</a>(<span class="keywordtype">double</span> *a, <span class="keywordtype">double</span> *work, <span class="keywordtype">double</span> *trigs, <span class="keywordtype">long</span> *ifax, <span class="keywordtype">long</span> inc, 
00041             <span class="keywordtype">long</span> jump, <span class="keywordtype">long</span> n, <span class="keywordtype">long</span> lot, <span class="keywordtype">long</span> isign)
00042 {
00043   <span class="comment">/* Local variables */</span>
00044   <span class="keyword">static</span> <span class="keywordtype">long</span> nfax, i, j, k, l, m, ibase, jbase;
00045   <span class="keyword">static</span> <span class="keywordtype">double</span> himag, hreal;
00046   <span class="keyword">static</span> <span class="keywordtype">long</span> ilast, i1, i2, la, nh, nn;
00047   <span class="keyword">static</span> <span class="keywordtype">long</span> igo, ink, jnk, jum, jst;
00048 
00049 
00050   <span class="comment">/* PURPOSE      PERFORMS MULTIPLE FAST FOURIER TRANSFORMS.  THIS PACKAGE </span>
00051 <span class="comment"> *              WILL PERFORM A NUMBER OF SIMULTANEOUS COMPLEX PERIODIC </span>
00052 <span class="comment"> *              FOURIER TRANSFORMS OR CORRESPONDING INVERSE TRANSFORMS. </span>
00053 <span class="comment"> *              THAT IS, GIVEN A SET OF COMPLEX GRIDPOINT VECTORS, THE </span>
00054 <span class="comment"> *              PACKAGE RETURNS A SET OF COMPLEX FOURIER </span>
00055 <span class="comment"> *              COEFFICIENT VECTORS, OR VICE VERSA.  THE LENGTH OF THE </span>
00056 <span class="comment"> *              TRANSFORMS MUST BE A NUMBER GREATER THAN 1 THAT HAS </span>
00057 <span class="comment"> *              NO PRIME FACTORS OTHER THAN 2, 3, AND 5. </span>
00058 <span class="comment"> *</span>
00059 <span class="comment"> *              THE PACKAGE CFFT99 CONTAINS SEVERAL USER-LEVEL ROUTINES: </span>
00060 <span class="comment"> *</span>
00061 <span class="comment"> *            CFTFAX </span>
00062 <span class="comment"> *                AN INITIALIZATION ROUTINE THAT MUST BE CALLED ONCE </span>
00063 <span class="comment"> *                BEFORE A SEQUENCE OF CALLS TO CFFT99 </span>
00064 <span class="comment"> *                (PROVIDED THAT N IS NOT CHANGED). </span>
00065 <span class="comment"> *</span>
00066 <span class="comment"> *            CFFT99 </span>
00067 <span class="comment"> *                THE ACTUAL TRANSFORM ROUTINE ROUTINE, CABABLE OF </span>
00068 <span class="comment"> *                PERFORMING BOTH THE TRANSFORM AND ITS INVERSE. </span>
00069 <span class="comment"> *                HOWEVER, AS THE TRANSFORMS ARE NOT NORMALIZED, </span>
00070 <span class="comment"> *                THE APPLICATION OF A TRANSFORM FOLLOWED BY ITS </span>
00071 <span class="comment"> *                INVERSE WILL YIELD THE ORIGINAL VALUES MULTIPLIED </span>
00072 <span class="comment"> *                BY N. </span>
00073 <span class="comment"> *</span>
00074 <span class="comment"> *</span>
00075 <span class="comment"> *</span>
00076 <span class="comment"> * USAGE        LET N BE OF THE FORM 2**P * 3**Q * 5**R, WHERE P .GE. 0, </span>
00077 <span class="comment"> *              Q .GE. 0, AND R .GE. 0.  THEN A TYPICAL SEQUENCE OF </span>
00078 <span class="comment"> *              CALLS TO TRANSFORM A GIVEN SET OF COMPLEX VECTORS OF </span>
00079 <span class="comment"> *              LENGTH N TO A SET OF (UNSCALED) COMPLEX FOURIER </span>
00080 <span class="comment"> *              COEFFICIENT VECTORS OF LENGTH N IS </span>
00081 <span class="comment"> *</span>
00082 <span class="comment"> *                   long ifax[13];</span>
00083 <span class="comment"> *                   double trigs[2*n];</span>
00084 <span class="comment"> *                   double a[...], work[...]</span>
00085 <span class="comment"> *</span>
00086 <span class="comment"> *                   cftfax (n, ifax, trigs);</span>
00087 <span class="comment"> *                   cfft99 (a,work,trigs,ifax,inc,jump,n,lot,isign);</span>
00088 <span class="comment"> *</span>
00089 <span class="comment"> *              THE OUTPUT VECTORS OVERWRITE THE INPUT VECTORS, AND </span>
00090 <span class="comment"> *              THESE ARE STORED IN A.  WITH APPROPRIATE CHOICES FOR </span>
00091 <span class="comment"> *              THE OTHER ARGUMENTS, THESE VECTORS MAY BE CONSIDERED </span>
00092 <span class="comment"> *              EITHER THE ROWS OR THE COLUMNS OF THE ARRAY A. </span>
00093 <span class="comment"> *              SEE THE INDIVIDUAL WRITE-UPS FOR CFTFAX AND </span>
00094 <span class="comment"> *              CFFT99 BELOW, FOR A DETAILED DESCRIPTION OF THE </span>
00095 <span class="comment"> *              ARGUMENTS. </span>
00096 <span class="comment"> *</span>
00097 <span class="comment"> * HISTORY      THE PACKAGE WAS WRITTEN BY CLIVE TEMPERTON AT ECMWF IN </span>
00098 <span class="comment"> *              NOVEMBER, 1978.  IT WAS MODIFIED, DOCUMENTED, AND TESTED </span>
00099 <span class="comment"> *              FOR NCAR BY RUSS REW IN SEPTEMBER, 1980.  IT WAS </span>
00100 <span class="comment"> *              FURTHER MODIFIED FOR THE FULLY COMPLEX CASE BY DAVE </span>
00101 <span class="comment"> *              FULKER IN NOVEMBER, 1980. </span>
00102 <span class="comment"> *</span>
00103 <span class="comment"> * ----------------------------------------------------------------------- </span>
00104 <span class="comment"> *</span>
00105 <span class="comment"> *  cftfax (n,ifax,trigs) </span>
00106 <span class="comment"> *</span>
00107 <span class="comment"> * PURPOSE      A SET-UP ROUTINE FOR CFFT99.  IT NEED ONLY BE </span>
00108 <span class="comment"> *              CALLED ONCE BEFORE A SEQUENCE OF CALLS TO CFFT99, </span>
00109 <span class="comment"> *              PROVIDED THAT N IS NOT CHANGED. </span>
00110 <span class="comment"> *</span>
00111 <span class="comment"> * ARGUMENT     long ifax[13]; double trigs[2*n];</span>
00112 <span class="comment"> * DIMENSIONS </span>
00113 <span class="comment"> *</span>
00114 <span class="comment"> * ARGUMENTS </span>
00115 <span class="comment"> *</span>
00116 <span class="comment"> * ON INPUT     N </span>
00117 <span class="comment"> *               AN EVEN NUMBER GREATER THAN 1 THAT HAS NO PRIME FACTOR </span>
00118 <span class="comment"> *               GREATER THAN 5.  N IS THE LENGTH OF THE TRANSFORMS (SEE </span>
00119 <span class="comment"> *               THE DOCUMENTATION FOR CFFT99 FOR THE DEFINITION OF </span>
00120 <span class="comment"> *               THE TRANSFORMS). </span>
00121 <span class="comment"> *</span>
00122 <span class="comment"> *              IFAX </span>
00123 <span class="comment"> *               AN INTEGER ARRAY.  THE NUMBER OF ELEMENTS ACTUALLY USED </span>
00124 <span class="comment"> *               WILL DEPEND ON THE FACTORIZATION OF N.  DIMENSIONING </span>
00125 <span class="comment"> *               IFAX FOR 13 SUFFICES FOR ALL N LESS THAN 1 MILLION. </span>
00126 <span class="comment"> *</span>
00127 <span class="comment"> *              TRIGS </span>
00128 <span class="comment"> *               AN ARRAY OF DIMENSION 2*N </span>
00129 <span class="comment"> *</span>
00130 <span class="comment"> * ON OUTPUT    IFAX </span>
00131 <span class="comment"> *               CONTAINS THE FACTORIZATION OF N.  IFAX[0] IS THE </span>
00132 <span class="comment"> *               NUMBER OF FACTORS, AND THE FACTORS THEMSELVES ARE STORED </span>
00133 <span class="comment"> *               IN IFAX[1],IFAX[2],...  IF N HAS ANY PRIME FACTORS </span>
00134 <span class="comment"> *               GREATER THAN 5, IFAX[0] IS SET TO -99. </span>
00135 <span class="comment"> *</span>
00136 <span class="comment"> *              TRIGS </span>
00137 <span class="comment"> *               AN ARRAY OF TRIGONOMETRIC FUNCTION VALUES SUBSEQUENTLY </span>
00138 <span class="comment"> *               USED BY THE CFT ROUTINES. </span>
00139 <span class="comment"> *</span>
00140 <span class="comment"> * ----------------------------------------------------------------------- </span>
00141 <span class="comment"> *</span>
00142 <span class="comment"> * cfft99 (a,work,trigs,ifax,inc,jump,n,lot,isign) </span>
00143 <span class="comment"> *</span>
00144 <span class="comment"> * PURPOSE      PERFORM A NUMBER OF SIMULTANEOUS (UNNORMALIZED) COMPLEX </span>
00145 <span class="comment"> *              PERIODIC FOURIER TRANSFORMS OR CORRESPONDING INVERSE </span>
00146 <span class="comment"> *              TRANSFORMS.  GIVEN A SET OF COMPLEX GRIDPOINT </span>
00147 <span class="comment"> *              VECTORS, THE PACKAGE RETURNS A SET OF </span>
00148 <span class="comment"> *              COMPLEX FOURIER COEFFICIENT VECTORS, OR VICE </span>
00149 <span class="comment"> *              VERSA.  THE LENGTH OF THE TRANSFORMS MUST BE A </span>
00150 <span class="comment"> *              NUMBER HAVING NO PRIME FACTORS OTHER THAN </span>
00151 <span class="comment"> *              2, 3, AND 5.  THIS ROUTINE IS </span>
00152 <span class="comment"> *              OPTIMIZED FOR USE ON THE CRAY-1. </span>
00153 <span class="comment"> *</span>
00154 <span class="comment"> * ARGUMENT     double a[2*n*inc+(lot-1)*jump], work[2*n*lot]</span>
00155 <span class="comment"> * DIMENSIONS   double trigs[2*n], long ifax[13]</span>
00156 <span class="comment"> *</span>
00157 <span class="comment"> * ARGUMENTS </span>
00158 <span class="comment"> *</span>
00159 <span class="comment"> * ON INPUT     A </span>
00160 <span class="comment"> *               A COMPLEX ARRAY OF LENGTH N*INC+(LOT-1)*JUMP CONTAINING </span>
00161 <span class="comment"> *               THE INPUT GRIDPOINT OR COEFFICIENT VECTORS.  THIS ARRAY </span>
00162 <span class="comment"> *               OVERWRITTEN BY THE RESULTS. </span>
00163 <span class="comment"> *</span>
00164 <span class="comment"> *               N.B. ALTHOUGH THE ARRAY A IS USUALLY CONSIDERED TO BE OF </span>
00165 <span class="comment"> *               TYPE COMPLEX IN THE CALLING PROGRAM, IT IS TREATED AS </span>
00166 <span class="comment"> *               REAL WITHIN THE TRANSFORM PACKAGE.  THIS REQUIRES THAT </span>
00167 <span class="comment"> *               SUCH TYPE CONFLICTS ARE PERMITTED IN THE USER^S </span>
00168 <span class="comment"> *               ENVIRONMENT, AND THAT THE STORAGE OF COMPLEX NUMBERS </span>
00169 <span class="comment"> *               MATCHES THE ASSUMPTIONS OF THIS ROUTINE.  THIS ROUTINE </span>
00170 <span class="comment"> *               ASSUMES THAT THE REAL AND IMAGINARY PORTIONS OF A </span>
00171 <span class="comment"> *               COMPLEX NUMBER OCCUPY ADJACENT ELEMENTS OF MEMORY.  IF </span>
00172 <span class="comment"> *               THESE CONDITIONS ARE NOT MET, THE USER MUST TREAT THE </span>
00173 <span class="comment"> *               ARRAY A AS REAL (AND OF TWICE THE ABOVE LENGTH), AND </span>
00174 <span class="comment"> *               WRITE THE CALLING PROGRAM TO TREAT THE REAL AND </span>
00175 <span class="comment"> *               IMAGINARY PORTIONS EXPLICITLY. </span>
00176 <span class="comment"> *</span>
00177 <span class="comment"> *              WORK </span>
00178 <span class="comment"> *               A COMPLEX WORK ARRAY OF LENGTH N*LOT OR A REAL ARRAY </span>
00179 <span class="comment"> *               OF LENGTH 2*N*LOT.  SEE N.B. ABOVE. </span>
00180 <span class="comment"> *</span>
00181 <span class="comment"> *              TRIGS </span>
00182 <span class="comment"> *               AN ARRAY SET UP BY CFTFAX, WHICH MUST BE CALLED FIRST. </span>
00183 <span class="comment"> *</span>
00184 <span class="comment"> *              IFAX </span>
00185 <span class="comment"> *               AN ARRAY SET UP BY CFTFAX, WHICH MUST BE CALLED FIRST. </span>
00186 <span class="comment"> *</span>
00187 <span class="comment"> *</span>
00188 <span class="comment"> *               N.B. IN THE FOLLOWING ARGUMENTS, INCREMENTS ARE MEASURED </span>
00189 <span class="comment"> *               IN WORD PAIRS, BECAUSE EACH COMPLEX ELEMENT IS ASSUMED </span>
00190 <span class="comment"> *               TO OCCUPY AN ADJACENT PAIR OF WORDS IN MEMORY. </span>
00191 <span class="comment"> *</span>
00192 <span class="comment"> *              INC </span>
00193 <span class="comment"> *               THE INCREMENT (IN WORD PAIRS) BETWEEN SUCCESSIVE ELEMENT </span>
00194 <span class="comment"> *               OF EACH (COMPLEX) GRIDPOINT OR COEFFICIENT VECTOR </span>
00195 <span class="comment"> *               (E.G.  INC=1 FOR CONSECUTIVELY STORED DATA). </span>
00196 <span class="comment"> *</span>
00197 <span class="comment"> *              JUMP </span>
00198 <span class="comment"> *               THE INCREMENT (IN WORD PAIRS) BETWEEN THE FIRST ELEMENTS </span>
00199 <span class="comment"> *               OF SUCCESSIVE DATA OR COEFFICIENT VECTORS.  ON THE CRAY- </span>
00200 <span class="comment"> *               TRY TO ARRANGE DATA SO THAT JUMP IS NOT A MULTIPLE OF 8 </span>
00201 <span class="comment"> *               (TO AVOID MEMORY BANK CONFLICTS).  FOR CLARIFICATION OF </span>
00202 <span class="comment"> *               INC AND JUMP, SEE THE EXAMPLES BELOW. </span>
00203 <span class="comment"> *</span>
00204 <span class="comment"> *              N </span>
00205 <span class="comment"> *               THE LENGTH OF EACH TRANSFORM (SEE DEFINITION OF </span>
00206 <span class="comment"> *               TRANSFORMS, BELOW). </span>
00207 <span class="comment"> *</span>
00208 <span class="comment"> *              LOT </span>
00209 <span class="comment"> *               THE NUMBER OF TRANSFORMS TO BE DONE SIMULTANEOUSLY. </span>
00210 <span class="comment"> *</span>
00211 <span class="comment"> *              ISIGN </span>
00212 <span class="comment"> *               = -1 FOR A TRANSFORM FROM GRIDPOINT VALUES TO FOURIER </span>
00213 <span class="comment"> *                    COEFFICIENTS. </span>
00214 <span class="comment"> *               = +1 FOR A TRANSFORM FROM FOURIER COEFFICIENTS TO </span>
00215 <span class="comment"> *                    GRIDPOINT VALUES. </span>
00216 <span class="comment"> *</span>
00217 <span class="comment"> * ON OUTPUT    A </span>
00218 <span class="comment"> *               IF ISIGN = -1, AND LOT GRIDPOINT VECTORS ARE SUPPLIED, </span>
00219 <span class="comment"> *               EACH CONTAINING THE COMPLEX SEQUENCE: </span>
00220 <span class="comment"> *</span>
00221 <span class="comment"> *               G(0),G(1), ... ,G(N-1)  (N COMPLEX VALUES) </span>
00222 <span class="comment"> *</span>
00223 <span class="comment"> *               THEN THE RESULT CONSISTS OF LOT COMPLEX VECTORS EACH </span>
00224 <span class="comment"> *               CONTAINING THE CORRESPONDING N COEFFICIENT VALUES: </span>
00225 <span class="comment"> *</span>
00226 <span class="comment"> *               C(0),C(1), ... ,C(N-1)  (N COMPLEX VALUES) </span>
00227 <span class="comment"> *</span>
00228 <span class="comment"> *               DEFINED BY: </span>
00229 <span class="comment"> *                 C(K) = SUM(J=0,...,N-1)( G(J)*EXP(-2*I*J*K*PI/N) ) </span>
00230 <span class="comment"> *                 WHERE I = SQRT(-1) </span>
00231 <span class="comment"> *</span>
00232 <span class="comment"> *</span>
00233 <span class="comment"> *               IF ISIGN = +1, AND LOT COEFFICIENT VECTORS ARE SUPPLIED, </span>
00234 <span class="comment"> *               EACH CONTAINING THE COMPLEX SEQUENCE: </span>
00235 <span class="comment"> *</span>
00236 <span class="comment"> *               C(0),C(1), ... ,C(N-1)  (N COMPLEX VALUES) </span>
00237 <span class="comment"> *</span>
00238 <span class="comment"> *               THEN THE RESULT CONSISTS OF LOT COMPLEX VECTORS EACH </span>
00239 <span class="comment"> *               CONTAINING THE CORRESPONDING N GRIDPOINT VALUES: </span>
00240 <span class="comment"> *</span>
00241 <span class="comment"> *               G(0),G(1), ... ,G(N-1)  (N COMPLEX VALUES) </span>
00242 <span class="comment"> *</span>
00243 <span class="comment"> *               DEFINED BY: </span>
00244 <span class="comment"> *                 G(J) = SUM(K=0,...,N-1)( G(K)*EXP(+2*I*J*K*PI/N) ) </span>
00245 <span class="comment"> *                 WHERE I = SQRT(-1) </span>
00246 <span class="comment"> *</span>
00247 <span class="comment"> *</span>
00248 <span class="comment"> *               A CALL WITH ISIGN=-1 FOLLOWED BY A CALL WITH ISIGN=+1 </span>
00249 <span class="comment"> *               (OR VICE VERSA) RETURNS THE ORIGINAL DATA, MULTIPLIED </span>
00250 <span class="comment"> *               BY THE FACTOR N. </span>
00251 <span class="comment"> *</span>
00252 <span class="comment"> *</span>
00253 <span class="comment"> * EXAMPLE       GIVEN A 64 BY 9 GRID OF COMPLEX VALUES, STORED IN </span>
00254 <span class="comment"> *               A 66 BY 9 COMPLEX ARRAY, A, COMPUTE THE TWO DIMENSIONAL </span>
00255 <span class="comment"> *               FOURIER TRANSFORM OF THE GRID.  FROM TRANSFORM THEORY, </span>
00256 <span class="comment"> *               IT IS KNOWN THAT A TWO DIMENSIONAL TRANSFORM CAN BE </span>
00257 <span class="comment"> *               OBTAINED BY FIRST TRANSFORMING THE GRID ALONG ONE </span>
00258 <span class="comment"> *               DIRECTION, THEN TRANSFORMING THESE RESULTS ALONG THE </span>
00259 <span class="comment"> *               ORTHOGONAL DIRECTION. </span>
00260 <span class="comment"> *</span>
00261 <span class="comment"> *               COMPLEX A(66,9), WORK(64,9) </span>
00262 <span class="comment"> *               REAL TRIGS1(128), TRIGS2(18) </span>
00263 <span class="comment"> *               INTEGER IFAX1(13), IFAX2(13) </span>
00264 <span class="comment"> *</span>
00265 <span class="comment"> *               SET UP THE IFAX AND TRIGS ARRAYS FOR EACH DIRECTION: </span>
00266 <span class="comment"> *</span>
00267 <span class="comment"> *               CALL CFTFAX(64, IFAX1, TRIGS1) </span>
00268 <span class="comment"> *               CALL CFTFAX( 9, IFAX2, TRIGS2) </span>
00269 <span class="comment"> *</span>
00270 <span class="comment"> *               IN THIS CASE, THE COMPLEX VALUES OF THE GRID ARE </span>
00271 <span class="comment"> *               STORED IN MEMORY AS FOLLOWS (USING U AND V TO </span>
00272 <span class="comment"> *               DENOTE THE REAL AND IMAGINARY COMPONENTS, AND </span>
00273 <span class="comment"> *               ASSUMING CONVENTIONAL FORTRAN STORAGE): </span>
00274 <span class="comment"> *</span>
00275 <span class="comment"> *   U(1,1), V(1,1), U(2,1), V(2,1),  ...  U(64,1), V(64,1), 4 NULLS, </span>
00276 <span class="comment"> *</span>
00277 <span class="comment"> *   U(1,2), V(1,2), U(2,2), V(2,2),  ...  U(64,2), V(64,2), 4 NULLS, </span>
00278 <span class="comment"> *</span>
00279 <span class="comment"> *   .       .       .       .         .   .        .        . </span>
00280 <span class="comment"> *   .       .       .       .         .   .        .        . </span>
00281 <span class="comment"> *   .       .       .       .         .   .        .        . </span>
00282 <span class="comment"> *</span>
00283 <span class="comment"> *   U(1,9), V(1,9), U(2,9), V(2,9),  ...  U(64,9), V(64,9), 4 NULLS. </span>
00284 <span class="comment"> *</span>
00285 <span class="comment"> *               WE CHOOSE (ARBITRARILY) TO TRANSORM FIRST ALONG THE </span>
00286 <span class="comment"> *               DIRECTION OF THE FIRST SUBSCRIPT.  THUS WE DEFINE </span>
00287 <span class="comment"> *               THE LENGTH OF THE TRANSFORMS, N, TO BE 64, THE </span>
00288 <span class="comment"> *               NUMBER OF TRANSFORMS, LOT, TO BE 9, THE INCREMENT </span>
00289 <span class="comment"> *               BETWEEN ELEMENTS OF EACH TRANSFORM, INC, TO BE 1, </span>
00290 <span class="comment"> *               AND THE INCREMENT BETWEEN THE STARTING POINTS </span>
00291 <span class="comment"> *               FOR EACH TRANSFORM, JUMP, TO BE 66 (THE FIRST </span>
00292 <span class="comment"> *               DIMENSION OF A). </span>
00293 <span class="comment"> *</span>
00294 <span class="comment"> *               CALL CFFT99( A, WORK, TRIGS1, IFAX1, 1, 66, 64, 9, -1) </span>
00295 <span class="comment"> *</span>
00296 <span class="comment"> *               TO TRANSFORM ALONG THE DIRECTION OF THE SECOND SUBSCRIPT </span>
00297 <span class="comment"> *               THE ROLES OF THE INCREMENTS ARE REVERSED.  THUS WE DEFIN </span>
00298 <span class="comment"> *               THE LENGTH OF THE TRANSFORMS, N, TO BE 9, THE </span>
00299 <span class="comment"> *               NUMBER OF TRANSFORMS, LOT, TO BE 64, THE INCREMENT </span>
00300 <span class="comment"> *               BETWEEN ELEMENTS OF EACH TRANSFORM, INC, TO BE 66, </span>
00301 <span class="comment"> *               AND THE INCREMENT BETWEEN THE STARTING POINTS </span>
00302 <span class="comment"> *               FOR EACH TRANSFORM, JUMP, TO BE 1 </span>
00303 <span class="comment"> *</span>
00304 <span class="comment"> *               CALL CFFT99( A, WORK, TRIGS2, IFAX2, 66, 1, 9, 64, -1) </span>
00305 <span class="comment"> *</span>
00306 <span class="comment"> *               THESE TWO SEQUENTIAL STEPS RESULTS IN THE TWO-DIMENSIONA </span>
00307 <span class="comment"> *               FOURIER COEFFICIENT ARRAY OVERWRITING THE INPUT </span>
00308 <span class="comment"> *               GRIDPOINT ARRAY, A.  THE SAME TWO STEPS APPLIED AGAIN </span>
00309 <span class="comment"> *               WITH ISIGN = +1 WOULD RESULT IN THE RECONSTRUCTION OF </span>
00310 <span class="comment"> *               THE GRIDPOINT ARRAY (MULTIPLIED BY A FACTOR OF 64*9). </span>
00311 <span class="comment"> *</span>
00312 <span class="comment"> *</span>
00313 <span class="comment"> * ----------------------------------------------------------------------- </span>
00314 <span class="comment"> */</span>
00315 
00316 <span class="comment">/*     function ^cfft99^ - MULTIPLE FAST COMPLEX FOURIER TRANSFORM </span>
00317 <span class="comment"></span>
00318 <span class="comment"> *     A IS THE ARRAY CONTAINING INPUT AND OUTPUT DATA </span>
00319 <span class="comment"> *     WORK IS AN AREA OF SIZE N*LOT </span>
00320 <span class="comment"> *     TRIGS IS A PREVIOUSLY PREPARED LIST OF TRIG FUNCTION VALUES </span>
00321 <span class="comment"> *     IFAX IS A PREVIOUSLY PREPARED LIST OF FACTORS OF N </span>
00322 <span class="comment"> *     INC IS THE INCREMENT WITHIN EACH DATA #VECTOR# </span>
00323 <span class="comment"> *         (E.G. INC=1 FOR CONSECUTIVELY STORED DATA) </span>
00324 <span class="comment"> *     JUMP IS THE INCREMENT BETWEEN THE START OF EACH DATA VECTOR </span>
00325 <span class="comment"> *     N IS THE LENGTH OF THE DATA VECTORS </span>
00326 <span class="comment"> *     LOT IS THE NUMBER OF DATA VECTORS </span>
00327 <span class="comment"> *     ISIGN = +1 FOR TRANSFORM FROM SPECTRAL TO GRIDPOINT </span>
00328 <span class="comment"> *           = -1 FOR TRANSFORM FROM GRIDPOINT TO SPECTRAL </span>
00329 <span class="comment"> */</span>
00330 
00331 <span class="comment">/*  VECTORIZATION IS ACHIEVED ON CRAY BY DOING THE TRANSFORMS IN  PARALLEL. */</span>
00332 
00333     <span class="comment">/* Parameter adjustments */</span>
00334   --work;
00335   --a;
00336 
00337     <span class="comment">/* Function Body */</span>
00338   nn = n + n;
00339   ink = inc + inc;
00340   jum = jump + jump;
00341   nfax = ifax[0];
00342   jnk = 2;
00343   jst = 2;
00344   <span class="keywordflow">if</span> (isign &gt;= 0) {
00345     <span class="keywordflow">goto</span> L30;
00346   }
00347 
00348   <span class="comment">/*     THE INNERMOST TEMPERTON ROUTINES HAVE NO FACILITY FOR THE */</span>
00349   <span class="comment">/*     FORWARD (ISIGN = -1) TRANSFORM.  THEREFORE, THE INPUT MUST BE */</span>
00350   <span class="comment">/*     REARRANGED AS FOLLOWS: */</span>
00351 
00352 <span class="comment">/*     THE ORDER OF EACH INPUT VECTOR, */</span>
00353 
00354 <span class="comment">/*     G(0), G(1), G(2), ... , G(N-2), G(N-1) */</span>
00355 
00356 <span class="comment">/*     IS REVERSED (EXCLUDING G(0)) TO YIELD */</span>
00357 
00358 <span class="comment">/*     G(0), G(N-1), G(N-2), ... , G(2), G(1). */</span>
00359 
00360 <span class="comment">/*     WITHIN THE TRANSFORM, THE CORRESPONDING EXPONENTIAL MULTIPLIER */</span>
00361 <span class="comment">/*     IS THEN PRECISELY THE CONJUGATE OF THAT FOR THE NORMAL */</span>
00362 <span class="comment">/*     ORDERING.  THUS THE FORWARD (ISIGN = -1) TRANSFORM IS */</span>
00363 <span class="comment">/*     ACCOMPLISHED */</span>
00364 
00365 <span class="comment">/*     FOR NFAX ODD, THE INPUT MUST BE TRANSFERRED TO THE WORK ARRAY, */</span>
00366 <span class="comment">/*     AND THE REARRANGEMENT CAN BE DONE DURING THE MOVE. */</span>
00367 
00368   jnk = -2;
00369   jst = nn - 2;
00370   <span class="keywordflow">if</span> (nfax % 2 == 1) {
00371     <span class="keywordflow">goto</span> L40;
00372   }
00373 
00374   <span class="comment">/*     FOR NFAX EVEN, THE REARRANGEMENT MUST BE APPLIED DIRECTLY TO */</span>
00375   <span class="comment">/*     THE INPUT ARRAY.  THIS CAN BE DONE BY SWAPPING ELEMENTS. */</span>
00376 
00377   ibase = 1;
00378   ilast = (n - 1) * ink;
00379   nh = n / 2;
00380   <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
00381     i1 = ibase + ink;
00382     i2 = ibase + ilast;
00383     <span class="comment">/* DIR$ IVDEP */</span>
00384     <span class="keywordflow">for</span> (m = 1; m &lt;= nh; ++m) {
00385       <span class="comment">/*     SWAP REAL AND IMAGINARY PORTIONS */</span>
00386       hreal = a[i1];
00387       himag = a[i1 + 1];
00388       a[i1] = a[i2];
00389       a[i1 + 1] = a[i2 + 1];
00390       a[i2] = hreal;
00391       a[i2 + 1] = himag;
00392       i1 += ink;
00393       i2 -= ink;
00394       <span class="comment">/* L10: */</span>
00395     }
00396     ibase += jum;
00397     <span class="comment">/* L20: */</span>
00398   }
00399   <span class="keywordflow">goto</span> L100;
00400 
00401  L30:
00402   <span class="keywordflow">if</span> (nfax % 2 == 0) {
00403     <span class="keywordflow">goto</span> L100;
00404   }
00405 
00406  L40:
00407 
00408 <span class="comment">/*     DURING THE TRANSFORM PROCESS, NFAX STEPS ARE TAKEN, AND THE */</span>
00409 <span class="comment">/*     RESULTS ARE STORED ALTERNATELY IN WORK AND IN A.  IF NFAX IS */</span>
00410 <span class="comment">/*     ODD, THE INPUT DATA ARE FIRST MOVED TO WORK SO THAT THE FINAL */</span>
00411 <span class="comment">/*     RESULT (AFTER NFAX STEPS) IS STORED IN ARRAY A. */</span>
00412 
00413   ibase = 1;
00414   jbase = 1;
00415   <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
00416     <span class="comment">/*     MOVE REAL AND IMAGINARY PORTIONS OF ELEMENT ZERO */</span>
00417     work[jbase] = a[ibase];
00418     work[jbase + 1] = a[ibase + 1];
00419     i = ibase + ink;
00420     j = jbase + jst;
00421     <span class="comment">/* DIR$ IVDEP */</span>
00422     <span class="keywordflow">for</span> (m = 2; m &lt;= n; ++m) {
00423       <span class="comment">/*     MOVE REAL AND IMAGINARY PORTIONS OF OTHER ELEMENTS (POSSIBLY IN */</span>
00424       <span class="comment">/*     REVERSE ORDER, DEPENDING ON JST AND JNK) */</span>
00425       work[j] = a[i];
00426       work[j + 1] = a[i + 1];
00427       i += ink;
00428       j += jnk;
00429       <span class="comment">/* L50: */</span>
00430     }
00431     ibase += jum;
00432     jbase += nn;
00433     <span class="comment">/* L60: */</span>
00434   }
00435 
00436  L100:
00437 
00438 <span class="comment">/*     PERFORM THE TRANSFORM PASSES, ONE PASS FOR EACH FACTOR.  DURING */</span>
00439 <span class="comment">/*     EACH PASS THE DATA ARE MOVED FROM A TO WORK OR FROM WORK TO A. */</span>
00440 
00441 <span class="comment">/*     FOR NFAX EVEN, THE FIRST PASS MOVES FROM A TO WORK */</span>
00442   igo = 110;
00443   <span class="comment">/*     FOR NFAX ODD, THE FIRST PASS MOVES FROM WORK TO A */</span>
00444   <span class="keywordflow">if</span> (nfax % 2 == 1) {
00445     igo = 120;
00446   }
00447   la = 1;
00448   <span class="keywordflow">for</span> (k = 1; k &lt;= nfax; ++k) {
00449     <span class="keywordflow">if</span> (igo == 120) {
00450       <span class="keywordflow">goto</span> L120;
00451     }
00452     <span class="comment">/* L110: */</span>
00453     <a class="code" href="fft99_8c.html#a2">vpassm</a>(&amp;a[1], &amp;a[2], &amp;work[1], &amp;work[2], trigs, ink, 2, jum, nn, lot, n, 
00454            ifax[k], la);
00455     igo = 120;
00456     <span class="keywordflow">goto</span> L130;
00457   L120:
00458     <a class="code" href="fft99_8c.html#a2">vpassm</a>(&amp;work[1], &amp;work[2], &amp;a[1], &amp;a[2], trigs, 2, ink, nn,
00459            jum, lot, n, ifax[k], la);
00460     igo = 110;
00461   L130:
00462     la *= ifax[k];
00463     <span class="comment">/* L140: */</span>
00464   }
00465 
00466   <span class="comment">/*     AT THIS POINT THE FINAL TRANSFORM RESULT IS STORED IN A. */</span>
00467 
00468   <span class="keywordflow">return</span>;
00469 } <span class="comment">/* cfft99 */</span>
00470 
<a name="l00471"></a><a class="code" href="fft99_8c.html#a8">00471</a> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a8">cftfax</a>(<span class="keywordtype">long</span> n, <span class="keywordtype">long</span> *ifax, <span class="keywordtype">double</span> *trigs)
00472 {
00473   <span class="comment">/* Local variables */</span>
00474   <span class="keyword">static</span> <span class="keywordtype">long</span> k;
00475 
00476 <span class="comment">/*     THIS ROUTINE WAS MODIFIED FROM TEMPERTON^S ORIGINAL */</span>
00477 <span class="comment">/*     BY DAVE FULKER.  IT NO LONGER PRODUCES FACTORS IN ASCENDING */</span>
00478 <span class="comment">/*     ORDER, AND THERE ARE NONE OF THE ORIGINAL #MODE# OPTIONS. */</span>
00479 
00480 <span class="comment">/* ON INPUT     N */</span>
00481 <span class="comment">/*               THE LENGTH OF EACH COMPLEX TRANSFORM TO BE PERFORMED */</span>
00482 
00483 <span class="comment">/*               N MUST BE GREATER THAN 1 AND CONTAIN NO PRIME */</span>
00484 <span class="comment">/*               FACTORS GREATER THAN 5. */</span>
00485 
00486 <span class="comment">/* ON OUTPUT    IFAX */</span>
00487 <span class="comment">/*               IFAX(1) */</span>
00488 <span class="comment">/*                 THE NUMBER OF FACTORS CHOSEN OR -99 IN CASE OF ERROR */</span>
00489 <span class="comment">/*               IFAX(2) THRU IFAX( IFAX(1)+1 ) */</span>
00490 <span class="comment">/*                 THE FACTORS OF N IN THE FOLLOWIN ORDER:  APPEARING */</span>
00491 <span class="comment">/*                 FIRST ARE AS MANY FACTORS OF 4 AS CAN BE OBTAINED. */</span>
00492 <span class="comment">/*                 SUBSEQUENT FACTORS ARE PRIMES, AND APPEAR IN */</span>
00493 <span class="comment">/*                 ASCENDING ORDER, EXCEPT FOR MULTIPLE FACTORS. */</span>
00494 
00495 <span class="comment">/*              TRIGS */</span>
00496 <span class="comment">/*               2N SIN AND COS VALUES FOR USE BY THE TRANSFORM ROUTINE */</span>
00497 
00498     <span class="comment">/* Function Body */</span>
00499   <a class="code" href="fft99_8c.html#a0">fact</a>(n, ifax);
00500   k = ifax[0];
00501   <span class="keywordflow">if</span> (k &lt; 1 || ifax[k] &gt; 5) {
00502     ifax[0] = -99;
00503   }
00504   <span class="keywordflow">if</span> (ifax[0] &lt;= 0)
00505     <span class="keywordflow">return</span>;
00506       
00507   <a class="code" href="fft99_8c.html#a1">cftrig</a>(n, trigs);
00508   <span class="keywordflow">return</span>;
00509 } <span class="comment">/* cftfax */</span>
00510 
<a name="l00511"></a><a class="code" href="fft99_8c.html#a0">00511</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a0">fact</a>(<span class="keywordtype">long</span> n, <span class="keywordtype">long</span> *ifax)
00512 {
00513   <span class="comment">/* Local variables */</span>
00514   <span class="keyword">static</span> <span class="keywordtype">long</span> k, l, nn, inc, max;
00515 
00516 <span class="comment">/*     FACTORIZATION ROUTINE THAT FIRST EXTRACTS ALL FACTORS OF 4 */</span>
00517     <span class="comment">/* Function Body */</span>
00518   <span class="keywordflow">if</span> (n &gt; 1) {
00519     <span class="keywordflow">goto</span> L10;
00520   }
00521   ifax[0] = 0;
00522   <span class="keywordflow">if</span> (n &lt; 1) {
00523     ifax[0] = -99;
00524   }
00525   <span class="keywordflow">return</span>;
00526  L10:
00527   nn = n;
00528   k = 0;
00529   <span class="comment">/*     TEST FOR FACTORS OF 4 */</span>
00530  L20:
00531   <span class="keywordflow">if</span> (nn % 4 != 0) {
00532     <span class="keywordflow">goto</span> L30;
00533   }
00534   ++k;
00535   ifax[k] = 4;
00536   nn /= 4;
00537   <span class="keywordflow">if</span> (nn == 1) {
00538     <span class="keywordflow">goto</span> L80;
00539   }
00540   <span class="keywordflow">goto</span> L20;
00541   <span class="comment">/*     TEST FOR EXTRA FACTOR OF 2 */</span>
00542  L30:
00543   <span class="keywordflow">if</span> (nn % 2 != 0) {
00544     <span class="keywordflow">goto</span> L40;
00545   }
00546   ++k;
00547   ifax[k] = 2;
00548   nn /= 2;
00549   <span class="keywordflow">if</span> (nn == 1) {
00550     <span class="keywordflow">goto</span> L80;
00551   }
00552   <span class="comment">/*     TEST FOR FACTORS OF 3 */</span>
00553  L40:
00554   <span class="keywordflow">if</span> (nn % 3 != 0) {
00555     <span class="keywordflow">goto</span> L50;
00556   }
00557   ++k;
00558   ifax[k] = 3;
00559   nn /= 3;
00560   <span class="keywordflow">if</span> (nn == 1) {
00561     <span class="keywordflow">goto</span> L80;
00562   }
00563   <span class="keywordflow">goto</span> L40;
00564   <span class="comment">/*     NOW FIND REMAINING FACTORS */</span>
00565  L50:
00566   l = 5;
00567   max = sqrt((<span class="keywordtype">double</span>) nn);
00568   inc = 2;
00569   <span class="comment">/*     INC ALTERNATELY TAKES ON VALUES 2 AND 4 */</span>
00570  L60:
00571   <span class="keywordflow">if</span> (nn % l != 0) {
00572     <span class="keywordflow">goto</span> L70;
00573   }
00574   ++k;
00575   ifax[k] = l;
00576   nn /= l;
00577   <span class="keywordflow">if</span> (nn == 1) {
00578     <span class="keywordflow">goto</span> L80;
00579   }
00580   <span class="keywordflow">goto</span> L60;
00581  L70:
00582   <span class="keywordflow">if</span> (l &gt; max) {
00583     <span class="keywordflow">goto</span> L75;
00584   }
00585   l += inc;
00586   inc = 6 - inc;
00587   <span class="keywordflow">goto</span> L60;
00588  L75:
00589   ++k;
00590   ifax[k] = nn;
00591  L80:
00592   ifax[0] = k;
00593   <span class="comment">/*     IFAX(0) NOW CONTAINS NUMBER OF FACTORS */</span>
00594   <span class="keywordflow">return</span>;
00595 } <span class="comment">/* fact */</span>
00596 
<a name="l00597"></a><a class="code" href="fft99_8c.html#a1">00597</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a1">cftrig</a>(<span class="keywordtype">long</span> n, <span class="keywordtype">double</span> *trigs)
00598 {
00599   <span class="comment">/* Local variables */</span>
00600   <span class="keyword">static</span> <span class="keywordtype">long</span> i, n2;
00601   <span class="keyword">static</span> <span class="keywordtype">double</span> angle, del;
00602 
00603   <span class="comment">/* Function Body */</span>
00604   del = (<a class="code" href="geo__to__km_8c.html#a0">PI</a> + <a class="code" href="geo__to__km_8c.html#a0">PI</a>) / (double) (n);
00605   n2 = n + n;
00606   <span class="keywordflow">for</span> (i = 0; i &lt; n2; i += 2) {
00607     angle = (double) i * 0.5 * del;
00608     trigs[i] = cos(angle);
00609     trigs[i + 1] = sin(angle);
00610   }
00611   <span class="keywordflow">return</span>;
00612 } <span class="comment">/* cftrig */</span>
00613 
<a name="l00614"></a><a class="code" href="fft99_8c.html#a2">00614</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a2">vpassm</a>(<span class="keywordtype">double</span> *a, <span class="keywordtype">double</span> *b, <span class="keywordtype">double</span> *c, <span class="keywordtype">double</span> *d, 
00615                    <span class="keywordtype">double</span> *trigs, <span class="keywordtype">long</span> inc1, <span class="keywordtype">long</span> inc2, <span class="keywordtype">long</span> inc3, <span class="keywordtype">long</span> inc4, 
00616                    <span class="keywordtype">long</span> lot, <span class="keywordtype">long</span> n, <span class="keywordtype">long</span> ifac, <span class="keywordtype">long</span> la)
00617 {
00618   <span class="comment">/* Initialized data */</span>
00619 
00620   <span class="keyword">static</span> <span class="keywordtype">double</span> sin36 = 0.587785252292473;
00621   <span class="keyword">static</span> <span class="keywordtype">double</span> cos36 = 0.809016994374947;
00622   <span class="keyword">static</span> <span class="keywordtype">double</span> sin72 = 0.951056516295154;
00623   <span class="keyword">static</span> <span class="keywordtype">double</span> cos72 = 0.309016994374947;
00624   <span class="keyword">static</span> <span class="keywordtype">double</span> sin60 = 0.866025403784437;
00625 
00626     <span class="comment">/* Local variables */</span>
00627   <span class="keyword">static</span> <span class="keywordtype">long</span> iink, jink, jump, i, j, k, l, m, ibase, jbase;
00628   <span class="keyword">static</span> <span class="keywordtype">double</span> c1, c2, c3, c4, s1, s2, s3, s4;
00629   <span class="keyword">static</span> <span class="keywordtype">long</span> ia, ja, ib, jb, kb, ic, jc, kc, <a class="code" href="getutil_8c.html#a13">id</a>, jd, kd, ie, je, ke, 
00630     la1, ijk, igo;
00631 
00632 
00633 <span class="comment">/*     SUBROUTINE ^VPASSM^ - MULTIPLE VERSION OF ^VPASSA^ */</span>
00634 <span class="comment">/*     PERFORMS ONE PASS THROUGH DATA */</span>
00635 <span class="comment">/*     AS PART OF MULTIPLE COMPLEX (INVERSE) FFT ROUTINE */</span>
00636 <span class="comment">/*     A IS FIRST REAL INPUT VECTOR */</span>
00637 <span class="comment">/*     B IS FIRST IMAGINARY INPUT VECTOR */</span>
00638 <span class="comment">/*     C IS FIRST REAL OUTPUT VECTOR */</span>
00639 <span class="comment">/*     D IS FIRST IMAGINARY OUTPUT VECTOR */</span>
00640 <span class="comment">/*     TRIGS IS PRECALCULATED TABLE OF SINES \ COSINES */</span>
00641 <span class="comment">/*     INC1 IS ADDRESSING INCREMENT FOR A AND B */</span>
00642 <span class="comment">/*     INC2 IS ADDRESSING INCREMENT FOR C AND D */</span>
00643 <span class="comment">/*     INC3 IS ADDRESSING INCREMENT BETWEEN A^S \ B^S */</span>
00644 <span class="comment">/*     INC4 IS ADDRESSING INCREMENT BETWEEN C^S \ D^S */</span>
00645 <span class="comment">/*     LOT IS THE NUMBER OF VECTORS */</span>
00646 <span class="comment">/*     N IS LENGTH OF VECTORS */</span>
00647 <span class="comment">/*     IFAC IS CURRENT FACTOR OF N */</span>
00648 <span class="comment">/*     LA IS PRODUCT OF PREVIOUS FACTORS */</span>
00649 
00650     <span class="comment">/* Parameter adjustments */</span>
00651   --d;
00652   --c;
00653   --b;
00654   --a;
00655 
00656     <span class="comment">/* Function Body */</span>
00657 
00658   m = n / ifac;
00659   iink = m * inc1;
00660   jink = la * inc2;
00661   jump = (ifac - 1) * jink;
00662   ibase = 0;
00663   jbase = 0;
00664   igo = ifac - 1;
00665   <span class="keywordflow">if</span> (igo &gt; 4) {
00666     <span class="keywordflow">return</span>;
00667   }
00668   <span class="keywordflow">switch</span> ((int)igo) {
00669   <span class="keywordflow">case</span> 1:  <span class="keywordflow">goto</span> L10;
00670   <span class="keywordflow">case</span> 2:  <span class="keywordflow">goto</span> L50;
00671   <span class="keywordflow">case</span> 3:  <span class="keywordflow">goto</span> L90;
00672   <span class="keywordflow">case</span> 4:  <span class="keywordflow">goto</span> L130;
00673   }
00674 
00675   <span class="comment">/*     CODING FOR FACTOR 2 */</span>
00676 
00677  L10:
00678   ia = 1;
00679   ja = 1;
00680   ib = ia + iink;
00681   jb = ja + jink;
00682   <span class="keywordflow">for</span> (l = 1; l &lt;= la; ++l) {
00683     i = ibase;
00684     j = jbase;
00685     <span class="comment">/* DIR$ IVDEP */</span>
00686     <span class="keywordflow">for</span> (ijk = 1; ijk &lt;= lot; ++ijk) {
00687       c[ja + j] = a[ia + i] + a[ib + i];
00688       d[ja + j] = b[ia + i] + b[ib + i];
00689       c[jb + j] = a[ia + i] - a[ib + i];
00690       d[jb + j] = b[ia + i] - b[ib + i];
00691       i += inc3;
00692       j += inc4;
00693       <span class="comment">/* L15: */</span>
00694     }
00695     ibase += inc1;
00696     jbase += inc2;
00697     <span class="comment">/* L20: */</span>
00698   }
00699   <span class="keywordflow">if</span> (la == m) {
00700     <span class="keywordflow">return</span>;
00701   }
00702   la1 = la + 1;
00703   jbase += jump;
00704   <span class="keywordflow">for</span> (k = la1; la &lt; 0 ? k &gt;= m : k &lt;= m; k += la) {
00705     kb = k + k - 2;
00706     c1 = trigs[kb];
00707     s1 = trigs[kb + 1];
00708     <span class="keywordflow">for</span> (l = 1; l &lt;= la; ++l) {
00709       i = ibase;
00710       j = jbase;
00711       <span class="comment">/* DIR$ IVDEP */</span>
00712       <span class="keywordflow">for</span> (ijk = 1; ijk &lt;= lot; ++ijk) {
00713         c[ja + j] = a[ia + i] + a[ib + i];
00714         d[ja + j] = b[ia + i] + b[ib + i];
00715         c[jb + j] = c1 * (a[ia + i] - a[ib + i]) - s1 * 
00716           (b[ia +i] - b[ib + i]);
00717         d[jb + j] = s1 * (a[ia + i] - a[ib + i]) + c1 * 
00718           (b[ia +i] - b[ib + i]);
00719         i += inc3;
00720         j += inc4;
00721         <span class="comment">/* L25: */</span>
00722       }
00723       ibase += inc1;
00724       jbase += inc2;
00725       <span class="comment">/* L30: */</span>
00726     }
00727     jbase += jump;
00728     <span class="comment">/* L40: */</span>
00729   }
00730   <span class="keywordflow">return</span>;
00731 
00732 <span class="comment">/*     CODING FOR FACTOR 3 */</span>
00733 
00734  L50:
00735   ia = 1;
00736   ja = 1;
00737   ib = ia + iink;
00738   jb = ja + jink;
00739   ic = ib + iink;
00740   jc = jb + jink;
00741   <span class="keywordflow">for</span> (l = 1; l &lt;= la; ++l) {
00742     i = ibase;
00743     j = jbase;
00744     <span class="comment">/* DIR$ IVDEP */</span>
00745     <span class="keywordflow">for</span> (ijk = 1; ijk &lt;= lot; ++ijk) {
00746       c[ja + j] = a[ia + i] + (a[ib + i] + a[ic + i]);
00747       d[ja + j] = b[ia + i] + (b[ib + i] + b[ic + i]);
00748       c[jb + j] = a[ia + i] - (a[ib + i] + a[ic + i]) * 0.5 - 
00749         sin60 * (b[ib + i] - b[ic + i]);
00750       c[jc + j] = a[ia + i] - (a[ib + i] + a[ic + i]) * 0.5 + 
00751         sin60 * (b[ib + i] - b[ic + i]);
00752       d[jb + j] = b[ia + i] - (b[ib + i] + b[ic + i]) * 0.5 + 
00753         sin60 * (a[ib + i] - a[ic + i]);
00754       d[jc + j] = b[ia + i] - (b[ib + i] + b[ic + i]) * 0.5 - 
00755         sin60 * (a[ib + i] - a[ic + i]);
00756       i += inc3;
00757       j += inc4;
00758       <span class="comment">/* L55: */</span>
00759     }
00760     ibase += inc1;
00761     jbase += inc2;
00762     <span class="comment">/* L60: */</span>
00763   }
00764   <span class="keywordflow">if</span> (la == m) {
00765     <span class="keywordflow">return</span>;
00766   }
00767   la1 = la + 1;
00768   jbase += jump;
00769   <span class="keywordflow">for</span> (k = la1; la &lt; 0 ? k &gt;= m : k &lt;= m; k += la) {
00770     kb = k + k - 2;
00771     kc = kb + kb;
00772     c1 = trigs[kb];
00773     s1 = trigs[kb + 1];
00774     c2 = trigs[kc];
00775     s2 = trigs[kc + 1];
00776     <span class="keywordflow">for</span> (l = 1; l &lt;= la; ++l) {
00777       i = ibase;
00778       j = jbase;
00779       <span class="comment">/* DIR$ IVDEP */</span>
00780       <span class="keywordflow">for</span> (ijk = 1; ijk &lt;= lot; ++ijk) {
00781         c[ja + j] = a[ia + i] + (a[ib + i] + a[ic + i]);
00782         d[ja + j] = b[ia + i] + (b[ib + i] + b[ic + i]);
00783         c[jb + j] = c1 * (a[ia + i] - (a[ib + i] + a[ic + i]) * 0.5 - 
00784                           sin60 * (b[ib + i] - b[ic + i])) - 
00785           s1 * (b[ia + i] - (b[ib + i] + b[ic + i]) * 0.5 + 
00786                 sin60 * (a[ib + i] - a[ic + i]));
00787         d[jb + j] = s1 * (a[ia + i] - (a[ib + i] + a[ic + i]) * 0.5 - 
00788                           sin60 * (b[ib + i] - b[ic + i])) + 
00789           c1 * (b[ia + i] - (b[ib + i] + b[ic + i]) * 0.5 + 
00790                 sin60 * (a[ib + i] - a[ic + i]));
00791         c[jc + j] = c2 * (a[ia + i] - (a[ib + i] + a[ic + i]) * 0.5 + 
00792                           sin60 * (b[ib + i] - b[ic + i])) - 
00793           s2 * (b[ia + i] - (b[ib + i] + b[ic + i]) * 0.5 - 
00794                 sin60 * (a[ib + i] - a[ic + i]));
00795         d[jc + j] = s2 * (a[ia + i] - (a[ib + i] + a[ic + i]) * 0.5 + 
00796                           sin60 * (b[ib + i] - b[ic + i])) + 
00797           c2 * (b[ia + i] - (b[ib + i] + b[ic + i]) * 0.5 - 
00798                 sin60 * (a[ib + i] - a[ic + i]));
00799         i += inc3;
00800         j += inc4;
00801         <span class="comment">/* L65: */</span>
00802       }
00803       ibase += inc1;
00804       jbase += inc2;
00805       <span class="comment">/* L70: */</span>
00806     }
00807     jbase += jump;
00808     <span class="comment">/* L80: */</span>
00809   }
00810   <span class="keywordflow">return</span>;
00811 
00812 <span class="comment">/*     CODING FOR FACTOR 4 */</span>
00813 
00814  L90:
00815   ia = 1;
00816   ja = 1;
00817   ib = ia + iink;
00818   jb = ja + jink;
00819   ic = ib + iink;
00820   jc = jb + jink;
00821   <a class="code" href="getutil_8c.html#a13">id</a> = ic + iink;
00822   jd = jc + jink;
00823   <span class="keywordflow">for</span> (l = 1; l &lt;= la; ++l) {
00824     i = ibase;
00825     j = jbase;
00826     <span class="comment">/* DIR$ IVDEP */</span>
00827     <span class="keywordflow">for</span> (ijk = 1; ijk &lt;= lot; ++ijk) {
00828       c[ja + j] = a[ia + i] + a[ic + i] + (a[ib + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00829       c[jc + j] = a[ia + i] + a[ic + i] - (a[ib + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00830       d[ja + j] = b[ia + i] + b[ic + i] + (b[ib + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00831       d[jc + j] = b[ia + i] + b[ic + i] - (b[ib + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00832       c[jb + j] = a[ia + i] - a[ic + i] - (b[ib + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00833       c[jd + j] = a[ia + i] - a[ic + i] + (b[ib + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00834       d[jb + j] = b[ia + i] - b[ic + i] + (a[ib + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00835       d[jd + j] = b[ia + i] - b[ic + i] - (a[ib + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00836       i += inc3;
00837       j += inc4;
00838       <span class="comment">/* L95: */</span>
00839     }
00840     ibase += inc1;
00841     jbase += inc2;
00842     <span class="comment">/* L100: */</span>
00843   }
00844   <span class="keywordflow">if</span> (la == m) {
00845     <span class="keywordflow">return</span>;
00846   }
00847   la1 = la + 1;
00848   jbase += jump;
00849   <span class="keywordflow">for</span> (k = la1; la &lt; 0 ? k &gt;= m : k &lt;= m; k += la) {
00850     kb = k + k - 2;
00851     kc = kb + kb;
00852     kd = kc + kb;
00853     c1 = trigs[kb];
00854     s1 = trigs[kb + 1];
00855     c2 = trigs[kc];
00856     s2 = trigs[kc + 1];
00857     c3 = trigs[kd];
00858     s3 = trigs[kd + 1];
00859     <span class="keywordflow">for</span> (l = 1; l &lt;= la; ++l) {
00860       i = ibase;
00861       j = jbase;
00862       <span class="comment">/* DIR$ IVDEP */</span>
00863       <span class="keywordflow">for</span> (ijk = 1; ijk &lt;= lot; ++ijk) {
00864         c[ja + j] = a[ia + i] + a[ic + i] + (a[ib + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00865         d[ja + j] = b[ia + i] + b[ic + i] + (b[ib + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00866         c[jc + j] = c2 * (a[ia + i] + a[ic + i] - (a[ib + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i])) - 
00867           s2 * (b[ia + i] + b[ic + i] - (b[ib + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00868         d[jc + j] = s2 * (a[ia + i] + a[ic + i] - (a[ib + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i])) + 
00869           c2 * (b[ia + i] + b[ic + i] - (b[ib + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00870         c[jb + j] = c1 * (a[ia + i] - a[ic + i] - (b[ib + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i])) - 
00871           s1 * (b[ia + i] - b[ic + i] + (a[ib + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00872         d[jb + j] = s1 * (a[ia + i] - a[ic + i] - (b[ib + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i])) + 
00873           c1 * (b[ia + i] - b[ic + i] + (a[ib + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00874         c[jd + j] = c3 * (a[ia + i] - a[ic + i] + (b[ib + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i])) - 
00875           s3 * (b[ia + i] - b[ic + i] - (a[ib + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00876         d[jd + j] = s3 * (a[ia + i] - a[ic + i] + (b[ib + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i])) + 
00877           c3 * (b[ia + i] - b[ic + i] - (a[ib + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00878         i += inc3;
00879         j += inc4;
00880         <span class="comment">/* L105: */</span>
00881       }
00882       ibase += inc1;
00883       jbase += inc2;
00884       <span class="comment">/* L110: */</span>
00885     }
00886     jbase += jump;
00887     <span class="comment">/* L120: */</span>
00888   }
00889   <span class="keywordflow">return</span>;
00890 
00891 <span class="comment">/*     CODING FOR FACTOR 5 */</span>
00892 
00893  L130:
00894   ia = 1;
00895   ja = 1;
00896   ib = ia + iink;
00897   jb = ja + jink;
00898   ic = ib + iink;
00899   jc = jb + jink;
00900   <a class="code" href="getutil_8c.html#a13">id</a> = ic + iink;
00901   jd = jc + jink;
00902   ie = <a class="code" href="getutil_8c.html#a13">id</a> + iink;
00903   je = jd + jink;
00904   <span class="keywordflow">for</span> (l = 1; l &lt;= la; ++l) {
00905     i = ibase;
00906     j = jbase;
00907     <span class="comment">/* DIR$ IVDEP */</span>
00908     <span class="keywordflow">for</span> (ijk = 1; ijk &lt;= lot; ++ijk) {
00909       c[ja + j] = a[ia + i] + (a[ib + i] + a[ie + i]) + 
00910         (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00911       d[ja + j] = b[ia + i] + (b[ib + i] + b[ie + i]) + 
00912         (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00913       c[jb + j] = a[ia + i] + cos72 * (a[ib + i] + a[ie + i]) - 
00914         cos36 * (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]) - (sin72 * (b[ib + i] - b[ie + i]) + 
00915                                            sin36 * (b[ic + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00916       c[je + j] = a[ia + i] + cos72 * (a[ib + i] + a[ie + i]) -
00917         cos36 * (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]) + (sin72 * (b[ib + i] - b[ie + i]) + 
00918                                            sin36 * (b[ic + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00919       d[jb + j] = b[ia + i] + cos72 * (b[ib + i] + b[ie + i]) - 
00920         cos36 * (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]) + (sin72 * (a[ib + i] - a[ie + i]) + 
00921                                            sin36 * (a[ic + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00922       d[je + j] = b[ia + i] + cos72 * (b[ib + i] + b[ie + i]) - 
00923         cos36 * (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]) - (sin72 * (a[ib + i] - a[ie + i]) + 
00924                                            sin36 * (a[ic + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00925       c[jc + j] = a[ia + i] - cos36 * (a[ib + i] + a[ie + i]) + 
00926         cos72 * (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]) - (sin36 * (b[ib + i] - b[ie + i]) -
00927                                            sin72 * (b[ic + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00928       c[jd + j] = a[ia + i] - cos36 * (a[ib + i] + a[ie + i]) + 
00929         cos72 * (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]) + (sin36 * (b[ib + i] - b[ie + i]) - 
00930                                            sin72 * (b[ic + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00931       d[jc + j] = b[ia + i] - cos36 * (b[ib + i] + b[ie + i]) + 
00932         cos72 * (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]) + (sin36 * (a[ib + i] - a[ie + i]) - 
00933                                            sin72 * (a[ic + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00934       d[jd + j] = b[ia + i] - cos36 * (b[ib + i] + b[ie + i]) + 
00935         cos72 * (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]) - (sin36 * (a[ib + i] - a[ie + i]) - 
00936                                            sin72 * (a[ic + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i]));
00937       i += inc3;
00938       j += inc4;
00939       <span class="comment">/* L135: */</span>
00940     }
00941     ibase += inc1;
00942     jbase += inc2;
00943     <span class="comment">/* L140: */</span>
00944   }
00945   <span class="keywordflow">if</span> (la == m) {
00946     <span class="keywordflow">return</span>;
00947   }
00948   la1 = la + 1;
00949   jbase += jump;
00950   <span class="keywordflow">for</span> (k = la1; la &lt; 0 ? k &gt;= m : k &lt;= m; k += la) {
00951     kb = k + k - 2;
00952     kc = kb + kb;
00953     kd = kc + kb;
00954     ke = kd + kb;
00955     c1 = trigs[kb];
00956     s1 = trigs[kb + 1];
00957     c2 = trigs[kc];
00958     s2 = trigs[kc + 1];
00959     c3 = trigs[kd];
00960     s3 = trigs[kd + 1];
00961     c4 = trigs[ke];
00962     s4 = trigs[ke + 1];
00963     <span class="keywordflow">for</span> (l = 1; l &lt;= la; ++l) {
00964       i = ibase;
00965       j = jbase;
00966       <span class="comment">/* DIR$ IVDEP */</span>
00967       <span class="keywordflow">for</span> (ijk = 1; ijk &lt;= lot; ++ijk) {
00968         c[ja + j] = a[ia + i] + (a[ib + i] + a[ie + i]) + 
00969           (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00970         d[ja + j] = b[ia + i] + (b[ib + i] + b[ie + i]) + 
00971           (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]);
00972         c[jb + j] = 
00973           c1 * (a[ia + i] + cos72 * (a[ib + i] + a[ie + i]) - 
00974                 cos36 * (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]) - 
00975                 (sin72 * (b[ib + i] - b[ie + i]) + 
00976                  sin36 * (b[ic + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]))) - 
00977           s1 * (b[ia + i] + cos72 * (b[ib + i] + b[ie + i]) - 
00978                 cos36 * (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]) + 
00979                 (sin72 * (a[ib + i] - a[ie + i]) + 
00980                  sin36 * (a[ic + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i])));
00981         d[jb + j] = 
00982           s1 * (a[ia + i] + cos72 * (a[ib + i] + a[ie + i]) - 
00983                 cos36 * (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]) - 
00984                 (sin72 * (b[ib + i] - b[ie + i]) + 
00985                  sin36 * (b[ic + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]))) + 
00986           c1 * (b[ia + i] + cos72 * (b[ib + i] + b[ie + i]) - 
00987                 cos36 * (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]) + 
00988                 (sin72 * (a[ib + i] - a[ie + i]) +
00989                  sin36 * (a[ic + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i])));
00990         c[je + j] = 
00991           c4 * (a[ia + i] + cos72 * (a[ib + i] + a[ie + i]) - 
00992                 cos36 * (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]) + 
00993                 (sin72 * (b[ib + i] - b[ie + i]) + 
00994                  sin36 * (b[ic + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]))) - 
00995           s4 * (b[ia + i] + cos72 * (b[ib + i] + b[ie + i]) - 
00996                 cos36 * (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]) - 
00997                 (sin72 * (a[ib + i] - a[ie + i]) + 
00998                  sin36 * (a[ic + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i])));
00999         d[je + j] = 
01000           s4 * (a[ia + i] + cos72 * (a[ib + i] + a[ie + i]) - 
01001                 cos36 * (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]) + 
01002                 (sin72 * (b[ib + i] - b[ie + i]) + 
01003                  sin36 * (b[ic + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]))) + 
01004           c4 * (b[ia + i] + cos72 * (b[ib + i] + b[ie + i]) - 
01005                 cos36 * (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]) - 
01006                 (sin72 * (a[ib + i] - a[ie + i]) +
01007                  sin36 * (a[ic + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i])));
01008         c[jc + j] = 
01009           c2 * (a[ia + i] - cos36 * (a[ib + i] + a[ie + i]) + 
01010                 cos72 * (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]) - 
01011                 (sin36 * (b[ib + i] - b[ie + i]) - 
01012                  sin72 * (b[ic + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]))) - 
01013           s2 * (b[ia + i] - cos36 * (b[ib + i] + b[ie + i]) + 
01014                 cos72 * (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]) + 
01015                 (sin36 * (a[ib + i] - a[ie + i]) -
01016                  sin72 * (a[ic + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i])));
01017         d[jc + j] = 
01018           s2 * (a[ia + i] - cos36 * (a[ib + i] + a[ie + i]) + 
01019                 cos72 * (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]) - 
01020                 (sin36 * (b[ib + i] - b[ie + i]) - 
01021                  sin72 * (b[ic + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]))) + 
01022           c2 * (b[ia + i] - cos36 * (b[ib + i] + b[ie + i]) + 
01023                 cos72 * (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]) + 
01024                 (sin36 * (a[ib + i] - a[ie + i]) - 
01025                  sin72 * (a[ic + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i])));
01026         c[jd + j] = 
01027           c3 * (a[ia + i] - cos36 * (a[ib + i] + a[ie + i]) + 
01028                 cos72 * (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]) + 
01029                 (sin36 * (b[ib + i] - b[ie + i]) - 
01030                  sin72 * (b[ic +i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]))) - 
01031           s3 * (b[ia + i] - cos36 * (b[ib + i] + b[ie + i]) + 
01032                 cos72 * (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]) - 
01033                 (sin36 * (a[ib + i] - a[ie + i]) - 
01034                  sin72 * (a[ic + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i])));
01035         d[jd + j] = 
01036           s3 * (a[ia + i] - cos36 * (a[ib + i] + a[ie + i]) + 
01037                 cos72 * (a[ic + i] + a[<a class="code" href="getutil_8c.html#a13">id</a> + i]) + 
01038                 (sin36 * (b[ib + i] - b[ie + i]) - 
01039                  sin72 * (b[ic + i] - b[<a class="code" href="getutil_8c.html#a13">id</a> + i]))) + 
01040           c3 * (b[ia + i] - cos36 * (b[ib + i] + b[ie + i]) + 
01041                 cos72 * (b[ic + i] + b[<a class="code" href="getutil_8c.html#a13">id</a> + i]) - 
01042                 (sin36 * (a[ib + i] - a[ie + i]) -
01043                  sin72 * (a[ic + i] - a[<a class="code" href="getutil_8c.html#a13">id</a> + i])));
01044         i += inc3;
01045         j += inc4;
01046         <span class="comment">/* L145: */</span>
01047       }
01048       ibase += inc1;
01049       jbase += inc2;
01050       <span class="comment">/* L150: */</span>
01051     }
01052     jbase += jump;
01053     <span class="comment">/* L160: */</span>
01054   }
01055   <span class="keywordflow">return</span>;
01056 } <span class="comment">/* vpassm */</span>
01057 
<a name="l01058"></a><a class="code" href="fft99_8c.html#a9">01058</a> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a9">fft99</a>(<span class="keywordtype">double</span> *a, <span class="keywordtype">double</span> *work, <span class="keywordtype">double</span> *trigs, <span class="keywordtype">long</span> *ifax, <span class="keywordtype">long</span> inc, 
01059            <span class="keywordtype">long</span> jump, <span class="keywordtype">long</span> n, <span class="keywordtype">long</span> lot, <span class="keywordtype">long</span> isign)
01060 {
01061   <span class="comment">/* Local variables */</span>
01062   <span class="keyword">static</span> <span class="keywordtype">long</span> nfax, i, j, k, l, m, ibase, jbase;
01063   <span class="keyword">static</span> <span class="keywordtype">long</span> ia, ib, la, nh, nx;
01064   <span class="keyword">static</span> <span class="keywordtype">long</span> igo, ink;
01065 
01066 
01067 <span class="comment">/* PURPOSE      PERFORMS MULTIPLE FAST FOURIER TRANSFORMS.  THIS PACKAGE </span>
01068 <span class="comment"> *              WILL PERFORM A NUMBER OF SIMULTANEOUS REAL/HALF-COMPLEX </span>
01069 <span class="comment"> *              PERIODIC FOURIER TRANSFORMS OR CORRESPONDING INVERSE </span>
01070 <span class="comment"> *              TRANSFORMS, I.E.  GIVEN A SET OF REAL DATA VECTORS, THE </span>
01071 <span class="comment"> *              PACKAGE RETURNS A SET OF #HALF-COMPLEX# FOURIER </span>
01072 <span class="comment"> *              COEFFICIENT VECTORS, OR VICE VERSA.  THE LENGTH OF THE </span>
01073 <span class="comment"> *              TRANSFORMS MUST BE AN EVEN NUMBER GREATER THAN 4 THAT HAS </span>
01074 <span class="comment"> *              NO OTHER FACTORS EXCEPT POSSIBLY POWERS OF 2, 3, AND 5. </span>
01075 <span class="comment"> *</span>
01076 <span class="comment"> *              THE PACKAGE FFT99F CONTAINS SEVERAL USER-LEVEL ROUTINES: </span>
01077 <span class="comment"> *</span>
01078 <span class="comment"> *             fftfax </span>
01079 <span class="comment"> *                AN INITIALIZATION ROUTINE THAT MUST BE CALLED ONCE </span>
01080 <span class="comment"> *                BEFORE A SEQUENCE OF CALLS TO THE FFT ROUTINES </span>
01081 <span class="comment"> *                (PROVIDED THAT N IS NOT CHANGED). </span>
01082 <span class="comment"> *</span>
01083 <span class="comment"> *             fft99 AND fft991 </span>
01084 <span class="comment"> *                TWO FFT ROUTINES THAT RETURN SLIGHTLY DIFFERENT </span>
01085 <span class="comment"> *                ARRANGEMENTS OF THE DATA IN GRIDPOINT SPACE. </span>
01086 <span class="comment"> *</span>
01087 <span class="comment"> * USAGE        LET N BE OF THE FORM 2**P * 3**Q * 5**R, WHERE P .GE. 1, </span>
01088 <span class="comment"> *              Q .GE. 0, AND R .GE. 0.  THEN A TYPICAL SEQUENCE OF </span>
01089 <span class="comment"> *              CALLS TO TRANSFORM A GIVEN SET OF REAL VECTORS OF LENGTH </span>
01090 <span class="comment"> *              N TO A SET OF #HALF-COMPLEX# FOURIER COEFFICIENT VECTORS </span>
01091 <span class="comment"> *              OF LENGTH N IS </span>
01092 <span class="comment"> *</span>
01093 <span class="comment"> *                   long ifax[13];</span>
01094 <span class="comment"> *                   double trigs[3*n/2+1],a[m*(n+2)], work[m*(n+1)];</span>
01095 <span class="comment"> *</span>
01096 <span class="comment"> *                    fftfax (n, ifax, trigs);</span>
01097 <span class="comment"> *                    fft99 (a,work,trigs,ifax,inc,jump,n,m,isign);</span>
01098 <span class="comment"> *</span>
01099 <span class="comment"> *              SEE THE INDIVIDUAL WRITE-UPS FOR FFTFAX, FFT99, AND </span>
01100 <span class="comment"> *              FFT991 BELOW, FOR A DETAILED DESCRIPTION OF THE </span>
01101 <span class="comment"> *              ARGUMENTS. </span>
01102 <span class="comment"> *</span>
01103 <span class="comment"> * HISTORY      THE PACKAGE WAS WRITTEN BY CLIVE TEMPERTON AT ECMWF IN </span>
01104 <span class="comment"> *              NOVEMBER, 1978.  IT WAS MODIFIED, DOCUMENTED, AND TESTED </span>
01105 <span class="comment"> *              FOR NCAR BY RUSS REW IN SEPTEMBER, 1980. </span>
01106 <span class="comment"> *</span>
01107 <span class="comment"> * ----------------------------------------------------------------------- </span>
01108 <span class="comment"> *</span>
01109 <span class="comment"> *  fftfax (n,ifax,trigs) </span>
01110 <span class="comment"> *</span>
01111 <span class="comment"> * PURPOSE      A SET-UP ROUTINE FOR FFT99 AND FFT991.  IT NEED ONLY BE </span>
01112 <span class="comment"> *              CALLED ONCE BEFORE A SEQUENCE OF CALLS TO THE FFT </span>
01113 <span class="comment"> *              ROUTINES (PROVIDED THAT N IS NOT CHANGED). </span>
01114 <span class="comment"> *</span>
01115 <span class="comment"> * ARGUMENT     IFAX(13),TRIGS(3*N/2+1) </span>
01116 <span class="comment"> * DIMENSIONS </span>
01117 <span class="comment"> *</span>
01118 <span class="comment"> * ARGUMENTS </span>
01119 <span class="comment"> *</span>
01120 <span class="comment"> * ON INPUT     N </span>
01121 <span class="comment"> *               AN EVEN NUMBER GREATER THAN 4 THAT HAS NO PRIME FACTOR </span>
01122 <span class="comment"> *               GREATER THAN 5.  N IS THE LENGTH OF THE TRANSFORMS (SEE </span>
01123 <span class="comment"> *               THE DOCUMENTATION FOR FFT99 AND FFT991 FOR THE </span>
01124 <span class="comment"> *               DEFINITIONS OF THE TRANSFORMS). </span>
01125 <span class="comment"> *</span>
01126 <span class="comment"> *              IFAX </span>
01127 <span class="comment"> *               AN INTEGER ARRAY.  THE NUMBER OF ELEMENTS ACTUALLY USED </span>
01128 <span class="comment"> *               WILL DEPEND ON THE FACTORIZATION OF N.  DIMENSIONING </span>
01129 <span class="comment"> *               IFAX FOR 13 SUFFICES FOR ALL N LESS THAN A MILLION. </span>
01130 <span class="comment"> *</span>
01131 <span class="comment"> *              TRIGS </span>
01132 <span class="comment"> *               A FLOATING POINT ARRAY OF DIMENSION 3*N/2 IF N/2 IS </span>
01133 <span class="comment"> *               EVEN, OR 3*N/2+1 IF N/2 IS ODD. </span>
01134 <span class="comment"> *</span>
01135 <span class="comment"> * ON OUTPUT    IFAX </span>
01136 <span class="comment"> *               CONTAINS THE FACTORIZATION OF N/2.  IFAX(1) IS THE </span>
01137 <span class="comment"> *               NUMBER OF FACTORS, AND THE FACTORS THEMSELVES ARE STORED </span>
01138 <span class="comment"> *               IN IFAX(2),IFAX(3),...  IF FFTFAX IS CALLED WITH N ODD, </span>
01139 <span class="comment"> *               OR IF N HAS ANY PRIME FACTORS GREATER THAN 5, IFAX(1) </span>
01140 <span class="comment"> *               IS SET TO -99. </span>
01141 <span class="comment"> *</span>
01142 <span class="comment"> *              TRIGS </span>
01143 <span class="comment"> *               AN ARRAY OF TRIGNOMENTRIC FUNCTION VALUES SUBSEQUENTLY </span>
01144 <span class="comment"> *               USED BY THE FFT ROUTINES. </span>
01145 <span class="comment"> *</span>
01146 <span class="comment"> * ----------------------------------------------------------------------- </span>
01147 <span class="comment"> *</span>
01148 <span class="comment"> *  fft991 (a,work,trigs,ifax,inc,jump,n,m,isign) </span>
01149 <span class="comment"> *                       AND </span>
01150 <span class="comment"> *  fft99 (a,work,trigs,ifax,inc,jump,n,m,isign) </span>
01151 <span class="comment"> *</span>
01152 <span class="comment"> * PURPOSE      PERFORM A NUMBER OF SIMULTANEOUS REAL/HALF-COMPLEX </span>
01153 <span class="comment"> *              PERIODIC FOURIER TRANSFORMS OR CORRESPONDING INVERSE </span>
01154 <span class="comment"> *              TRANSFORMS, USING ORDINARY SPATIAL ORDER OF GRIDPOINT </span>
01155 <span class="comment"> *              VALUES (FFT991) OR EXPLICIT CYCLIC CONTINUITY IN THE </span>
01156 <span class="comment"> *              GRIDPOINT VALUES (FFT99).  GIVEN A SET </span>
01157 <span class="comment"> *              OF REAL DATA VECTORS, THE PACKAGE RETURNS A SET OF </span>
01158 <span class="comment"> *              #HALF-COMPLEX# FOURIER COEFFICIENT VECTORS, OR VICE </span>
01159 <span class="comment"> *              VERSA.  THE LENGTH OF THE TRANSFORMS MUST BE AN EVEN </span>
01160 <span class="comment"> *              NUMBER THAT HAS NO OTHER FACTORS EXCEPT POSSIBLY POWERS </span>
01161 <span class="comment"> *              OF 2, 3, AND 5.  THESE VERSION OF FFT991 AND FFT99 ARE </span>
01162 <span class="comment"> *              OPTIMIZED FOR USE ON THE CRAY-1. </span>
01163 <span class="comment"> *</span>
01164 <span class="comment"> * ARGUMENT     A(M*(N+2)), WORK(M*(N+1)), TRIGS(3*N/2+1), IFAX(13) </span>
01165 <span class="comment"> * DIMENSIONS </span>
01166 <span class="comment"> *</span>
01167 <span class="comment"> * ARGUMENTS </span>
01168 <span class="comment"> *</span>
01169 <span class="comment"> * ON INPUT     A </span>
01170 <span class="comment"> *               AN ARRAY OF LENGTH M*(N+2) CONTAINING THE INPUT DATA </span>
01171 <span class="comment"> *               OR COEFFICIENT VECTORS.  THIS ARRAY IS OVERWRITTEN BY </span>
01172 <span class="comment"> *               THE RESULTS. </span>
01173 <span class="comment"> *</span>
01174 <span class="comment"> *              WORK </span>
01175 <span class="comment"> *               A WORK ARRAY OF DIMENSION M*(N+1) </span>
01176 <span class="comment"> *</span>
01177 <span class="comment"> *              TRIGS </span>
01178 <span class="comment"> *               AN ARRAY SET UP BY FFTFAX, WHICH MUST BE CALLED FIRST. </span>
01179 <span class="comment"> *</span>
01180 <span class="comment"> *              IFAX </span>
01181 <span class="comment"> *               AN ARRAY SET UP BY FFTFAX, WHICH MUST BE CALLED FIRST. </span>
01182 <span class="comment"> *</span>
01183 <span class="comment"> *              INC </span>
01184 <span class="comment"> *               THE INCREMENT (IN WORDS) BETWEEN SUCCESSIVE ELEMENTS OF </span>
01185 <span class="comment"> *               EACH DATA OR COEFFICIENT VECTOR (E.G.  INC=1 FOR </span>
01186 <span class="comment"> *               CONSECUTIVELY STORED DATA). </span>
01187 <span class="comment"> *</span>
01188 <span class="comment"> *              JUMP </span>
01189 <span class="comment"> *               THE INCREMENT (IN WORDS) BETWEEN THE FIRST ELEMENTS OF </span>
01190 <span class="comment"> *               SUCCESSIVE DATA OR COEFFICIENT VECTORS.  ON THE CRAY-1, </span>
01191 <span class="comment"> *               TRY TO ARRANGE DATA SO THAT JUMP IS NOT A MULTIPLE OF 8 </span>
01192 <span class="comment"> *               (TO AVOID MEMORY BANK CONFLICTS).  FOR CLARIFICATION OF </span>
01193 <span class="comment"> *               INC AND JUMP, SEE THE EXAMPLES BELOW. </span>
01194 <span class="comment"> *</span>
01195 <span class="comment"> *              N </span>
01196 <span class="comment"> *               THE LENGTH OF EACH TRANSFORM (SEE DEFINITION OF </span>
01197 <span class="comment"> *               TRANSFORMS, BELOW). </span>
01198 <span class="comment"> *</span>
01199 <span class="comment"> *              M </span>
01200 <span class="comment"> *               THE NUMBER OF TRANSFORMS TO BE DONE SIMULTANEOUSLY. </span>
01201 <span class="comment"> *</span>
01202 <span class="comment"> *              ISIGN </span>
01203 <span class="comment"> *               = +1 FOR A TRANSFORM FROM FOURIER COEFFICIENTS TO </span>
01204 <span class="comment"> *                    GRIDPOINT VALUES. </span>
01205 <span class="comment"> *               = -1 FOR A TRANSFORM FROM GRIDPOINT VALUES TO FOURIER </span>
01206 <span class="comment"> *                    COEFFICIENTS. </span>
01207 <span class="comment"> *</span>
01208 <span class="comment"> * ON OUTPUT    A </span>
01209 <span class="comment"> *               IF ISIGN = +1, AND M COEFFICIENT VECTORS ARE SUPPLIED </span>
01210 <span class="comment"> *               EACH CONTAINING THE SEQUENCE: </span>
01211 <span class="comment"> *</span>
01212 <span class="comment"> *               A(0),B(0),A(1),B(1),...,A(N/2),B(N/2)  (N+2 VALUES) </span>
01213 <span class="comment"> *</span>
01214 <span class="comment"> *               THEN THE RESULT CONSISTS OF M DATA VECTORS EACH </span>
01215 <span class="comment"> *               CONTAINING THE CORRESPONDING N+2 GRIDPOINT VALUES: </span>
01216 <span class="comment"> *</span>
01217 <span class="comment"> *               FOR FFT991, X(0), X(1), X(2),...,X(N-1),0,0. </span>
01218 <span class="comment"> *               FOR FFT99, X(N-1),X(0),X(1),X(2),...,X(N-1),X(0). </span>
01219 <span class="comment"> *                   (EXPLICIT CYCLIC CONTINUITY) </span>
01220 <span class="comment"> *</span>
01221 <span class="comment"> *               WHEN ISIGN = +1, THE TRANSFORM IS DEFINED BY: </span>
01222 <span class="comment"> *                 X(J)=SUM(K=0,...,N-1)(C(K)*EXP(2*I*J*K*PI/N)) </span>
01223 <span class="comment"> *                 WHERE C(K)=A(K)+I*B(K) AND C(N-K)=A(K)-I*B(K) </span>
01224 <span class="comment"> *                 AND I=SQRT (-1) </span>
01225 <span class="comment"> *</span>
01226 <span class="comment"> *               IF ISIGN = -1, AND M DATA VECTORS ARE SUPPLIED EACH </span>
01227 <span class="comment"> *               CONTAINING A SEQUENCE OF GRIDPOINT VALUES X(J) AS </span>
01228 <span class="comment"> *               DEFINED ABOVE, THEN THE RESULT CONSISTS OF M VECTORS </span>
01229 <span class="comment"> *               EACH CONTAINING THE CORRESPONDING FOURIER COFFICIENTS </span>
01230 <span class="comment"> *               A(K), B(K), 0 .LE. K .LE N/2. </span>
01231 <span class="comment"> *</span>
01232 <span class="comment"> *               WHEN ISIGN = -1, THE INVERSE TRANSFORM IS DEFINED BY: </span>
01233 <span class="comment"> *                 C(K)=(1/N)*SUM(J=0,...,N-1)(X(J)*EXP(-2*I*J*K*PI/N)) </span>
01234 <span class="comment"> *                 WHERE C(K)=A(K)+I*B(K) AND I=SQRT(-1) </span>
01235 <span class="comment"> *</span>
01236 <span class="comment"> *               A CALL WITH ISIGN=+1 FOLLOWED BY A CALL WITH ISIGN=-1 </span>
01237 <span class="comment"> *               (OR VICE VERSA) RETURNS THE ORIGINAL DATA. </span>
01238 <span class="comment"> *</span>
01239 <span class="comment"> *               NOTE: THE FACT THAT THE GRIDPOINT VALUES X(J) ARE REAL </span>
01240 <span class="comment"> *               IMPLIES THAT B(0)=B(N/2)=0.  FOR A CALL WITH ISIGN=+1, </span>
01241 <span class="comment"> *               IT IS NOT ACTUALLY NECESSARY TO SUPPLY THESE ZEROS. </span>
01242 <span class="comment"> *</span>
01243 <span class="comment"> * EXAMPLES      GIVEN 19 DATA VECTORS EACH OF LENGTH 64 (+2 FOR EXPLICIT </span>
01244 <span class="comment"> *               CYCLIC CONTINUITY), COMPUTE THE CORRESPONDING VECTORS OF </span>
01245 <span class="comment"> *               FOURIER COEFFICIENTS.  THE DATA MAY, FOR EXAMPLE, BE </span>
01246 <span class="comment"> *               ARRANGED LIKE THIS: </span>
01247 <span class="comment"> *</span>
01248 <span class="comment"> * FIRST DATA   A(1)=    . . .                A(66)=             A(70) </span>
01249 <span class="comment"> * VECTOR       X(63) X(0) X(1) X(2) ... X(63) X(0)  (4 EMPTY LOCATIONS) </span>
01250 <span class="comment"> *</span>
01251 <span class="comment"> * SECOND DATA  A(71)=   . . .                                  A(140) </span>
01252 <span class="comment"> * VECTOR       X(63) X(0) X(1) X(2) ... X(63) X(0)  (4 EMPTY LOCATIONS) </span>
01253 <span class="comment"> *</span>
01254 <span class="comment"> *               AND SO ON.  HERE INC=1, JUMP=70, N=64, M=19, ISIGN=-1, </span>
01255 <span class="comment"> *               AND FFT99 SHOULD BE USED (BECAUSE OF THE EXPLICIT CYCLIC </span>
01256 <span class="comment"> *               CONTINUITY). </span>
01257 <span class="comment"> *</span>
01258 <span class="comment"> *               ALTERNATIVELY THE DATA MAY BE ARRANGED LIKE THIS: </span>
01259 <span class="comment"> *</span>
01260 <span class="comment"> *                FIRST         SECOND                          LAST </span>
01261 <span class="comment"> *                DATA          DATA                            DATA </span>
01262 <span class="comment"> *                VECTOR        VECTOR                          VECTOR </span>
01263 <span class="comment"> *</span>
01264 <span class="comment"> *                 A(1)=         A(2)=                           A(19)= </span>
01265 <span class="comment"> *</span>
01266 <span class="comment"> *                 X(63)         X(63)       . . .               X(63) </span>
01267 <span class="comment"> *        A(20)=   X(0)          X(0)        . . .               X(0) </span>
01268 <span class="comment"> *        A(39)=   X(1)          X(1)        . . .               X(1) </span>
01269 <span class="comment"> *                  .             .                               . </span>
01270 <span class="comment"> *                  .             .                               . </span>
01271 <span class="comment"> *                  .             .                               . </span>
01272 <span class="comment"> *</span>
01273 <span class="comment"> *               IN WHICH CASE WE HAVE INC=19, JUMP=1, AND THE REMAINING </span>
01274 <span class="comment"> *               PARAMETERS ARE THE SAME AS BEFORE.  IN EITHER CASE, EACH </span>
01275 <span class="comment"> *               COEFFICIENT VECTOR OVERWRITES THE CORRESPONDING INPUT </span>
01276 <span class="comment"> *               DATA VECTOR. </span>
01277 <span class="comment"> *</span>
01278 <span class="comment"> * ----------------------------------------------------------------------- </span>
01279 <span class="comment"> *</span>
01280 <span class="comment"> *     SUBROUTINE ^FFT99^ - MULTIPLE FAST REAL PERIODIC TRANSFORM </span>
01281 <span class="comment"> *     CORRESPONDING TO OLD SCALAR ROUTINE FFT9 </span>
01282 <span class="comment"> *     PROCEDURE USED TO CONVERT TO HALF-LENGTH COMPLEX TRANSFORM </span>
01283 <span class="comment"> *     IS GIVEN BY COOLEY, LEWIS AND WELCH (J. SOUND VIB., VOL. 12 </span>
01284 <span class="comment"> *     (1970), 315-337) </span>
01285 <span class="comment"> *</span>
01286 <span class="comment"> *     A IS THE ARRAY CONTAINING INPUT AND OUTPUT DATA </span>
01287 <span class="comment"> *     WORK IS AN AREA OF SIZE (N+1)*LOT </span>
01288 <span class="comment"> *     TRIGS IS A PREVIOUSLY PREPARED LIST OF TRIG FUNCTION VALUES </span>
01289 <span class="comment"> *     IFAX IS A PREVIOUSLY PREPARED LIST OF FACTORS OF N/2 </span>
01290 <span class="comment"> *     INC IS THE INCREMENT WITHIN EACH DATA #VECTOR# </span>
01291 <span class="comment"> *         (E.G. INC=1 FOR CONSECUTIVELY STORED DATA) </span>
01292 <span class="comment"> *     JUMP IS THE INCREMENT BETWEEN THE START OF EACH DATA VECTOR </span>
01293 <span class="comment"> *     N IS THE LENGTH OF THE DATA VECTORS </span>
01294 <span class="comment"> *     LOT IS THE NUMBER OF DATA VECTORS </span>
01295 <span class="comment"> *     ISIGN = +1 FOR TRANSFORM FROM SPECTRAL TO GRIDPOINT </span>
01296 <span class="comment"> *           = -1 FOR TRANSFORM FROM GRIDPOINT TO SPECTRAL </span>
01297 <span class="comment"> *</span>
01298 <span class="comment"> *     ORDERING OF COEFFICIENTS: </span>
01299 <span class="comment"> *         A(0),B(0),A(1),B(1),A(2),B(2),...,A(N/2),B(N/2) </span>
01300 <span class="comment"> *         WHERE B(0)=B(N/2)=0; (N+2) LOCATIONS REQUIRED </span>
01301 <span class="comment"> *</span>
01302 <span class="comment"> *     ORDERING OF DATA: </span>
01303 <span class="comment"> *         X(N-1),X(0),X(1),X(2),...,X(N),X(0) </span>
01304 <span class="comment"> *         I.E. EXPLICIT CYCLIC CONTINUITY; (N+2) LOCATIONS REQUIRED </span>
01305 <span class="comment"> *</span>
01306 <span class="comment"> *     VECTORIZATION IS ACHIEVED ON CRAY BY DOING THE TRANSFORMS IN </span>
01307 <span class="comment"> *     PARALLEL </span>
01308 <span class="comment"> *</span>
01309 <span class="comment"> *     *** N.B. N IS ASSUMED TO BE AN EVEN NUMBER </span>
01310 <span class="comment"> *</span>
01311 <span class="comment"> *     DEFINITION OF TRANSFORMS: </span>
01312 <span class="comment"> *     ------------------------- </span>
01313 <span class="comment"> *</span>
01314 <span class="comment"> *     ISIGN=+1: X(J)=SUM(K=0,...,N-1)(C(K)*EXP(2*I*J*K*PI/N)) </span>
01315 <span class="comment"> *         WHERE C(K)=A(K)+I*B(K) AND C(N-K)=A(K)-I*B(K) </span>
01316 <span class="comment"> *</span>
01317 <span class="comment"> *     ISIGN=-1: A(K)=(1/N)*SUM(J=0,...,N-1)(X(J)*COS(2*J*K*PI/N)) </span>
01318 <span class="comment"> *               B(K)=-(1/N)*SUM(J=0,...,N-1)(X(J)*SIN(2*J*K*PI/N)) </span>
01319 <span class="comment"> */</span>
01320 
01321     <span class="comment">/* Parameter adjustments */</span>
01322   --work;
01323   --a;
01324 
01325     <span class="comment">/* Function Body */</span>
01326   nfax = ifax[0];
01327   nx = n + 1;
01328   nh = n / 2;
01329   ink = inc + inc;
01330   <span class="keywordflow">if</span> (isign == 1) {
01331     <span class="keywordflow">goto</span> L30;
01332   }
01333 
01334   <span class="comment">/*     IF NECESSARY, TRANSFER DATA TO WORK AREA */</span>
01335   igo = 50;
01336   <span class="keywordflow">if</span> (nfax % 2 == 1) {
01337     <span class="keywordflow">goto</span> L40;
01338   }
01339   ibase = inc + 1;
01340   jbase = 1;
01341   <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
01342     i = ibase;
01343     j = jbase;
01344     <span class="comment">/* DIR$ IVDEP */</span>
01345     <span class="keywordflow">for</span> (m = 1; m &lt;= n; ++m) {
01346       work[j] = a[i];
01347       i += inc;
01348       ++j;
01349       <span class="comment">/* L10: */</span>
01350     }
01351     ibase += jump;
01352     jbase += nx;
01353     <span class="comment">/* L20: */</span>
01354   }
01355 
01356   igo = 60;
01357   <span class="keywordflow">goto</span> L40;
01358 
01359   <span class="comment">/*     PREPROCESSING (ISIGN=+1) */</span>
01360   <span class="comment">/*     ------------------------ */</span>
01361 
01362  L30:
01363   <a class="code" href="fft99_8c.html#a3">fft99a</a>(&amp;a[1], &amp;work[1], trigs, inc, jump, n, lot);
01364   igo = 60;
01365 
01366 <span class="comment">/*     COMPLEX TRANSFORM */</span>
01367 <span class="comment">/*     ----------------- */</span>
01368 
01369  L40:
01370   ia = inc + 1;
01371   la = 1;
01372   <span class="keywordflow">for</span> (k = 1; k &lt;= nfax; ++k) {
01373     <span class="keywordflow">if</span> (igo == 60) {
01374       <span class="keywordflow">goto</span> L60;
01375     }
01376     <span class="comment">/* L50: */</span>
01377     <a class="code" href="fft99_8c.html#a2">vpassm</a>(&amp;a[ia], &amp;a[ia + inc], &amp;work[1], &amp;work[2], trigs, ink, 2, jump, nx, 
01378            lot, nh, ifax[k], la);
01379     igo = 60;
01380     <span class="keywordflow">goto</span> L70;
01381   L60:
01382     <a class="code" href="fft99_8c.html#a2">vpassm</a>(&amp;work[1], &amp;work[2], &amp;a[ia], &amp;a[ia + inc], trigs, 2, ink, nx, jump, 
01383            lot, nh, ifax[k], la);
01384     igo = 50;
01385   L70:
01386     la *= ifax[k];
01387     <span class="comment">/* L80: */</span>
01388   }
01389 
01390   <span class="keywordflow">if</span> (isign == -1) {
01391     <span class="keywordflow">goto</span> L130;
01392   }
01393 
01394   <span class="comment">/*     IF NECESSARY, TRANSFER DATA FROM WORK AREA */</span>
01395   <span class="keywordflow">if</span> (nfax % 2 == 1) {
01396     <span class="keywordflow">goto</span> L110;
01397   }
01398   ibase = 1;
01399   jbase = ia;
01400   <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
01401     i = ibase;
01402     j = jbase;
01403     <span class="comment">/* DIR$ IVDEP */</span>
01404     <span class="keywordflow">for</span> (m = 1; m &lt;= n; ++m) {
01405       a[j] = work[i];
01406       ++i;
01407       j += inc;
01408       <span class="comment">/* L90: */</span>
01409     }
01410     ibase += nx;
01411     jbase += jump;
01412     <span class="comment">/* L100: */</span>
01413   }
01414 
01415   <span class="comment">/*     FILL IN CYCLIC BOUNDARY POINTS */</span>
01416  L110:
01417   ia = 1;
01418   ib = n * inc + 1;
01419   <span class="comment">/* DIR$ IVDEP */</span>
01420   <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
01421     a[ia] = a[ib];
01422     a[ib + inc] = a[ia + inc];
01423     ia += jump;
01424     ib += jump;
01425     <span class="comment">/* L120: */</span>
01426   }
01427   <span class="keywordflow">goto</span> L140;
01428 
01429 <span class="comment">/*     POSTPROCESSING (ISIGN=-1): */</span>
01430 <span class="comment">/*     -------------------------- */</span>
01431 
01432  L130:
01433   <a class="code" href="fft99_8c.html#a4">fft99b</a>(&amp;work[1], &amp;a[1], trigs, inc, jump, n, lot);
01434 
01435  L140:
01436   <span class="keywordflow">return</span>;
01437 } <span class="comment">/* fft99 */</span>
01438 
<a name="l01439"></a><a class="code" href="fft99_8c.html#a3">01439</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a3">fft99a</a>(<span class="keywordtype">double</span> *a, <span class="keywordtype">double</span> *work, <span class="keywordtype">double</span> *trigs, <span class="keywordtype">long</span> inc, <span class="keywordtype">long</span> jump,
01440                    <span class="keywordtype">long</span> n, <span class="keywordtype">long</span> lot)
01441 {
01442   <span class="comment">/* Local variables */</span>
01443   <span class="keyword">static</span> <span class="keywordtype">double</span> c;
01444   <span class="keyword">static</span> <span class="keywordtype">long</span> k, l;
01445   <span class="keyword">static</span> <span class="keywordtype">double</span> s;
01446   <span class="keyword">static</span> <span class="keywordtype">long</span> ia, ib, ja, jb, iabase, ibbase, nh, jabase, jbbase, nx, 
01447     ink;
01448 
01449 
01450 <span class="comment">/*     SUBROUTINE FFT99A - PREPROCESSING STEP FOR FFT99, ISIGN=+1 */</span>
01451 <span class="comment">/*     (SPECTRAL TO GRIDPOINT TRANSFORM) */</span>
01452 
01453     <span class="comment">/* Parameter adjustments */</span>
01454   --work;
01455   --a;
01456 
01457     <span class="comment">/* Function Body */</span>
01458   nh = n / 2;
01459   nx = n + 1;
01460   ink = inc + inc;
01461 
01462   <span class="comment">/*     A(0) AND A(N/2) */</span>
01463   ia = 1;
01464   ib = n * inc + 1;
01465   ja = 1;
01466   jb = 2;
01467   <span class="comment">/* DIR$ IVDEP */</span>
01468   <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
01469     work[ja] = a[ia] + a[ib];
01470     work[jb] = a[ia] - a[ib];
01471     ia += jump;
01472     ib += jump;
01473     ja += nx;
01474     jb += nx;
01475     <span class="comment">/* L10: */</span>
01476   }
01477 
01478   <span class="comment">/*     REMAINING WAVENUMBERS */</span>
01479   iabase = (inc &lt;&lt; 1) + 1;
01480   ibbase = (n - 2) * inc + 1;
01481   jabase = 3;
01482   jbbase = n - 1;
01483 
01484   <span class="keywordflow">for</span> (k = 3; k &lt;= nh; k += 2) {
01485     ia = iabase;
01486     ib = ibbase;
01487     ja = jabase;
01488     jb = jbbase;
01489     c = trigs[n + k - 1];
01490     s = trigs[n + k];
01491     <span class="comment">/* DIR$ IVDEP */</span>
01492     <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
01493       work[ja] = a[ia] + a[ib] - (s * (a[ia] - a[ib]) + 
01494                                   c * (a[ia + inc] + a[ib + inc]));
01495       work[jb] = a[ia] + a[ib] + (s * (a[ia] - a[ib]) + 
01496                                   c * (a[ia + inc] + a[ib + inc]));
01497       work[ja + 1] = c * (a[ia] - a[ib]) - 
01498         s * (a[ia + inc] + a[ib + inc]) + (a[ia + inc] - a[ib + inc]);
01499       work[jb + 1] = c * (a[ia] - a[ib]) - 
01500         s * (a[ia + inc] + a[ib + inc]) - (a[ia + inc] - a[ib + inc]);
01501       ia += jump;
01502       ib += jump;
01503       ja += nx;
01504       jb += nx;
01505       <span class="comment">/* L20: */</span>
01506     }
01507     iabase += ink;
01508     ibbase -= ink;
01509     jabase += 2;
01510     jbbase += -2;
01511     <span class="comment">/* L30: */</span>
01512   }
01513 
01514   <span class="keywordflow">if</span> (iabase != ibbase) {
01515     <span class="keywordflow">goto</span> L50;
01516   }
01517   <span class="comment">/*     WAVENUMBER N/4 (IF IT EXISTS) */</span>
01518   ia = iabase;
01519   ja = jabase;
01520   <span class="comment">/* DIR$ IVDEP */</span>
01521   <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
01522     work[ja] = a[ia] * 2.0;
01523     work[ja + 1] = a[ia + inc] * -2.0;
01524     ia += jump;
01525     ja += nx;
01526     <span class="comment">/* L40: */</span>
01527   }
01528 
01529  L50:
01530   <span class="keywordflow">return</span>;
01531 } <span class="comment">/* fft99a */</span>
01532 
<a name="l01533"></a><a class="code" href="fft99_8c.html#a4">01533</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a4">fft99b</a>(<span class="keywordtype">double</span> *work, <span class="keywordtype">double</span> *a, <span class="keywordtype">double</span> *trigs, <span class="keywordtype">long</span> inc, <span class="keywordtype">long</span> jump,
01534                    <span class="keywordtype">long</span> n, <span class="keywordtype">long</span> lot)
01535 {
01536   <span class="comment">/* Local variables */</span>
01537   <span class="keyword">static</span> <span class="keywordtype">double</span> c;
01538   <span class="keyword">static</span> <span class="keywordtype">long</span> k, l;
01539   <span class="keyword">static</span> <span class="keywordtype">double</span> s, scale;
01540   <span class="keyword">static</span> <span class="keywordtype">long</span> ia, ib, ja, jb, iabase, ibbase, nh, jabase, jbbase, nx, 
01541     ink;
01542 
01543 
01544 <span class="comment">/*     SUBROUTINE FFT99B - POSTPROCESSING STEP FOR FFT99, ISIGN=-1 */</span>
01545 <span class="comment">/*     (GRIDPOINT TO SPECTRAL TRANSFORM) */</span>
01546 
01547     <span class="comment">/* Parameter adjustments */</span>
01548   --a;
01549   --work;
01550 
01551     <span class="comment">/* Function Body */</span>
01552   nh = n / 2;
01553   nx = n + 1;
01554   ink = inc + inc;
01555 
01556   <span class="comment">/*     A(0) AND A(N/2) */</span>
01557   scale = 1.0 / (double) n;
01558   ia = 1;
01559   ib = 2;
01560   ja = 1;
01561   jb = n * inc + 1;
01562   <span class="comment">/* DIR$ IVDEP */</span>
01563   <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
01564     a[ja] = scale * (work[ia] + work[ib]);
01565     a[jb] = scale * (work[ia] - work[ib]);
01566     a[ja + inc] = 0.0;
01567     a[jb + inc] = 0.0;
01568     ia += nx;
01569     ib += nx;
01570     ja += jump;
01571     jb += jump;
01572     <span class="comment">/* L10: */</span>
01573   }
01574 
01575   <span class="comment">/*     REMAINING WAVENUMBERS */</span>
01576   scale *= 0.5;
01577   iabase = 3;
01578   ibbase = n - 1;
01579   jabase = (inc &lt;&lt; 1) + 1;
01580   jbbase = (n - 2) * inc + 1;
01581 
01582   <span class="keywordflow">for</span> (k = 3; k &lt;= nh; k += 2) {
01583     ia = iabase;
01584     ib = ibbase;
01585     ja = jabase;
01586     jb = jbbase;
01587     c = trigs[n + k - 1];
01588     s = trigs[n + k];
01589     <span class="comment">/* DIR$ IVDEP */</span>
01590     <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
01591       a[ja] = scale * (work[ia] + work[ib] + 
01592                        (c * (work[ia + 1] + work[ib + 1]) + 
01593                         s * (work[ia] - work[ib])));
01594       a[jb] = scale * (work[ia] + work[ib] - 
01595                        (c * (work[ia + 1] + work[ib + 1]) + 
01596                         s * (work[ia] - work[ib])));
01597       a[ja + inc] = scale * (c * (work[ia] - work[ib]) - 
01598                              s * (work[ia + 1] + work[ib + 1]) + 
01599                              (work[ib + 1] - work[ia + 1]));
01600       a[jb + inc] = scale * (c * (work[ia] - work[ib]) - 
01601                              s * (work[ia + 1] + work[ib + 1]) - 
01602                              (work[ib + 1] - work[ia + 1]));
01603       ia += nx;
01604       ib += nx;
01605       ja += jump;
01606       jb += jump;
01607       <span class="comment">/* L20: */</span>
01608     }
01609     iabase += 2;
01610     ibbase += -2;
01611     jabase += ink;
01612     jbbase -= ink;
01613     <span class="comment">/* L30: */</span>
01614   }
01615 
01616   <span class="keywordflow">if</span> (iabase != ibbase) {
01617     <span class="keywordflow">goto</span> L50;
01618   }
01619   <span class="comment">/*     WAVENUMBER N/4 (IF IT EXISTS) */</span>
01620   ia = iabase;
01621   ja = jabase;
01622   scale *= 2.0;
01623   <span class="comment">/* DIR$ IVDEP */</span>
01624   <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
01625     a[ja] = scale * work[ia];
01626     a[ja + inc] = -scale * work[ia + 1];
01627     ia += nx;
01628     ja += jump;
01629     <span class="comment">/* L40: */</span>
01630   }
01631 
01632  L50:
01633   <span class="keywordflow">return</span>;
01634 } <span class="comment">/* fft99b */</span>
01635 
<a name="l01636"></a><a class="code" href="fft99_8c.html#a10">01636</a> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a10">fft991</a>(<span class="keywordtype">double</span> *a, <span class="keywordtype">double</span> *work, <span class="keywordtype">double</span> *trigs, <span class="keywordtype">long</span> *ifax, <span class="keywordtype">long</span> inc, 
01637             <span class="keywordtype">long</span> jump, <span class="keywordtype">long</span> n, <span class="keywordtype">long</span> lot, <span class="keywordtype">long</span> isign)
01638 {
01639   <span class="comment">/* Local variables */</span>
01640   <span class="keyword">static</span> <span class="keywordtype">long</span> nfax, i, j, k, l, m, ibase, jbase;
01641   <span class="keyword">static</span> <span class="keywordtype">long</span> ia, ib, la, nh, nx;
01642   <span class="keyword">static</span> <span class="keywordtype">long</span> igo, ink;
01643 
01644 
01645 <span class="comment">/*     SUBROUTINE ^FFT991^ - MULTIPLE REAL/HALF-COMPLEX PERIODIC */</span>
01646 <span class="comment">/*     FAST FOURIER TRANSFORM */</span>
01647 
01648 <span class="comment">/*     SAME AS FFT99 EXCEPT THAT ORDERING OF DATA CORRESPONDS TO */</span>
01649 <span class="comment">/*     THAT IN MRFFT2 */</span>
01650 
01651 <span class="comment">/*     PROCEDURE USED TO CONVERT TO HALF-LENGTH COMPLEX TRANSFORM */</span>
01652 <span class="comment">/*     IS GIVEN BY COOLEY, LEWIS AND WELCH (J. SOUND VIB., VOL. 12 */</span>
01653 <span class="comment">/*     (1970), 315-337) */</span>
01654 
01655 <span class="comment">/*     A IS THE ARRAY CONTAINING INPUT AND OUTPUT DATA */</span>
01656 <span class="comment">/*     WORK IS AN AREA OF SIZE (N+1)*LOT */</span>
01657 <span class="comment">/*     TRIGS IS A PREVIOUSLY PREPARED LIST OF TRIG FUNCTION VALUES */</span>
01658 <span class="comment">/*     IFAX IS A PREVIOUSLY PREPARED LIST OF FACTORS OF N/2 */</span>
01659 <span class="comment">/*     INC IS THE INCREMENT WITHIN EACH DATA #VECTOR# */</span>
01660 <span class="comment">/*         (E.G. INC=1 FOR CONSECUTIVELY STORED DATA) */</span>
01661 <span class="comment">/*     JUMP IS THE INCREMENT BETWEEN THE START OF EACH DATA VECTOR */</span>
01662 <span class="comment">/*     N IS THE LENGTH OF THE DATA VECTORS */</span>
01663 <span class="comment">/*     LOT IS THE NUMBER OF DATA VECTORS */</span>
01664 <span class="comment">/*     ISIGN = +1 FOR TRANSFORM FROM SPECTRAL TO GRIDPOINT */</span>
01665 <span class="comment">/*           = -1 FOR TRANSFORM FROM GRIDPOINT TO SPECTRAL */</span>
01666 
01667 <span class="comment">/*     ORDERING OF COEFFICIENTS: */</span>
01668 <span class="comment">/*         A(0),B(0),A(1),B(1),A(2),B(2),...,A(N/2),B(N/2) */</span>
01669 <span class="comment">/*         WHERE B(0)=B(N/2)=0; (N+2) LOCATIONS REQUIRED */</span>
01670 
01671 <span class="comment">/*     ORDERING OF DATA: */</span>
01672 <span class="comment">/*         X(0),X(1),X(2),...,X(N-1) */</span>
01673 
01674 <span class="comment">/*     VECTORIZATION IS ACHIEVED ON CRAY BY DOING THE TRANSFORMS IN */</span>
01675 <span class="comment">/*     PARALLEL */</span>
01676 
01677 <span class="comment">/*     *** N.B. N IS ASSUMED TO BE AN EVEN NUMBER */</span>
01678 
01679 <span class="comment">/*     DEFINITION OF TRANSFORMS: */</span>
01680 <span class="comment">/*     ------------------------- */</span>
01681 
01682 <span class="comment">/*     ISIGN=+1: X(J)=SUM(K=0,...,N-1)(C(K)*EXP(2*I*J*K*PI/N)) */</span>
01683 <span class="comment">/*         WHERE C(K)=A(K)+I*B(K) AND C(N-K)=A(K)-I*B(K) */</span>
01684 
01685 <span class="comment">/*     ISIGN=-1: A(K)=(1/N)*SUM(J=0,...,N-1)(X(J)*COS(2*J*K*PI/N)) */</span>
01686 <span class="comment">/*               B(K)=-(1/N)*SUM(J=0,...,N-1)(X(J)*SIN(2*J*K*PI/N)) */</span>
01687 
01688     <span class="comment">/* Parameter adjustments */</span>
01689   --work;
01690   --a;
01691 
01692     <span class="comment">/* Function Body */</span>
01693   nfax = ifax[0];
01694   nx = n + 1;
01695   nh = n / 2;
01696   ink = inc + inc;
01697   <span class="keywordflow">if</span> (isign == 1) {
01698     <span class="keywordflow">goto</span> L30;
01699   }
01700 
01701   <span class="comment">/*     IF NECESSARY, TRANSFER DATA TO WORK AREA */</span>
01702   igo = 50;
01703   <span class="keywordflow">if</span> (nfax % 2 == 1) {
01704     <span class="keywordflow">goto</span> L40;
01705   }
01706   ibase = 1;
01707   jbase = 1;
01708   <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
01709     i = ibase;
01710     j = jbase;
01711     <span class="comment">/* DIR$ IVDEP */</span>
01712     <span class="keywordflow">for</span> (m = 1; m &lt;= n; ++m) {
01713       work[j] = a[i];
01714       i += inc;
01715       ++j;
01716       <span class="comment">/* L10: */</span>
01717     }
01718     ibase += jump;
01719     jbase += nx;
01720     <span class="comment">/* L20: */</span>
01721   }
01722 
01723   igo = 60;
01724   <span class="keywordflow">goto</span> L40;
01725 
01726   <span class="comment">/*     PREPROCESSING (ISIGN=+1) */</span>
01727   <span class="comment">/*     ------------------------ */</span>
01728 
01729  L30:
01730   <a class="code" href="fft99_8c.html#a3">fft99a</a>(&amp;a[1], &amp;work[1], trigs, inc, jump, n, lot);
01731   igo = 60;
01732 
01733 <span class="comment">/*     COMPLEX TRANSFORM */</span>
01734 <span class="comment">/*     ----------------- */</span>
01735 
01736  L40:
01737   ia = 1;
01738   la = 1;
01739   <span class="keywordflow">for</span> (k = 1; k &lt;= nfax; ++k) {
01740     <span class="keywordflow">if</span> (igo == 60) {
01741       <span class="keywordflow">goto</span> L60;
01742     }
01743     <span class="comment">/* L50: */</span>
01744     <a class="code" href="fft99_8c.html#a2">vpassm</a>(&amp;a[ia], &amp;a[ia + inc], &amp;work[1], &amp;work[2], trigs, ink, 2, jump, nx, 
01745            lot, nh, ifax[k], la);
01746     igo = 60;
01747     <span class="keywordflow">goto</span> L70;
01748   L60:
01749     <a class="code" href="fft99_8c.html#a2">vpassm</a>(&amp;work[1], &amp;work[2], &amp;a[ia], &amp;a[ia + inc], trigs, 2, ink, nx, jump, 
01750            lot, nh, ifax[k], la);
01751     igo = 50;
01752   L70:
01753     la *= ifax[k];
01754     <span class="comment">/* L80: */</span>
01755   }
01756 
01757   <span class="keywordflow">if</span> (isign == -1) {
01758     <span class="keywordflow">goto</span> L130;
01759   }
01760 
01761   <span class="comment">/*     IF NECESSARY, TRANSFER DATA FROM WORK AREA */</span>
01762   <span class="keywordflow">if</span> (nfax % 2 == 1) {
01763     <span class="keywordflow">goto</span> L110;
01764   }
01765   ibase = 1;
01766   jbase = 1;
01767   <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
01768     i = ibase;
01769     j = jbase;
01770     <span class="comment">/* DIR$ IVDEP */</span>
01771     <span class="keywordflow">for</span> (m = 1; m &lt;= n; ++m) {
01772       a[j] = work[i];
01773       ++i;
01774       j += inc;
01775       <span class="comment">/* L90: */</span>
01776     }
01777     ibase += nx;
01778     jbase += jump;
01779     <span class="comment">/* L100: */</span>
01780   }
01781 
01782   <span class="comment">/*     FILL IN ZEROS AT END */</span>
01783  L110:
01784   ib = n * inc + 1;
01785   <span class="comment">/* DIR$ IVDEP */</span>
01786   <span class="keywordflow">for</span> (l = 1; l &lt;= lot; ++l) {
01787     a[ib] = 0.0;
01788     a[ib + inc] = 0.0;
01789     ib += jump;
01790     <span class="comment">/* L120: */</span>
01791   }
01792   <span class="keywordflow">goto</span> L140;
01793 
01794 <span class="comment">/*     POSTPROCESSING (ISIGN=-1): */</span>
01795 <span class="comment">/*     -------------------------- */</span>
01796 
01797  L130:
01798   <a class="code" href="fft99_8c.html#a4">fft99b</a>(&amp;work[1], &amp;a[1], trigs, inc, jump, n, lot);
01799 
01800  L140:
01801   <span class="keywordflow">return</span>;
01802 } <span class="comment">/* fft991 */</span>
01803 
<a name="l01804"></a><a class="code" href="fft99_8c.html#a11">01804</a> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a11">fftfax</a>(<span class="keywordtype">long</span> n, <span class="keywordtype">long</span> *ifax, <span class="keywordtype">double</span> *trigs)
01805 {
01806     <span class="comment">/* Local variables */</span>
01807   <span class="keyword">static</span> <span class="keywordtype">long</span> i;
01808 
01809   <span class="comment">/* Function Body */</span>
01810   <a class="code" href="fft99_8c.html#a5">fax</a>(ifax, n);
01811   i = ifax[0];
01812   <span class="keywordflow">if</span> (ifax[i] &gt; 5 || n &lt;= 4) {
01813     ifax[0] = -99;
01814   }
01815   <span class="keywordflow">if</span> (ifax[0] &lt;= 0) 
01816     <span class="keywordflow">return</span>;
01817     
01818   <a class="code" href="fft99_8c.html#a6">fftrig</a>(trigs, n);
01819   <span class="keywordflow">return</span>;
01820 } <span class="comment">/* fftfax */</span>
01821 
<a name="l01822"></a><a class="code" href="fft99_8c.html#a5">01822</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a5">fax</a>(<span class="keywordtype">long</span> *ifax, <span class="keywordtype">long</span> n)
01823 {
01824   <span class="comment">/* Local variables */</span>
01825   <span class="keyword">static</span> <span class="keywordtype">long</span> nfax, item, i, k, l, istop, ii, nn, inc;
01826 
01827     <span class="comment">/* Function Body */</span>
01828   nn = n / 2;
01829   <span class="keywordflow">if</span> (nn + nn == n) {
01830     <span class="keywordflow">goto</span> L10;
01831   }
01832   ifax[0] = -99;
01833   <span class="keywordflow">return</span>;
01834  L10:
01835   k = 0;
01836   <span class="comment">/*     TEST FOR FACTORS OF 4 */</span>
01837  L20:
01838   <span class="keywordflow">if</span> (nn % 4 != 0) {
01839     <span class="keywordflow">goto</span> L30;
01840   }
01841   ++k;
01842   ifax[k] = 4;
01843   nn /= 4;
01844   <span class="keywordflow">if</span> (nn == 1) {
01845     <span class="keywordflow">goto</span> L80;
01846   }
01847   <span class="keywordflow">goto</span> L20;
01848   <span class="comment">/*     TEST FOR EXTRA FACTOR OF 2 */</span>
01849  L30:
01850   <span class="keywordflow">if</span> (nn % 2 != 0) {
01851     <span class="keywordflow">goto</span> L40;
01852   }
01853   ++k;
01854   ifax[k] = 2;
01855   nn /= 2;
01856   <span class="keywordflow">if</span> (nn == 1) {
01857     <span class="keywordflow">goto</span> L80;
01858   }
01859   <span class="comment">/*     TEST FOR FACTORS OF 3 */</span>
01860  L40:
01861   <span class="keywordflow">if</span> (nn % 3 != 0) {
01862     <span class="keywordflow">goto</span> L50;
01863   }
01864   ++k;
01865   ifax[k] = 3;
01866   nn /= 3;
01867   <span class="keywordflow">if</span> (nn == 1) {
01868     <span class="keywordflow">goto</span> L80;
01869   }
01870   <span class="keywordflow">goto</span> L40;
01871   <span class="comment">/*     NOW FIND REMAINING FACTORS */</span>
01872  L50:
01873   l = 5;
01874   inc = 2;
01875   <span class="comment">/*     INC ALTERNATELY TAKES ON VALUES 2 AND 4 */</span>
01876  L60:
01877   <span class="keywordflow">if</span> (nn % l != 0) {
01878     <span class="keywordflow">goto</span> L70;
01879   }
01880   ++k;
01881   ifax[k] = l;
01882   nn /= l;
01883   <span class="keywordflow">if</span> (nn == 1) {
01884     <span class="keywordflow">goto</span> L80;
01885   }
01886   <span class="keywordflow">goto</span> L60;
01887  L70:
01888   l += inc;
01889   inc = 6 - inc;
01890   <span class="keywordflow">goto</span> L60;
01891  L80:
01892   ifax[0] = k;
01893   <span class="comment">/*     IFAX(0) CONTAINS NUMBER OF FACTORS */</span>
01894   nfax = ifax[0];
01895   <span class="comment">/*     SORT FACTORS INTO ASCENDING ORDER */</span>
01896   <span class="keywordflow">if</span> (nfax == 1) 
01897     <span class="keywordflow">return</span>;
01898   
01899   <span class="keywordflow">for</span> (ii = 2; ii &lt;= nfax; ++ii) {
01900     istop = nfax + 2 - ii;
01901     <span class="keywordflow">for</span> (i = 2; i &lt;= istop; ++i) {
01902       <span class="keywordflow">if</span> (ifax[i] &lt; ifax[i - 1]) {
01903         item = ifax[i - 1];
01904         ifax[i - 1] = ifax[i];
01905         ifax[i] = item;
01906       }
01907     }
01908   }
01909   <span class="keywordflow">return</span>;
01910 } <span class="comment">/* fax */</span>
01911 
<a name="l01912"></a><a class="code" href="fft99_8c.html#a6">01912</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="fft99_8c.html#a6">fftrig</a>(<span class="keywordtype">double</span> *trigs, <span class="keywordtype">long</span> n)
01913 {
01914   <span class="comment">/* Local variables */</span>
01915   <span class="keyword">static</span> <span class="keywordtype">long</span> i, n2;
01916   <span class="keyword">static</span> <span class="keywordtype">double</span> angle;
01917   <span class="keyword">static</span> <span class="keywordtype">long</span> la, nh;
01918   <span class="keyword">static</span> <span class="keywordtype">long</span> nn;
01919   <span class="keyword">static</span> <span class="keywordtype">double</span> del;
01920 
01921     <span class="comment">/* Function Body */</span>
01922   nn = n / 2;
01923   del = (<a class="code" href="geo__to__km_8c.html#a0">PI</a> + <a class="code" href="geo__to__km_8c.html#a0">PI</a>) / (double) nn;
01924   n2 = nn + nn;
01925   <span class="keywordflow">for</span> (i = 0; i &lt; n2; i += 2) {
01926     angle = (double) i * 0.5 * del;
01927     trigs[i] = cos(angle);
01928     trigs[i + 1] = sin(angle);
01929   }
01930   del *= 0.5;
01931   nh = (nn + 1) / 2;
01932   n2 = nh + nh;
01933   la = nn + nn;
01934   <span class="keywordflow">for</span> (i = 0; i &lt; n2; i += 2) {
01935     angle = (double) i * 0.5 * del;
01936     trigs[la + i] = cos(angle);
01937     trigs[la + i + 1] = sin(angle);
01938   }
01939 
01940   <span class="keywordflow">return</span>;
01941 } <span class="comment">/* fftrig */</span>
01942 
</pre></div><hr><address style="align: right;"><small>Generated on Tue May 6 09:16:01 2003 for Earthworm Libs by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc3 </small></address>
</body>
</html>
