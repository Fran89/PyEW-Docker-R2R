<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>transport.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>transport.c</h1><a href="transport_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> *   THIS FILE IS UNDER RCS - DO NOT MODIFY UNLESS YOU HAVE</span>
00004 <span class="comment"> *   CHECKED IT OUT USING THE COMMAND CHECKOUT.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *    $Id: transport_8c-source.html 2161 2006-05-19 16:55:03Z paulf $</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *    Revision history:</span>
00009 <span class="comment"> *     $Log$
00009 <span class="comment"> *     Revision 1.1  2006/05/19 16:55:02  paulf
00009 <span class="comment"> *     first inclusion
00009 <span class="comment"> *</span>
00010 <span class="comment"> *     Revision 1.3  2001/05/04 23:43:54  dietz</span>
00011 <span class="comment"> *     Changed flag arg of tport_putflag from short to int to handle</span>
00012 <span class="comment"> *     processids properly.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> *     Revision 1.2  2000/06/02 18:19:48  dietz</span>
00015 <span class="comment"> *     Fixed tport_putmsg,tport_copyto to always release semaphore before returning</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> *     Revision 1.1  2000/02/14 18:53:30  lucky</span>
00018 <span class="comment"> *     Initial revision</span>
00019 <span class="comment"> *</span>
00020 <span class="comment"> *</span>
00021 <span class="comment"> */</span>
00022 
00023 <span class="comment">/********************************************************************/</span>
00024 <span class="comment">/*                                                        6/2000    */</span>
00025 <span class="comment">/*                           transport.c                            */</span>
00026 <span class="comment">/*                                                                  */</span>
00027 <span class="comment">/*   Transport layer functions to access shared memory regions.     */</span>
00028 <span class="comment">/*                                                                  */</span>
00029 <span class="comment">/*   written by Lynn Dietz, Will Kohler with inspiration from       */</span>
00030 <span class="comment">/*       Carl Johnson, Alex Bittenbinder, Barbara Bogaert           */</span>
00031 <span class="comment">/*                                                                  */</span>
00032 <span class="comment">/********************************************************************/</span>
00033 
00034 <span class="comment">/* ***** Notes on development, delete when appropriate</span>
00035 <span class="comment">1. Change the quotes for the transport.h and earthworm.h includes</span>
00036 <span class="comment">   when these are moved to the appropriately pathed included directory.</span>
00037 <span class="comment">*/</span>
00038 <span class="preprocessor">#include &lt;windows.h&gt;</span>
00039 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00040 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00041 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00042 <span class="preprocessor">#include &lt;string.h&gt;</span>
00043 <span class="preprocessor">#include &lt;time.h&gt;</span>
00044 <span class="preprocessor">#include &lt;process.h&gt;</span>
00045 <span class="preprocessor">#include &lt;<a class="code" href="transport_8h.html">transport.h</a>&gt;</span>
00046 
<a name="l00047"></a><a class="code" href="transport_8c.html#a0">00047</a> <span class="keyword">static</span> <span class="keywordtype">short</span> <a class="code" href="transport_8c.html#a0">Put_Init</a>=1;           <span class="comment">/* initialization flag */</span>
<a name="l00048"></a><a class="code" href="transport_8c.html#a1">00048</a> <span class="keyword">static</span> <span class="keywordtype">short</span> <a class="code" href="transport_8c.html#a1">Get_Init</a>=1;           <span class="comment">/* initialization flag */</span>
<a name="l00049"></a><a class="code" href="transport_8c.html#a2">00049</a> <span class="keyword">static</span> <span class="keywordtype">short</span> <a class="code" href="transport_8c.html#a2">Copyfrom_Init</a>=1;      <span class="comment">/* initialization flag */</span>
<a name="l00050"></a><a class="code" href="transport_8c.html#a3">00050</a> <span class="keyword">static</span> <span class="keywordtype">short</span> <a class="code" href="transport_8c.html#a3">Copyto_Init</a>  =1;      <span class="comment">/* initialization flag */</span>
00051 
00052 <span class="comment">/* These functions are for internal use by transport functions only</span>
00053 <span class="comment">   ****************************************************************/</span>
00054 <span class="keywordtype">void</span>  <a class="code" href="transport_8c.html#a13">tport_syserr</a>  ( <span class="keywordtype">char</span> *, <span class="keywordtype">long</span> );
00055 <span class="keywordtype">void</span>  <a class="code" href="transport_8c.html#a14">tport_buferror</a>( <span class="keywordtype">short</span>, <span class="keywordtype">char</span> * );
00056 
00057 <span class="comment">/* These statements and variables are required by the functions of</span>
00058 <span class="comment">   the input-buffering thread</span>
00059 <span class="comment">   ***************************************************************/</span>
00060 <span class="preprocessor">#include "<a class="code" href="earthworm_8h.html">earthworm.h</a>"</span>
<a name="l00061"></a><a class="code" href="transport_8c.html#a4">00061</a> <span class="keyword">volatile</span> <a class="code" href="structSHM__INFO.html">SHM_INFO</a> *<a class="code" href="transport_8c.html#a4">PubRegion</a>;      <span class="comment">/* transport public ring      */</span>
<a name="l00062"></a><a class="code" href="transport_8c.html#a5">00062</a> <span class="keyword">volatile</span> <a class="code" href="structSHM__INFO.html">SHM_INFO</a> *<a class="code" href="transport_8c.html#a5">BufRegion</a>;      <span class="comment">/* pointer to private ring    */</span>
<a name="l00063"></a><a class="code" href="transport_8c.html#a6">00063</a> <span class="keyword">volatile</span> <a class="code" href="structMSG__LOGO.html">MSG_LOGO</a> *<a class="code" href="transport_8c.html#a6">Getlogo</a>;        <span class="comment">/* array of logos to copy     */</span>
<a name="l00064"></a><a class="code" href="transport_8c.html#a7">00064</a> <span class="keyword">volatile</span> <span class="keywordtype">short</span>     <a class="code" href="transport_8c.html#a7">Nget</a>;           <span class="comment">/* number of logos in getlogo */</span>
<a name="l00065"></a><a class="code" href="transport_8c.html#a8">00065</a> <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span>  <a class="code" href="transport_8c.html#a8">MaxMsgSize</a>;     <span class="comment">/* size of message buffer     */</span>
<a name="l00066"></a><a class="code" href="transport_8c.html#a9">00066</a> <span class="keyword">volatile</span> <span class="keywordtype">char</span>     *<a class="code" href="transport_8c.html#a9">Message</a>;        <span class="comment">/* message buffer             */</span>
<a name="l00067"></a><a class="code" href="transport_8c.html#a10">00067</a> <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="transport_8c.html#a10">MyModuleId</a>;   <span class="comment">/* module id of main thread   */</span>
<a name="l00068"></a><a class="code" href="transport_8c.html#a11">00068</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>      <a class="code" href="transport_8c.html#a11">MyInstid</a>;       <span class="comment">/* instid of main thread      */</span>
<a name="l00069"></a><a class="code" href="transport_8c.html#a12">00069</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>      <a class="code" href="transport_8c.html#a12">TypeError</a>;      <span class="comment">/* type for error messages    */</span>
00070 
00071 <span class="comment">/******************** function tport_create *************************/</span>
00072 <span class="comment">/*         Create a shared memory region &amp; its semaphore,           */</span>
00073 <span class="comment">/*           attach to it and initialize header values.             */</span>
00074 <span class="comment">/********************************************************************/</span>
<a name="l00075"></a><a class="code" href="transport_8c.html#a15">00075</a> <span class="keywordtype">void</span> <a class="code" href="transport_8c.html#a15">tport_create</a>( <a class="code" href="structSHM__INFO.html">SHM_INFO</a> *region,   <span class="comment">/* info structure for memory region  */</span>
00076                    <span class="keywordtype">long</span>      nbytes,   <span class="comment">/* size of shared memory region      */</span>
00077                    <span class="keywordtype">long</span>      memkey )  <span class="comment">/* key to shared memory region       */</span>
00078 {
00079    <a class="code" href="structSHM__HEAD.html">SHM_HEAD</a>       *shm;       <span class="comment">/* pointer to start of memory region */</span>
00080    HANDLE         hshare;     <span class="comment">// Handle to memory shared file</span>
00081    HANDLE         hmutex;     <span class="comment">// Handle to mutex object</span>
00082    <span class="keywordtype">char</span>           share[20];  <span class="comment">// Shared file name from memkey</span>
00083    <span class="keywordtype">char</span>           mutex[20];  <span class="comment">// Mutex name</span>
00084    <span class="keywordtype">int</span>            err;        <span class="comment">// Error code from GetLastError()</span>
00085 
00086 <span class="comment">/**** Create shared memory region ****/</span>
00087    sprintf(share, <span class="stringliteral">"SHR_%ld"</span>, memkey);
00088    hshare = CreateFileMapping(
00089       (HANDLE)0xFFFFFFFF,  <span class="comment">// Request memory file (swap space)</span>
00090       NULL,                <span class="comment">// Security attributes</span>
00091       PAGE_READWRITE,      <span class="comment">// Access restrictions</span>
00092       0,                   <span class="comment">// High order size (for very large mappings)</span>
00093       nbytes,              <span class="comment">// Low order size</span>
00094       share);              <span class="comment">// Name of file for other processes</span>
00095    <span class="keywordflow">if</span> ( hshare == NULL )
00096    {
00097       err = GetLastError();
00098       <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="stringliteral">"CreateFileMapping"</span>, err);
00099    }
00100 
00101 <span class="comment">/**** Attach to shared memory region ****/</span>
00102    shm = (<a class="code" href="structSHM__HEAD.html">SHM_HEAD</a> *) MapViewOfFile(
00103       hshare,              <span class="comment">// File object to map</span>
00104       FILE_MAP_WRITE,      <span class="comment">// Access desired</span>
00105       0,                   <span class="comment">// High-order 32 bits of file offset</span>
00106       0,                   <span class="comment">// Low-order 32 bits of file offset</span>
00107       nbytes);             <span class="comment">// Number of bytes to map</span>
00108    <span class="keywordflow">if</span> ( shm == NULL )
00109    {
00110       err = GetLastError();
00111       <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="stringliteral">"MapViewOfFile"</span>, err );
00112    }
00113 
00114 <span class="comment">/**** Initialize shared memory region header ****/</span>
00115    shm-&gt;<a class="code" href="structSHM__HEAD.html#m0">nbytes</a> = nbytes;
00116    shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> = nbytes - <span class="keyword">sizeof</span>(SHM_HEAD);
00117    shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a>  = <span class="keyword">sizeof</span>(SHM_HEAD);
00118    shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> = shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a>;
00119    shm-&gt;<a class="code" href="structSHM__HEAD.html#m4">flag</a>   = 0;
00120 
00121 <span class="comment">/**** Make semaphore for this shared memory region &amp; set semval = SHM_FREE ****/</span>
00122    sprintf(mutex, <span class="stringliteral">"MTX_%ld"</span>, memkey);
00123    hmutex = CreateMutex(
00124       NULL,                <span class="comment">// Security attributes</span>
00125       FALSE,               <span class="comment">// Initial ownership</span>
00126       mutex);              <span class="comment">// Name of mutex (derived from memkey)</span>
00127    <span class="keywordflow">if</span> ( hmutex == NULL )
00128    {
00129       err = GetLastError();
00130       <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="stringliteral">"CreateMutex"</span>, err);
00131    }
00132 
00133 <span class="comment">/**** set values in the shared memory information structure ****/</span>
00134    region-&gt;<a class="code" href="structSHM__INFO.html#m0">addr</a> = shm;
00135    region-&gt;hShare = hshare;
00136    region-&gt;hMutex = hmutex;
00137    region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>  = memkey;
00138 }
00139 
00140 
00141 <span class="comment">/******************** function tport_destroy *************************/</span>
00142 <span class="comment">/*                Destroy a shared memory region.                    */</span>
00143 <span class="comment">/*********************************************************************/</span>
00144 
<a name="l00145"></a><a class="code" href="transport_8c.html#a16">00145</a> <span class="keywordtype">void</span> <a class="code" href="transport_8c.html#a16">tport_destroy</a>( <a class="code" href="structSHM__INFO.html">SHM_INFO</a> *region )
00146 {
00147    <span class="keywordtype">int</span> err;
00148 
00149 <span class="comment">/***** Set kill flag, give other attached programs time to terminate ****/</span>
00150 
00151    <a class="code" href="transport_8c.html#a21">tport_putflag</a>( region, TERMINATE );
00152    Sleep( 1000 );
00153 
00154 <span class="comment">/***** Detach from shared memory region *****/</span>
00155    <span class="keywordflow">if</span>(!UnmapViewOfFile( region-&gt;<a class="code" href="structSHM__INFO.html#m0">addr</a> )) {
00156       err = GetLastError();
00157       <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="stringliteral">"UnmapViewOfFile"</span>, err);
00158    }
00159 
00160 <span class="comment">/***** Destroy semaphore set for shared memory region *****/</span>
00161    <span class="keywordflow">if</span>(!CloseHandle(region-&gt;hMutex)) {
00162       err = GetLastError();
00163       <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="stringliteral">"CloseHandle (mutex)"</span>, err);
00164    }
00165 
00166 
00167 <span class="comment">/***** Destroy shared memory region *****/</span>
00168    <span class="keywordflow">if</span>(!CloseHandle(region-&gt;hShare)) {
00169       err = GetLastError();
00170       <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="stringliteral">"CloseHandle (share)"</span>, err);
00171    }
00172 }
00173 
00174 <span class="comment">/******************** function tport_attach *************************/</span>
00175 <span class="comment">/*            Map to an existing shared memory region.              */</span>
00176 <span class="comment">/********************************************************************/</span>
00177 
<a name="l00178"></a><a class="code" href="transport_8c.html#a17">00178</a> <span class="keywordtype">void</span> <a class="code" href="transport_8c.html#a17">tport_attach</a>( <a class="code" href="structSHM__INFO.html">SHM_INFO</a> *region,   <span class="comment">/* info structure for memory region  */</span>
00179                    <span class="keywordtype">long</span>      memkey )  <span class="comment">/* key to shared memory region       */</span>
00180 {
00181    <a class="code" href="structSHM__HEAD.html">SHM_HEAD</a>       *shm;       <span class="comment">/* pointer to start of memory region */</span>
00182    HANDLE         hshare;     <span class="comment">// Handle to memory shared file</span>
00183    HANDLE         hmutex;     <span class="comment">// Handle to mutex object</span>
00184    <span class="keywordtype">char</span>           share[20];  <span class="comment">// Shared file name from memkey</span>
00185    <span class="keywordtype">char</span>           mutex[20];  <span class="comment">// Mutex name</span>
00186    <span class="keywordtype">int</span>            err;        <span class="comment">// Error code from GetLastError()</span>
00187 
00188 <span class="comment">/**** Create shared memory region ****/</span>
00189    sprintf(share, <span class="stringliteral">"SHR_%ld"</span>, memkey);
00190    hshare = OpenFileMapping(
00191        FILE_MAP_WRITE,
00192        TRUE,
00193        share);
00194    <span class="keywordflow">if</span> ( hshare == NULL )
00195    {
00196       err = GetLastError();
00197       <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="stringliteral">"OpenFileMapping"</span>, err);
00198    }
00199 
00200 <span class="comment">/**** Attach to shared memory region ****/</span>
00201    shm = (<a class="code" href="structSHM__HEAD.html">SHM_HEAD</a> *) MapViewOfFile(
00202       hshare,              <span class="comment">// File object to map</span>
00203       FILE_MAP_WRITE,      <span class="comment">// Access desired</span>
00204       0,                   <span class="comment">// High-order 32 bits of file offset</span>
00205       0,                   <span class="comment">// Low-order 32 bits of file offset</span>
00206       0);                  <span class="comment">// Number of bytes to map</span>
00207    <span class="keywordflow">if</span> ( shm == NULL )
00208    {
00209       err = GetLastError();
00210       <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="stringliteral">"MapViewOfFile"</span>, err );
00211    }
00212 
00213 <span class="comment">/**** Make semaphore for this shared memory region &amp; set semval = SHM_FREE ****/</span>
00214    sprintf(mutex, <span class="stringliteral">"MTX_%ld"</span>, memkey);
00215    hmutex = CreateMutex(
00216       NULL,                <span class="comment">// Security attributes</span>
00217       FALSE,               <span class="comment">// Initial ownership</span>
00218       mutex);              <span class="comment">// Name of mutex (derived from memkey)</span>
00219    <span class="keywordflow">if</span> ( hmutex == NULL )
00220    {
00221       err = GetLastError();
00222       <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="stringliteral">"CreateMutex"</span>, err);
00223    }
00224 
00225 <span class="comment">/**** set values in the shared memory information structure ****/</span>
00226    region-&gt;<a class="code" href="structSHM__INFO.html#m0">addr</a> = shm;
00227    region-&gt;hShare = hshare;
00228    region-&gt;hMutex = hmutex;
00229    region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>  = memkey;
00230 }
00231 
00232 <span class="comment">/******************** function tport_detach **************************/</span>
00233 <span class="comment">/*                Detach from a shared memory region.                */</span>
00234 <span class="comment">/*********************************************************************/</span>
00235 
<a name="l00236"></a><a class="code" href="transport_8c.html#a18">00236</a> <span class="keywordtype">void</span> <a class="code" href="transport_8c.html#a18">tport_detach</a>( <a class="code" href="structSHM__INFO.html">SHM_INFO</a> *region )
00237 {
00238    <span class="keywordtype">int</span> err;
00239 
00240 <span class="comment">/***** Detach from shared memory region *****/</span>
00241    <span class="keywordflow">if</span>(!UnmapViewOfFile( region-&gt;<a class="code" href="structSHM__INFO.html#m0">addr</a> )) {
00242       err = GetLastError();
00243       <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="stringliteral">"UnmapViewOfFile"</span>, err);
00244    }
00245 
00246 <span class="comment">/***** Destroy semaphore set for shared memory region *****/</span>
00247    <span class="keywordflow">if</span>(!CloseHandle(region-&gt;hMutex)) {
00248       err = GetLastError();
00249       <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="stringliteral">"CloseHandle (mutex)"</span>, err);
00250    }
00251 
00252 
00253 <span class="comment">/***** Destroy shared memory region *****/</span>
00254    <span class="keywordflow">if</span>(!CloseHandle(region-&gt;hShare)) {
00255       err = GetLastError();
00256       <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="stringliteral">"CloseHandle (share)"</span>, err);
00257    }
00258 }
00259 
00260 
00261 
00262 <span class="comment">/*********************** function tport_putmsg ***********************/</span>
00263 <span class="comment">/*            Put a message into a shared memory region.             */</span>
00264 <span class="comment">/*            Assigns a transport-layer sequence number.             */</span>
00265 <span class="comment">/*********************************************************************/</span>
00266 
<a name="l00267"></a><a class="code" href="transport_8c.html#a19">00267</a> <span class="keywordtype">int</span> <a class="code" href="transport_8c.html#a19">tport_putmsg</a>( <a class="code" href="structSHM__INFO.html">SHM_INFO</a> *region,    <span class="comment">/* info structure for memory region    */</span>
00268                   <a class="code" href="structMSG__LOGO.html">MSG_LOGO</a> *putlogo,   <span class="comment">/* type, module, instid of incoming msg */</span>
00269                   <span class="keywordtype">long</span>      length,    <span class="comment">/* size of incoming message            */</span>
00270                   <span class="keywordtype">char</span>     *msg )      <span class="comment">/* pointer to incoming message         */</span>
00271 {
00272    <span class="keyword">volatile</span> <span class="keyword">static</span> <a class="code" href="structMSG__TRACK.html">MSG_TRACK</a>  trak[<a class="code" href="transport_8h.html#a1">NTRACK_PUT</a>];   <span class="comment">/* sequence number keeper   */</span>
00273    <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keywordtype">int</span>        nlogo;              <span class="comment">/* # of logos seen so far   */</span>
00274    <span class="keywordtype">int</span>                        it;                 <span class="comment">/* index into trak          */</span>
00275    <a class="code" href="structSHM__HEAD.html">SHM_HEAD</a>         *shm;              <span class="comment">/* pointer to start of memory region   */</span>
00276    <span class="keywordtype">char</span>             *ring;             <span class="comment">/* pointer to ring part of memory      */</span>
00277    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     ir;               <span class="comment">/* index into memory ring              */</span>
00278    <span class="keywordtype">long</span>              nfill;            <span class="comment">/* # bytes from ir to ring's last-byte */</span>
00279    <span class="keywordtype">long</span>              nwrap;            <span class="comment">/* # bytes to wrap to front of ring    */</span>
00280    <a class="code" href="structTPORT__HEAD.html">TPORT_HEAD</a>        hd;               <span class="comment">/* transport layer header to put       */</span>
00281    <span class="keywordtype">char</span>             *h;                <span class="comment">/* pointer to transport layer header   */</span>
00282    <a class="code" href="structTPORT__HEAD.html">TPORT_HEAD</a>        old;              <span class="comment">/* transport header of oldest msg      */</span>
00283    <span class="keywordtype">char</span>             *o;                <span class="comment">/* pointer to oldest transport header  */</span>
00284    <span class="keywordtype">int</span> j;
00285    <span class="keywordtype">int</span> retval = <a class="code" href="transport_8h.html#a5">PUT_OK</a>;                <span class="comment">/* return value for this function      */</span>
00286 
00287 <span class="comment">/**** First time around, init the sequence counters, semaphore controls ****/</span>
00288 
00289    <span class="keywordflow">if</span> (Put_Init)
00290    {
00291        nlogo    = 0;
00292 
00293        <span class="keywordflow">for</span>( j=0 ; j &lt; <a class="code" href="transport_8h.html#a1">NTRACK_PUT</a> ; j++ )
00294        {
00295           trak[j].<a class="code" href="structMSG__TRACK.html#m0">memkey</a>      = 0;
00296           trak[j].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   = 0;
00297           trak[j].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    = 0;
00298           trak[j].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> = 0;
00299           trak[j].<a class="code" href="structMSG__TRACK.html#m2">seq</a>         = 0;
00300           trak[j].<a class="code" href="structMSG__TRACK.html#m3">keyout</a>      = 0;
00301        }
00302 
00303        <a class="code" href="transport_8c.html#a0">Put_Init</a> = 0;
00304    }
00305 
00306 <span class="comment">/**** Set up pointers for shared memory, etc. ****/</span>
00307 
00308    shm  = region-&gt;<a class="code" href="structSHM__INFO.html#m0">addr</a>;
00309    ring = (<span class="keywordtype">char</span> *) shm + <span class="keyword">sizeof</span>(SHM_HEAD);
00310    h    = (<span class="keywordtype">char</span> *) (&amp;hd);
00311    o    = (<span class="keywordtype">char</span> *) (&amp;old);
00312 
00313 <span class="comment">/**** First, see if the incoming message will fit in the memory region ****/</span>
00314 
00315    <span class="keywordflow">if</span> ( length + <span class="keyword">sizeof</span>(TPORT_HEAD) &gt; shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> )
00316    {
00317       fprintf( stdout,
00318               <span class="stringliteral">"ERROR: tport_putmsg; message too large (%ld) for Region %ld\n"</span>,
00319                length, region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>);
00320       <span class="keywordflow">return</span>( PUT_TOOBIG );
00321    }
00322 
00323 <span class="comment">/**** Change semaphore; let others know you're using tracking structure &amp; memory  ****/</span>
00324 
00325    WaitForSingleObject(region-&gt;hMutex, INFINITE);
00326 
00327 <span class="comment">/**** Next, find incoming logo in list of combinations already seen ****/</span>
00328 
00329    <span class="keywordflow">for</span>( it=0 ; it &lt; nlogo ; it++ )
00330    {
00331       <span class="keywordflow">if</span> ( region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>     != trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a>     )  <span class="keywordflow">continue</span>;
00332       <span class="keywordflow">if</span> ( putlogo-&gt;<a class="code" href="structMSG__LOGO.html#m0">type</a>   != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>  )  <span class="keywordflow">continue</span>;
00333       <span class="keywordflow">if</span> ( putlogo-&gt;<a class="code" href="structMSG__LOGO.html#m1">mod</a>    != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>   )  <span class="keywordflow">continue</span>;
00334       <span class="keywordflow">if</span> ( putlogo-&gt;<a class="code" href="structMSG__LOGO.html#m2">instid</a> != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> ) <span class="keywordflow">continue</span>;
00335       <span class="keywordflow">goto</span> build_header;
00336    }
00337 
00338 <span class="comment">/**** Incoming logo is a new combination; store it, if there's room ****/</span>
00339 
00340    <span class="keywordflow">if</span> ( nlogo == <a class="code" href="transport_8h.html#a1">NTRACK_PUT</a> )
00341    {
00342       fprintf( stdout,
00343               <span class="stringliteral">"ERROR: tport_putmsg; exceeded NTRACK_PUT, msg not sent\n"</span>);
00344       retval = <a class="code" href="transport_8h.html#a6">PUT_NOTRACK</a>;
00345       <span class="keywordflow">goto</span> release_semaphore; 
00346    }
00347    it = nlogo;
00348    trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a> =  region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>;
00349    trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>   = *putlogo;
00350    nlogo++;
00351 
00352 <span class="comment">/**** Store everything you need in the transport header ****/</span>
00353 
00354 build_header:
00355    hd.<a class="code" href="structTPORT__HEAD.html#m0">start</a> = <a class="code" href="transport_8h.html#a3">FIRST_BYTE</a>;
00356    hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a>  = length;
00357    hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>  = trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>;
00358    hd.<a class="code" href="structTPORT__HEAD.html#m3">seq</a>   = trak[it].<a class="code" href="structMSG__TRACK.html#m2">seq</a>++;
00359 
00360 <span class="comment">/**** In shared memory, see if keyin will wrap; if so, reset keyin and keyold ****/</span>
00361 
00362    <span class="keywordflow">if</span> ( shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a> + <span class="keyword">sizeof</span>(TPORT_HEAD) + length  &lt;  shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> )
00363    {
00364        shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a>  = shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a>  % shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00365        shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> = shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> % shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00366        <span class="keywordflow">if</span> ( shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a> &lt;= shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> ) shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a> += shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00367      <span class="comment">/*fprintf( stdout,</span>
00368 <span class="comment">               "NOTICE: tport_putmsg; keyin wrapped &amp; reset; Region %ld\n",</span>
00369 <span class="comment">                region-&gt;key );*/</span>
00370    }
00371 
00372 <span class="comment">/**** Then see if there's enough room for new message in shared memory ****/</span>
00373 <span class="comment">/****      If not, "delete" oldest messages until there's room         ****/</span>
00374 
00375    <span class="keywordflow">while</span>( shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a> + <span class="keyword">sizeof</span>(TPORT_HEAD) + length - shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> &gt; shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> )
00376    {
00377       ir = shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> % shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00378       <span class="keywordflow">if</span> ( ring[ir] != <a class="code" href="transport_8h.html#a3">FIRST_BYTE</a> )
00379       {
00380           fprintf( stdout,
00381                   <span class="stringliteral">"ERROR: tport_putmsg; keyold not at FIRST_BYTE, Region %ld\n"</span>,
00382                    region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> );
00383           retval = <a class="code" href="transport_8h.html#a4">TPORT_FATAL</a>;
00384           <span class="keywordflow">goto</span> release_semaphore; 
00385       }
00386       <span class="keywordflow">for</span> ( j=0 ; j &lt; <span class="keyword">sizeof</span>(TPORT_HEAD) ; j++ )
00387       {
00388          <span class="keywordflow">if</span> ( ir &gt;= shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> )   ir -= shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00389          o[j] = ring[ir++];
00390       }
00391       shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> += <span class="keyword">sizeof</span>(TPORT_HEAD) + old.<a class="code" href="structTPORT__HEAD.html#m1">size</a>;
00392    }
00393 
00394 <span class="comment">/**** Now copy transport header into shared memory by chunks... ****/</span>
00395 
00396    ir = shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a> % shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00397    nwrap = ir + <span class="keyword">sizeof</span>(TPORT_HEAD) - shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00398    <span class="keywordflow">if</span> ( nwrap &lt;= 0 )
00399    {
00400          memcpy( (<span class="keywordtype">void</span> *) &amp;ring[ir], (<span class="keywordtype">void</span> *) h, <span class="keyword">sizeof</span>(<a class="code" href="structTPORT__HEAD.html">TPORT_HEAD</a>) );
00401    }
00402    <span class="keywordflow">else</span>
00403    {
00404          nfill = <span class="keyword">sizeof</span>(TPORT_HEAD) - nwrap;
00405          memcpy( (<span class="keywordtype">void</span> *) &amp;ring[ir], (<span class="keywordtype">void</span> *) &amp;h[0],     nfill );
00406          memcpy( (<span class="keywordtype">void</span> *) &amp;ring[0],  (<span class="keywordtype">void</span> *) &amp;h[nfill], nwrap );
00407    }
00408    ir += <span class="keyword">sizeof</span>(TPORT_HEAD);
00409    <span class="keywordflow">if</span> ( ir &gt;= shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> )  ir -= shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00410 
00411 <span class="comment">/**** ...and copy message into shared memory by chunks ****/</span>
00412 
00413    nwrap = ir + length - shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00414    <span class="keywordflow">if</span> ( nwrap &lt;= 0 )
00415    {
00416          memcpy( (<span class="keywordtype">void</span> *) &amp;ring[ir], (<span class="keywordtype">void</span> *) msg, length );
00417    }
00418    <span class="keywordflow">else</span>
00419    {
00420          nfill = length - nwrap;
00421          memcpy( (<span class="keywordtype">void</span> *) &amp;ring[ir], (<span class="keywordtype">void</span> *) &amp;msg[0],     nfill );
00422          memcpy( (<span class="keywordtype">void</span> *) &amp;ring[0],  (<span class="keywordtype">void</span> *) &amp;msg[nfill], nwrap );
00423    }
00424    shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a> += <span class="keyword">sizeof</span>(TPORT_HEAD) + length;
00425 
00426 <span class="comment">/**** Finished with shared memory, let others know via semaphore ****/</span>
00427 
00428 release_semaphore:
00429    ReleaseMutex(region-&gt;hMutex);
00430 
00431    <span class="keywordflow">if</span>( retval == <a class="code" href="transport_8h.html#a4">TPORT_FATAL</a> ) exit( 1 );
00432    <span class="keywordflow">return</span>( retval ); 
00433 }
00434 
00435 
00436 <span class="comment">/*********************** function tport_getmsg ***********************/</span>
00437 <span class="comment">/*                 Get a message out of shared memory.               */</span>
00438 <span class="comment">/*********************************************************************/</span>
00439 
<a name="l00440"></a><a class="code" href="transport_8c.html#a20">00440</a> <span class="keywordtype">int</span> <a class="code" href="transport_8c.html#a20">tport_getmsg</a>( <a class="code" href="structSHM__INFO.html">SHM_INFO</a>  *region,   <span class="comment">/* info structure for memory region  */</span>
00441                   <a class="code" href="structMSG__LOGO.html">MSG_LOGO</a>  *getlogo,  <span class="comment">/* requested logo(s)                 */</span>
00442                   <span class="keywordtype">short</span>      nget,     <span class="comment">/* number of logos in getlogo        */</span>
00443                   <a class="code" href="structMSG__LOGO.html">MSG_LOGO</a>  *logo,     <span class="comment">/* logo of retrieved msg             */</span>
00444                   <span class="keywordtype">long</span>      *length,   <span class="comment">/* size of retrieved message         */</span>
00445                   <span class="keywordtype">char</span>      *msg,      <span class="comment">/* retrieved message                 */</span>
00446                   <span class="keywordtype">long</span>       maxsize ) <span class="comment">/* max length for retrieved message  */</span>
00447 {
00448    <span class="keyword">static</span> <a class="code" href="structMSG__TRACK.html">MSG_TRACK</a>  trak[<a class="code" href="transport_8h.html#a2">NTRACK_GET</a>]; <span class="comment">/* sequence #, outpointer keeper     */</span>
00449    <span class="keyword">static</span> <span class="keywordtype">int</span>        nlogo;            <span class="comment">/* # modid,type,instid combos so far */</span>
00450    <span class="keywordtype">int</span>               it;               <span class="comment">/* index into trak                   */</span>
00451    <a class="code" href="structSHM__HEAD.html">SHM_HEAD</a>         *shm;              <span class="comment">/* pointer to start of memory region */</span>
00452    <span class="keywordtype">char</span>             *ring;             <span class="comment">/* pointer to ring part of memory    */</span>
00453    <a class="code" href="structTPORT__HEAD.html">TPORT_HEAD</a>       *tmphd;            <span class="comment">/* temp pointer into shared memory   */</span>
00454    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     ir;               <span class="comment">/* index into the ring               */</span>
00455    <span class="keywordtype">long</span>              nfill;            <span class="comment">/* bytes from ir to ring's last-byte */</span>
00456    <span class="keywordtype">long</span>              nwrap;            <span class="comment">/* bytes to grab from front of ring  */</span>
00457    <a class="code" href="structTPORT__HEAD.html">TPORT_HEAD</a>        hd;               <span class="comment">/* transport header from memory      */</span>
00458    <span class="keywordtype">char</span>             *h;                <span class="comment">/* pointer to transport layer header */</span>
00459    <span class="keywordtype">int</span>               ih;               <span class="comment">/* index into the transport header   */</span>
00460    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     keyin;            <span class="comment">/* in-pointer to shared memory       */</span>
00461    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     keyold;           <span class="comment">/* oldest complete message in memory */</span>
00462    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     keyget;           <span class="comment">/* pointer at which to start search  */</span>
00463    <span class="keywordtype">int</span>               status = <a class="code" href="transport_8h.html#a8">GET_OK</a>;  <span class="comment">/* how did retrieval go?             */</span>
00464    <span class="keywordtype">int</span>               trakked;          <span class="comment">/* flag for trakking list entries    */</span>
00465    <span class="keywordtype">int</span>               i,j;
00466 
00467 <span class="comment">/**** Get the pointers set up ****/</span>
00468 
00469    shm  = region-&gt;<a class="code" href="structSHM__INFO.html#m0">addr</a>;
00470    ring = (<span class="keywordtype">char</span> *) shm + <span class="keyword">sizeof</span>(SHM_HEAD);
00471    h    = (<span class="keywordtype">char</span> *) (&amp;hd);
00472 
00473 <span class="comment">/**** First time around, initialize sequence counters, outpointers ****/</span>
00474 
00475    <span class="keywordflow">if</span> (Get_Init)
00476    {
00477        nlogo = 0;
00478 
00479        <span class="keywordflow">for</span>( i=0 ; i &lt; <a class="code" href="transport_8h.html#a2">NTRACK_GET</a> ; i++ )
00480        {
00481           trak[i].<a class="code" href="structMSG__TRACK.html#m0">memkey</a>      = 0;
00482           trak[i].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   = 0;
00483           trak[i].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    = 0;
00484           trak[i].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> = 0;
00485           trak[i].<a class="code" href="structMSG__TRACK.html#m2">seq</a>         = 0;
00486           trak[i].<a class="code" href="structMSG__TRACK.html#m3">keyout</a>      = 0;
00487           trak[i].<a class="code" href="structMSG__TRACK.html#m4">active</a>      = 0; <span class="comment">/*960618:ldd*/</span>
00488        }
00489        <a class="code" href="transport_8c.html#a1">Get_Init</a> = 0;
00490    }
00491 
00492 <span class="comment">/**** make sure all requested logos are entered in tracking list ****/</span>
00493 
00494    <span class="keywordflow">for</span> ( j=0 ; j &lt; nget ; j++ )  <span class="comment">/* for all requested message logos */</span>
00495    {
00496        trakked = 0;  <span class="comment">/* assume it's not being trakked */</span>
00497        <span class="keywordflow">for</span>( it=0 ; it &lt; nlogo ; it++ )  <span class="comment">/* for all logos we're tracking */</span>
00498        {
00499           <span class="keywordflow">if</span>( region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>       != trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a>      ) <span class="keywordflow">continue</span>;
00500           <span class="keywordflow">if</span>( getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a>   != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   ) <span class="keywordflow">continue</span>;
00501           <span class="keywordflow">if</span>( getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>    != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    ) <span class="keywordflow">continue</span>;
00502           <span class="keywordflow">if</span>( getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a> != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> ) <span class="keywordflow">continue</span>;
00503           trakked = 1;  <span class="comment">/* found it in the trakking list! */</span>
00504           <span class="keywordflow">break</span>;
00505        }
00506        <span class="keywordflow">if</span>( trakked ) <span class="keywordflow">continue</span>;
00507     <span class="comment">/* Make an entry in trak for this logo; if there's room */</span>
00508        <span class="keywordflow">if</span> ( nlogo &lt; <a class="code" href="transport_8h.html#a2">NTRACK_GET</a> )
00509        {
00510           it = nlogo;
00511           trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a> = region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>;
00512           trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>   = getlogo[j];
00513           nlogo++;
00514        }
00515    }
00516 
00517 <span class="comment">/**** find latest starting index to look for any of the requested logos ****/</span>
00518 
00519 findkey:
00520 
00521    keyget = shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a>;
00522 
00523    <span class="keywordflow">for</span> ( it=0 ; it &lt; nlogo ; it++ )  <span class="comment">/* for all message logos we're tracking */</span>
00524    {
00525        <span class="keywordflow">if</span> ( trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a> != region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> ) <span class="keywordflow">continue</span>;
00526        <span class="keywordflow">for</span> ( j=0 ; j &lt; nget ; j++ )  <span class="comment">/* for all requested message logos */</span>
00527        {
00528           <span class="keywordflow">if</span>((getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a>   == trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   || getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a>==<a class="code" href="transport_8h.html#a0">WILD</a>  ) &amp;&amp;
00529              (getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>    == trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    || getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>==<a class="code" href="transport_8h.html#a0">WILD</a>   ) &amp;&amp;
00530              (getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a> == trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> || getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a>==<a class="code" href="transport_8h.html#a0">WILD</a>) )
00531           {
00532              <span class="keywordflow">if</span> ( trak[it].<a class="code" href="structMSG__TRACK.html#m3">keyout</a> &gt; keyget )  keyget = trak[it].<a class="code" href="structMSG__TRACK.html#m3">keyout</a>;
00533           }
00534        }
00535     }
00536     keyin = shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a>;
00537 
00538 <span class="comment">/**** See if keyin and keyold were wrapped and reset by tport_putmsg; ****/</span>
00539 <span class="comment">/****       If so, reset trak[xx].keyout and go back to findkey       ****/</span>
00540 
00541    <span class="keywordflow">if</span> ( keyget &gt; keyin )
00542    {
00543       keyold = shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a>;
00544       <span class="keywordflow">for</span> ( it=0 ; it &lt; nlogo ; it++ )
00545       {
00546          <span class="keywordflow">if</span>( trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a> == region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> )
00547          {
00548           <span class="comment">/* reset keyout */</span>
00549 <span class="comment">/*DEBUG*/</span>    <span class="comment">/*printf("tport_getmsg: Pre-reset:  keyout=%10u    keyold=%10u  keyin=%10u\n",</span>
00550 <span class="comment">                     trak[it].keyout, keyold, keyin );*/</span>
00551              trak[it].<a class="code" href="structMSG__TRACK.html#m3">keyout</a> = trak[it].<a class="code" href="structMSG__TRACK.html#m3">keyout</a> % shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00552 <span class="comment">/*DEBUG*/</span>    <span class="comment">/*printf("tport_getmsg:  Intermed:  keyout=%10u    keyold=%10u  keyin=%10u\n",</span>
00553 <span class="comment">                     trak[it].keyout, keyold, keyin );*/</span>
00554 
00555           <span class="comment">/* make sure new keyout points to keyin or to a msg's first-byte; */</span>
00556           <span class="comment">/* if not, we've been lapped, so set keyout to keyold             */</span>
00557              ir    = trak[it].<a class="code" href="structMSG__TRACK.html#m3">keyout</a>;
00558              tmphd = (<a class="code" href="structTPORT__HEAD.html">TPORT_HEAD</a> *) &amp;ring[ir];
00559              <span class="keywordflow">if</span> ( trak[it].keyout == keyin   ||
00560                   (keyin-trak[it].keyout)%shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> == 0 )
00561              {
00562 <span class="comment">/*DEBUG*/</span>       <span class="comment">/*printf("tport_getmsg:  Intermed:  keyout=%10u  same as keyin\n",</span>
00563 <span class="comment">                       trak[it].keyout );*/</span>
00564                 trak[it].keyout = keyin;
00565              }
00566              <span class="keywordflow">else</span> <span class="keywordflow">if</span>( tmphd-&gt;<a class="code" href="structTPORT__HEAD.html#m0">start</a> != <a class="code" href="transport_8h.html#a3">FIRST_BYTE</a> )
00567              {
00568 <span class="comment">/*DEBUG*/</span>       <span class="comment">/*printf("tport_getmsg:  Intermed:  keyout=%10u  does not point to FIRST_BYTE\n",</span>
00569 <span class="comment">                        trak[it].keyout );*/</span>
00570                 trak[it].keyout = keyold;
00571              }
00572 
00573           <span class="comment">/* else, make sure keyout's value is between keyold and keyin */</span>
00574              <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( trak[it].keyout &lt; keyold )
00575              {
00576                 <span class="keywordflow">do</span> {
00577                     trak[it].keyout += shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00578                 } <span class="keywordflow">while</span> ( trak[it].keyout &lt; keyold );
00579              }
00580 <span class="comment">/*DEBUG*/</span>    <span class="comment">/*printf("tport_getmsg:     Reset:  keyout=%10u    keyold=%10u  keyin=%10u\n",</span>
00581 <span class="comment">                     trak[it].keyout, keyold, keyin );*/</span>
00582          }
00583       }
00584     <span class="comment">/*fprintf( stdout,</span>
00585 <span class="comment">          "NOTICE: tport_getmsg; keyin wrapped, keyout(s) reset; Region %ld\n",</span>
00586 <span class="comment">           region-&gt;key );*/</span>
00587 
00588       <span class="keywordflow">goto</span> findkey;
00589    }
00590 
00591 
00592 <span class="comment">/**** Find next message from requested type, module, instid ****/</span>
00593 
00594 nextmsg:
00595 
00596    <span class="keywordflow">while</span> ( keyget &lt; keyin )
00597    {
00598    <span class="comment">/* make sure you haven't been lapped by tport_putmsg */</span>
00599        <span class="keywordflow">if</span> ( keyget &lt; shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> ) keyget = shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a>;
00600 
00601    <span class="comment">/* load next header; make sure you weren't lapped */</span>
00602        ir = keyget % shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00603        <span class="keywordflow">for</span> ( ih=0 ; ih &lt; <span class="keyword">sizeof</span>(TPORT_HEAD) ; ih++ )
00604        {
00605           <span class="keywordflow">if</span> ( ir &gt;= shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> )  ir -= shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00606           h[ih] = ring[ir++];
00607        }
00608        <span class="keywordflow">if</span> ( keyget &lt; shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> ) <span class="keywordflow">continue</span>;  <span class="comment">/*added 960612:ldd*/</span>
00609 
00610    <span class="comment">/* make sure it starts at beginning of a header */</span>
00611        <span class="keywordflow">if</span> ( hd.<a class="code" href="structTPORT__HEAD.html#m0">start</a> != <a class="code" href="transport_8h.html#a3">FIRST_BYTE</a> )
00612        {
00613           fprintf( stdout,
00614                   <span class="stringliteral">"ERROR: tport_getmsg; keyget not at FIRST_BYTE, Region %ld\n"</span>,
00615                    region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> );
00616           exit( 1 );
00617        }
00618        keyget += <span class="keyword">sizeof</span>(TPORT_HEAD) + hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a>;
00619 
00620    <span class="comment">/* see if this msg matches any requested type */</span>
00621        <span class="keywordflow">for</span> ( j=0 ; j &lt; nget ; j++ )
00622        {
00623           <span class="keywordflow">if</span>((getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a>   == hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   || getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a> == <a class="code" href="transport_8h.html#a0">WILD</a>) &amp;&amp;
00624              (getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>    == hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    || getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>  == <a class="code" href="transport_8h.html#a0">WILD</a>) &amp;&amp;
00625              (getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a> == hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> || getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a> == <a class="code" href="transport_8h.html#a0">WILD</a>) )
00626           {
00627 
00628 <span class="comment">/**** Found a message of requested logo; retrieve it! ****/</span>
00629         <span class="comment">/* complain if retreived msg is too big */</span>
00630              <span class="keywordflow">if</span> ( hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a> &gt; maxsize )
00631              {
00632                *logo   = hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>;
00633                *length = hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a>;
00634                 status = <a class="code" href="transport_8h.html#a12">GET_TOOBIG</a>;
00635                 <span class="keywordflow">goto</span> trackit;    <span class="comment">/*changed 960612:ldd*/</span>
00636              }
00637         <span class="comment">/* copy message by chunks to caller's address */</span>
00638              nwrap = ir + hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a> - shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
00639              <span class="keywordflow">if</span> ( nwrap &lt;= 0 )
00640              {
00641                 memcpy( (<span class="keywordtype">void</span> *) msg, (<span class="keywordtype">void</span> *) &amp;ring[ir], hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a> );
00642              }
00643              <span class="keywordflow">else</span>
00644              {
00645                 nfill = hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a> - nwrap;
00646                 memcpy( (<span class="keywordtype">void</span> *) &amp;msg[0],     (<span class="keywordtype">void</span> *) &amp;ring[ir], nfill );
00647                 memcpy( (<span class="keywordtype">void</span> *) &amp;msg[nfill], (<span class="keywordtype">void</span> *) &amp;ring[0],  nwrap );
00648              }
00649         <span class="comment">/* see if we got run over by tport_putmsg while copying msg */</span>
00650         <span class="comment">/* if we did, go back and try to get a msg cleanly          */</span>
00651              keyold = shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a>;
00652              <span class="keywordflow">if</span> ( keyold &gt;= keyget )
00653              {
00654                 keyget = keyold;
00655                 <span class="keywordflow">goto</span> nextmsg;
00656              }
00657 
00658         <span class="comment">/* set other returned variables */</span>
00659             *logo   = hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>;
00660             *length = hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a>;
00661 
00662 trackit:
00663         <span class="comment">/* find msg logo in tracked list */</span>
00664              <span class="keywordflow">for</span> ( it=0 ; it &lt; nlogo ; it++ )
00665              {
00666                 <span class="keywordflow">if</span> ( region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>    != trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a>      )  <span class="keywordflow">continue</span>;
00667                 <span class="keywordflow">if</span> ( hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   )  <span class="keywordflow">continue</span>;
00668                 <span class="keywordflow">if</span> ( hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    )  <span class="keywordflow">continue</span>;
00669                 <span class="keywordflow">if</span> ( hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> )  <span class="keywordflow">continue</span>;
00670                 <span class="comment">/* activate sequence tracking if 1st msg */</span>
00671                 <span class="keywordflow">if</span> ( !trak[it].<a class="code" href="structMSG__TRACK.html#m4">active</a> )
00672                 {
00673                     trak[it].<a class="code" href="structMSG__TRACK.html#m2">seq</a>    = hd.<a class="code" href="structTPORT__HEAD.html#m3">seq</a>;
00674                     trak[it].<a class="code" href="structMSG__TRACK.html#m4">active</a> = 1;
00675                 }
00676                 <span class="keywordflow">goto</span> sequence;
00677              }
00678         <span class="comment">/* new logo, track it if there's room */</span>
00679              <span class="keywordflow">if</span> ( nlogo == <a class="code" href="transport_8h.html#a2">NTRACK_GET</a> )
00680              {
00681                 fprintf( stdout,
00682                      <span class="stringliteral">"ERROR: tport_getmsg; exceeded NTRACK_GET\n"</span>);
00683                 <span class="keywordflow">if</span>( status != <a class="code" href="transport_8h.html#a12">GET_TOOBIG</a> ) status = <a class="code" href="transport_8h.html#a11">GET_NOTRACK</a>; <span class="comment">/*changed 960612:ldd*/</span>
00684                 <span class="keywordflow">goto</span> wrapup;
00685              }
00686              it = nlogo;
00687              trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a> = region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>;
00688              trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>   = hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>;
00689              trak[it].<a class="code" href="structMSG__TRACK.html#m2">seq</a>    = hd.<a class="code" href="structTPORT__HEAD.html#m3">seq</a>;
00690              trak[it].<a class="code" href="structMSG__TRACK.html#m4">active</a> = 1;      <span class="comment">/*960618:ldd*/</span>
00691              nlogo++;
00692 
00693 sequence:
00694         <span class="comment">/* check if sequence #'s match; update sequence # */</span>
00695              <span class="keywordflow">if</span> ( status == <a class="code" href="transport_8h.html#a12">GET_TOOBIG</a>   )  <span class="keywordflow">goto</span> wrapup; <span class="comment">/*added 960612:ldd*/</span>
00696              <span class="keywordflow">if</span> ( hd.<a class="code" href="structTPORT__HEAD.html#m3">seq</a> != trak[it].<a class="code" href="structMSG__TRACK.html#m2">seq</a> )
00697              {
00698                 status = <a class="code" href="transport_8h.html#a10">GET_MISS</a>;
00699                 trak[it].<a class="code" href="structMSG__TRACK.html#m2">seq</a> = hd.<a class="code" href="structTPORT__HEAD.html#m3">seq</a>;
00700              }
00701              trak[it].<a class="code" href="structMSG__TRACK.html#m2">seq</a>++;
00702 
00703         <span class="comment">/* Ok, we're finished grabbing this one */</span>
00704              <span class="keywordflow">goto</span> wrapup;
00705 
00706           } <span class="comment">/* end if of logo &amp; getlogo match */</span>
00707        }    <span class="comment">/* end for over getlogo */</span>
00708    }        <span class="comment">/* end while over ring */</span>
00709 
00710 <span class="comment">/**** If you got here, there were no messages of requested logo(s) ****/</span>
00711 
00712    status = <a class="code" href="transport_8h.html#a9">GET_NONE</a>;
00713 
00714 <span class="comment">/**** update outpointer (-&gt;msg after retrieved one) for all requested logos ****/</span>
00715 
00716 wrapup:
00717    <span class="keywordflow">for</span> ( it=0 ; it &lt; nlogo ; it++ )  <span class="comment">/* for all message logos we're tracking */</span>
00718    {
00719        <span class="keywordflow">if</span> ( trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a> != region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> ) <span class="keywordflow">continue</span>;
00720        <span class="keywordflow">for</span> ( j=0 ; j &lt; nget ; j++ )  <span class="comment">/* for all requested message logos */</span>
00721        {
00722           <span class="keywordflow">if</span>((getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a>   == trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   || getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a>==<a class="code" href="transport_8h.html#a0">WILD</a>) &amp;&amp;
00723              (getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>    == trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    || getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>==<a class="code" href="transport_8h.html#a0">WILD</a>)  &amp;&amp;
00724              (getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a> == trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> || getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a>==<a class="code" href="transport_8h.html#a0">WILD</a>) )
00725           {
00726              trak[it].<a class="code" href="structMSG__TRACK.html#m3">keyout</a> = keyget;
00727           }
00728        }
00729     }
00730 
00731    <span class="keywordflow">return</span>( status );
00732 
00733 }
00734 
00735 
00736 <span class="comment">/********************* function tport_putflag ************************/</span>
00737 <span class="comment">/*           Puts the kill flag into a shared memory region.         */</span>
00738 <span class="comment">/*********************************************************************/</span>
00739 
<a name="l00740"></a><a class="code" href="transport_8c.html#a21">00740</a> <span class="keywordtype">void</span> <a class="code" href="transport_8c.html#a21">tport_putflag</a>( <a class="code" href="structSHM__INFO.html">SHM_INFO</a> *region,  <span class="comment">/* shared memory info structure     */</span>
00741                     <span class="keywordtype">int</span>       flag )   <span class="comment">/* tells attached processes to exit */</span>
00742 {
00743    <a class="code" href="structSHM__HEAD.html">SHM_HEAD</a>  *shm;
00744 
00745    shm = region-&gt;<a class="code" href="structSHM__INFO.html#m0">addr</a>;
00746    shm-&gt;<a class="code" href="structSHM__HEAD.html#m4">flag</a> = flag;
00747    <span class="keywordflow">return</span>;
00748 }
00749 
00750 
00751 
00752 <span class="comment">/*********************** function tport_getflag **********************/</span>
00753 <span class="comment">/*         Returns the kill flag from a shared memory region.        */</span>
00754 <span class="comment">/*********************************************************************/</span>
00755 
<a name="l00756"></a><a class="code" href="transport_8c.html#a22">00756</a> <span class="keywordtype">int</span> <a class="code" href="transport_8c.html#a22">tport_getflag</a>( <a class="code" href="structSHM__INFO.html">SHM_INFO</a> *region )
00757 
00758 {
00759    <a class="code" href="structSHM__HEAD.html">SHM_HEAD</a>  *shm;
00760 
00761    shm = region-&gt;<a class="code" href="structSHM__INFO.html#m0">addr</a>;
00762    <span class="keywordflow">return</span>( (int)shm-&gt;<a class="code" href="structSHM__HEAD.html#m4">flag</a> );
00763 }
00764 
00765 
00766 <span class="comment">/************************** tport_bufthr ****************************/</span>
00767 <span class="comment">/*     Thread to buffer input from one transport ring to another.   */</span>
00768 <span class="comment">/********************************************************************/</span>
<a name="l00769"></a><a class="code" href="transport_8c.html#a23">00769</a> <span class="keywordtype">void</span> <a class="code" href="transport_8c.html#a23">tport_bufthr</a>( <span class="keywordtype">void</span> *dummy )
00770 {
00771    <span class="keywordtype">char</span>          errnote[150];
00772    <a class="code" href="structMSG__LOGO.html">MSG_LOGO</a>      logo;
00773    <span class="keywordtype">long</span>          msgsize;
00774    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> msgseq;
00775    <span class="keywordtype">int</span>           res1, res2;
00776    <span class="keywordtype">int</span>           gotmsg;
00777    HANDLE myHandle = GetCurrentThread();
00778 
00779 <span class="comment">/* Reset my own thread priority</span>
00780 <span class="comment">   ****************************/</span>
00781    <span class="keywordflow">if</span> ( SetThreadPriority( myHandle, THREAD_PRIORITY_TIME_CRITICAL ) == 0 )
00782    {
00783       printf( <span class="stringliteral">"Error setting buffer thread priority: %d\n"</span>, GetLastError() );
00784       exit( -1 );
00785    }
00786 
00787 <span class="comment">/* Flush all existing messages from the public memory region</span>
00788 <span class="comment">   *********************************************************/</span>
00789    <span class="keywordflow">while</span>( <a class="code" href="transport_8c.html#a25">tport_copyfrom</a>((<a class="code" href="structSHM__INFO.html">SHM_INFO</a> *) PubRegion, (<a class="code" href="structMSG__LOGO.html">MSG_LOGO</a> *) Getlogo, 
00790                           Nget, &amp;logo, &amp;msgsize, (<span class="keywordtype">char</span> *) Message, 
00791                           MaxMsgSize, &amp;msgseq )  !=  <a class="code" href="transport_8h.html#a9">GET_NONE</a>  );
00792 
00793    <span class="keywordflow">while</span> ( 1 )
00794    {
00795       Sleep( 500 );
00796 
00797 <span class="comment">/* If a terminate flag is found, copy it to the private ring.</span>
00798 <span class="comment">   Then, terminate this thread.</span>
00799 <span class="comment">   *********************************************************/</span>
00800       <span class="keywordflow">if</span> ( <a class="code" href="transport_8c.html#a22">tport_getflag</a>( (<a class="code" href="structSHM__INFO.html">SHM_INFO</a> *) PubRegion ) == <a class="code" href="transport_8h.html#a17">TERMINATE</a> )
00801       {
00802          <a class="code" href="transport_8c.html#a21">tport_putflag</a>( (<a class="code" href="structSHM__INFO.html">SHM_INFO</a> *) BufRegion, TERMINATE );
00803          _endthread();
00804       }
00805 
00806 <span class="comment">/* Try to copy a message from the public memory region</span>
00807 <span class="comment">   ***************************************************/</span>
00808       <span class="keywordflow">do</span>
00809       {
00810           res1 = <a class="code" href="transport_8c.html#a25">tport_copyfrom</a>((<a class="code" href="structSHM__INFO.html">SHM_INFO</a> *) PubRegion, (<a class="code" href="structMSG__LOGO.html">MSG_LOGO</a> *) Getlogo,
00811                                 Nget, &amp;logo, &amp;msgsize, (<span class="keywordtype">char</span> *) Message,
00812                                 MaxMsgSize, &amp;msgseq );
00813           gotmsg = 1;
00814 
00815 <span class="comment">/* Handle return values</span>
00816 <span class="comment">   ********************/</span>
00817           <span class="keywordflow">switch</span> ( res1 )
00818           {
00819           <span class="keywordflow">case</span> <a class="code" href="transport_8h.html#a13">GET_MISS_LAPPED</a>:
00820                 sprintf( errnote,
00821                         <span class="stringliteral">"tport_bufthr: Missed msg(s)  c%d m%d t%d  Overwritten, region:%ld."</span>,
00822                          (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m2">instid</a>, (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m1">mod</a>, (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m0">type</a>,
00823                          <a class="code" href="transport_8c.html#a4">PubRegion</a>-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> );
00824                 <a class="code" href="transport_8c.html#a14">tport_buferror</a>( ERR_LAPPED, errnote );
00825                 <span class="keywordflow">break</span>;
00826           <span class="keywordflow">case</span> <a class="code" href="transport_8h.html#a14">GET_MISS_SEQGAP</a>:
00827                 sprintf( errnote,
00828                         <span class="stringliteral">"tport_bufthr: Missed msg(s)  c%d m%d t%d  Sequence gap, region:%ld."</span>,
00829                          (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m2">instid</a>, (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m1">mod</a>, (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m0">type</a>,
00830                          <a class="code" href="transport_8c.html#a4">PubRegion</a>-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> );
00831                 <a class="code" href="transport_8c.html#a14">tport_buferror</a>( ERR_SEQGAP, errnote );
00832                 <span class="keywordflow">break</span>;
00833           <span class="keywordflow">case</span> <a class="code" href="transport_8h.html#a11">GET_NOTRACK</a>:
00834                 sprintf( errnote,
00835                         <span class="stringliteral">"tport_bufthr: Logo c%d m%d t%d not tracked; NTRACK_GET exceeded."</span>,
00836                         (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m2">instid</a>, (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m1">mod</a>, (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m0">type</a> );
00837                 <a class="code" href="transport_8c.html#a14">tport_buferror</a>( ERR_UNTRACKED, errnote );
00838           <span class="keywordflow">case</span> <a class="code" href="transport_8h.html#a8">GET_OK</a>:
00839                 <span class="keywordflow">break</span>;
00840           <span class="keywordflow">case</span> <a class="code" href="transport_8h.html#a12">GET_TOOBIG</a>:
00841                 sprintf( errnote,
00842                         <span class="stringliteral">"tport_bufthr: msg[%ld] c%d m%d t%d seq%d too big; skipped in region:%ld."</span>,
00843                          msgsize, (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m2">instid</a>, (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m1">mod</a>,
00844                          (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m0">type</a>, (<span class="keywordtype">int</span>) msgseq, <a class="code" href="transport_8c.html#a4">PubRegion</a>-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> );
00845                 <a class="code" href="transport_8c.html#a14">tport_buferror</a>( ERR_OVERFLOW, errnote );
00846           <span class="keywordflow">case</span> <a class="code" href="transport_8h.html#a9">GET_NONE</a>:
00847                 gotmsg = 0;
00848                 <span class="keywordflow">break</span>;
00849           }
00850 
00851 <span class="comment">/* If you did get a message, copy it to private ring</span>
00852 <span class="comment">   *************************************************/</span>
00853           <span class="keywordflow">if</span> ( gotmsg )
00854           {
00855               res2 = <a class="code" href="transport_8c.html#a26">tport_copyto</a>( (<a class="code" href="structSHM__INFO.html">SHM_INFO</a> *) BufRegion, &amp;logo,
00856                                    msgsize, (<span class="keywordtype">char</span> *) Message, msgseq );
00857               <span class="keywordflow">switch</span> (res2)
00858               {
00859               <span class="keywordflow">case</span> <a class="code" href="transport_8h.html#a7">PUT_TOOBIG</a>:
00860                  sprintf( errnote,
00861                      <span class="stringliteral">"tport_bufthr: msg[%ld] (c%d m%d t%d) too big for Region:%ld."</span>,
00862                       msgsize, (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m2">instid</a>, (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m1">mod</a>, (<span class="keywordtype">int</span>) logo.<a class="code" href="structMSG__LOGO.html#m0">type</a>,
00863                       <a class="code" href="transport_8c.html#a5">BufRegion</a>-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> );
00864                  <a class="code" href="transport_8c.html#a14">tport_buferror</a>( ERR_OVERFLOW, errnote );
00865               <span class="keywordflow">case</span> <a class="code" href="transport_8h.html#a5">PUT_OK</a>:
00866                  <span class="keywordflow">break</span>;
00867               }
00868           }
00869       } <span class="keywordflow">while</span> ( res1 != <a class="code" href="transport_8h.html#a9">GET_NONE</a> );
00870    }
00871 }
00872 
00873 
00874 <span class="comment">/************************** tport_buffer ****************************/</span>
00875 <span class="comment">/*       Function to initialize the input buffering thread          */</span>
00876 <span class="comment">/********************************************************************/</span>
<a name="l00877"></a><a class="code" href="transport_8c.html#a24">00877</a> <span class="keywordtype">int</span> <a class="code" href="transport_8c.html#a24">tport_buffer</a>( <a class="code" href="structSHM__INFO.html">SHM_INFO</a>  *region1,      <span class="comment">/* transport ring             */</span>
00878                   <a class="code" href="structSHM__INFO.html">SHM_INFO</a>  *region2,      <span class="comment">/* private ring               */</span>
00879                   <a class="code" href="structMSG__LOGO.html">MSG_LOGO</a>  *getlogo,      <span class="comment">/* array of logos to copy     */</span>
00880                   <span class="keywordtype">short</span>      nget,         <span class="comment">/* number of logos in getlogo */</span>
00881                   <span class="keywordtype">unsigned</span>   maxMsgSize,   <span class="comment">/* size of message buffer     */</span>
00882                   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> module,    <span class="comment">/* module id of main thread   */</span>
00883                   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> instid )   <span class="comment">/* instid id of main thread   */</span>
00884 {
00885    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> thread_id;            <span class="comment">/* Thread id of the buffer thread */</span>
00886 
00887 <span class="comment">/* Allocate message buffer</span>
00888 <span class="comment">   ***********************/</span>
00889    <a class="code" href="transport_8c.html#a9">Message</a> = (<span class="keywordtype">char</span> *) malloc( maxMsgSize );
00890    <span class="keywordflow">if</span> ( <a class="code" href="transport_8c.html#a9">Message</a> == NULL )
00891    {
00892       fprintf( stdout, <span class="stringliteral">"tport_buffer: Error allocating message buffer\n"</span> );
00893       <span class="keywordflow">return</span> -1;
00894    }
00895 
00896 <span class="comment">/* Copy function arguments to global variables</span>
00897 <span class="comment">   *******************************************/</span>
00898    <a class="code" href="transport_8c.html#a4">PubRegion</a>   = region1;
00899    <a class="code" href="transport_8c.html#a5">BufRegion</a>   = region2;
00900    <a class="code" href="transport_8c.html#a6">Getlogo</a>     = getlogo;
00901    <a class="code" href="transport_8c.html#a7">Nget</a>        = nget;
00902    <a class="code" href="transport_8c.html#a8">MaxMsgSize</a>  = maxMsgSize;
00903    <a class="code" href="transport_8c.html#a10">MyModuleId</a>  = module;
00904    <a class="code" href="transport_8c.html#a11">MyInstid</a>    = instid;
00905 
00906 <span class="comment">/* Lookup message type for error messages</span>
00907 <span class="comment">   **************************************/</span>
00908    <span class="keywordflow">if</span> ( <a class="code" href="getutil_8c.html#a29">GetType</a>( <span class="stringliteral">"TYPE_ERROR"</span>, &amp;TypeError ) != 0 )
00909    {
00910       fprintf( stderr,
00911               <span class="stringliteral">"tport_buffer: Invalid message type &lt;TYPE_ERROR&gt;\n"</span> );
00912       <span class="keywordflow">return</span> -1;
00913    }
00914 
00915 <span class="comment">/* Start the input buffer thread</span>
00916 <span class="comment">   *****************************/</span>
00917    thread_id = _beginthread( tport_bufthr, 0, NULL );
00918 
00919    <span class="keywordflow">if</span> ( thread_id == -1 )                <span class="comment">/* Couldn't create thread */</span>
00920    {
00921       fprintf( stderr, <span class="stringliteral">"tport_buffer: Can't start the buffer thread."</span> );
00922       <span class="keywordflow">return</span> -1;
00923    }
00924    <span class="keywordflow">return</span> 0;
00925 }
00926 
00927 
00928 <span class="comment">/********************** function tport_copyfrom *********************/</span>
00929 <span class="comment">/*      get a message out of public shared memory; save the         */</span>
00930 <span class="comment">/*     sequence number from the transport layer, with the intent    */</span>
00931 <span class="comment">/*       of copying it to a private (buffering) memory ring         */</span>
00932 <span class="comment">/********************************************************************/</span>
00933 
<a name="l00934"></a><a class="code" href="transport_8c.html#a25">00934</a> <span class="keywordtype">int</span> <a class="code" href="transport_8c.html#a25">tport_copyfrom</a>( <a class="code" href="structSHM__INFO.html">SHM_INFO</a>  *region,   <span class="comment">/* info structure for memory region */</span>
00935                     <a class="code" href="structMSG__LOGO.html">MSG_LOGO</a>  *getlogo,  <span class="comment">/* requested logo(s)                */</span>
00936                     <span class="keywordtype">short</span>      nget,     <span class="comment">/* number of logos in getlogo       */</span>
00937                     <a class="code" href="structMSG__LOGO.html">MSG_LOGO</a>  *logo,     <span class="comment">/* logo of retrieved message        */</span>
00938                     <span class="keywordtype">long</span>      *length,   <span class="comment">/* size of retrieved message        */</span>
00939                     <span class="keywordtype">char</span>      *msg,      <span class="comment">/* retrieved message                */</span>
00940                     <span class="keywordtype">long</span>       maxsize,  <span class="comment">/* max length for retrieved message */</span>
00941                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *seq ) <span class="comment">/* TPORT_HEAD seq# of retrieved msg */</span>
00942 {
00943    <span class="keyword">static</span> <a class="code" href="structMSG__TRACK.html">MSG_TRACK</a>  trak[<a class="code" href="transport_8h.html#a2">NTRACK_GET</a>]; <span class="comment">/* sequence #, outpointer keeper     */</span>
00944    <span class="keyword">static</span> <span class="keywordtype">int</span>        nlogo;            <span class="comment">/* # modid,type,instid combos so far */</span>
00945    <span class="keywordtype">int</span>               it;               <span class="comment">/* index into trak                   */</span>
00946    <a class="code" href="structSHM__HEAD.html">SHM_HEAD</a>         *shm;              <span class="comment">/* pointer to start of memory region */</span>
00947    <span class="keywordtype">char</span>             *ring;             <span class="comment">/* pointer to ring part of memory    */</span>
00948    <a class="code" href="structTPORT__HEAD.html">TPORT_HEAD</a>       *tmphd;            <span class="comment">/* temp pointer into shared memory   */</span>
00949    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     ir;               <span class="comment">/* index into the ring               */</span>
00950    <span class="keywordtype">long</span>              nfill;            <span class="comment">/* bytes from ir to ring's last-byte */</span>
00951    <span class="keywordtype">long</span>              nwrap;            <span class="comment">/* bytes to grab from front of ring  */</span>
00952    <a class="code" href="structTPORT__HEAD.html">TPORT_HEAD</a>        hd;               <span class="comment">/* transport header from memory      */</span>
00953    <span class="keywordtype">char</span>             *h;                <span class="comment">/* pointer to transport layer header */</span>
00954    <span class="keywordtype">int</span>               ih;               <span class="comment">/* index into the transport header   */</span>
00955    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     keyin;            <span class="comment">/* in-pointer to shared memory       */</span>
00956    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     keyold;           <span class="comment">/* oldest complete message in memory */</span>
00957    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     keyget;           <span class="comment">/* pointer at which to start search  */</span>
00958    <span class="keywordtype">int</span>               status = <a class="code" href="transport_8h.html#a8">GET_OK</a>;  <span class="comment">/* how did retrieval go?             */</span>
00959    <span class="keywordtype">int</span>               lapped = 0;       <span class="comment">/* = 1 if memory ring has been over- */</span>
00960                                        <span class="comment">/* written since last tport_copyfrom */</span>
00961    <span class="keywordtype">int</span>               trakked;          <span class="comment">/* flag for trakking list entries    */</span>
00962    <span class="keywordtype">int</span>               i,j;
00963 
00964 <span class="comment">/**** Get the pointers set up ****/</span>
00965 
00966    shm  = region-&gt;<a class="code" href="structSHM__INFO.html#m0">addr</a>;
00967    ring = (<span class="keywordtype">char</span> *) shm + <span class="keyword">sizeof</span>(SHM_HEAD);
00968    h    = (<span class="keywordtype">char</span> *) (&amp;hd);
00969 
00970 <span class="comment">/**** First time around, initialize sequence counters, outpointers ****/</span>
00971 
00972    <span class="keywordflow">if</span> (Copyfrom_Init)
00973    {
00974        nlogo = 0;
00975 
00976        <span class="keywordflow">for</span>( i=0 ; i &lt; <a class="code" href="transport_8h.html#a2">NTRACK_GET</a> ; i++ )
00977        {
00978           trak[i].<a class="code" href="structMSG__TRACK.html#m0">memkey</a>      = 0;
00979           trak[i].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   = 0;
00980           trak[i].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    = 0;
00981           trak[i].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> = 0;
00982           trak[i].<a class="code" href="structMSG__TRACK.html#m2">seq</a>         = 0;
00983           trak[i].<a class="code" href="structMSG__TRACK.html#m3">keyout</a>      = 0;
00984           trak[i].<a class="code" href="structMSG__TRACK.html#m4">active</a>      = 0; <span class="comment">/*960618:ldd*/</span>
00985        }
00986        <a class="code" href="transport_8c.html#a2">Copyfrom_Init</a> = 0;
00987    }
00988 
00989 <span class="comment">/**** make sure all requested logos are entered in tracking list ****/</span>
00990 
00991    <span class="keywordflow">for</span> ( j=0 ; j &lt; nget ; j++ )  <span class="comment">/* for all requested message logos */</span>
00992    {
00993        trakked = 0;  <span class="comment">/* assume it's not being trakked */</span>
00994        <span class="keywordflow">for</span>( it=0 ; it &lt; nlogo ; it++ )  <span class="comment">/* for all logos we're tracking */</span>
00995        {
00996           <span class="keywordflow">if</span>( region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>       != trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a>      ) <span class="keywordflow">continue</span>;
00997           <span class="keywordflow">if</span>( getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a>   != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   ) <span class="keywordflow">continue</span>;
00998           <span class="keywordflow">if</span>( getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>    != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    ) <span class="keywordflow">continue</span>;
00999           <span class="keywordflow">if</span>( getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a> != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> ) <span class="keywordflow">continue</span>;
01000           trakked = 1;  <span class="comment">/* found it in the trakking list! */</span>
01001           <span class="keywordflow">break</span>;
01002        }
01003        <span class="keywordflow">if</span>( trakked ) <span class="keywordflow">continue</span>;
01004     <span class="comment">/* Make an entry in trak for this logo; if there's room */</span>
01005        <span class="keywordflow">if</span> ( nlogo &lt; <a class="code" href="transport_8h.html#a2">NTRACK_GET</a> )
01006        {
01007           it = nlogo;
01008           trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a> = region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>;
01009           trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>   = getlogo[j];
01010           nlogo++;
01011        }
01012    }
01013 
01014 <span class="comment">/**** find latest starting index to look for any of the requested logos ****/</span>
01015 
01016 findkey:
01017 
01018    keyget = 0;
01019 
01020    <span class="keywordflow">for</span> ( it=0 ; it &lt; nlogo ; it++ )  <span class="comment">/* for all message logos we're tracking */</span>
01021    {
01022        <span class="keywordflow">if</span> ( trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a> != region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> ) <span class="keywordflow">continue</span>;
01023        <span class="keywordflow">for</span> ( j=0 ; j &lt; nget ; j++ )  <span class="comment">/* for all requested message logos */</span>
01024        {
01025           <span class="keywordflow">if</span>((getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a>   == trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   || getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a>==<a class="code" href="transport_8h.html#a0">WILD</a>) &amp;&amp;
01026              (getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>    == trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    || getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>==<a class="code" href="transport_8h.html#a0">WILD</a>)  &amp;&amp;
01027              (getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a> == trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> || getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a>==<a class="code" href="transport_8h.html#a0">WILD</a>) )
01028           {
01029              <span class="keywordflow">if</span> ( trak[it].<a class="code" href="structMSG__TRACK.html#m3">keyout</a> &gt; keyget )  keyget = trak[it].<a class="code" href="structMSG__TRACK.html#m3">keyout</a>;
01030           }
01031        }
01032    }
01033 
01034 <span class="comment">/**** make sure you haven't been lapped by tport_copyto or tport_putmsg ****/</span>
01035    <span class="keywordflow">if</span> ( keyget &lt; shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> ) {
01036       keyget = shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a>;
01037       lapped = 1;
01038    }
01039 
01040 <span class="comment">/**** See if keyin and keyold were wrapped and reset by tport_putmsg; ****/</span>
01041 <span class="comment">/****       If so, reset trak[xx].keyout and go back to findkey       ****/</span>
01042 
01043    keyin = shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a>;
01044    <span class="keywordflow">if</span> ( keyget &gt; keyin )
01045    {
01046       keyold = shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a>;
01047       <span class="keywordflow">for</span> ( it=0 ; it &lt; nlogo ; it++ )
01048       {
01049          <span class="keywordflow">if</span>( trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a> == region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> )
01050          {
01051           <span class="comment">/* reset keyout */</span>
01052 <span class="comment">/*DEBUG*/</span>    <span class="comment">/*printf("tport_copyfrom: Pre-reset:  keyout=%10u    keyold=%10u  keyin=%10u\n",</span>
01053 <span class="comment">                     trak[it].keyout, keyold, keyin );*/</span>
01054              trak[it].<a class="code" href="structMSG__TRACK.html#m3">keyout</a> = trak[it].<a class="code" href="structMSG__TRACK.html#m3">keyout</a> % shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01055 <span class="comment">/*DEBUG*/</span>    <span class="comment">/*printf("tport_copyfrom:  Intermed:  keyout=%10u    keyold=%10u  keyin=%10u\n",</span>
01056 <span class="comment">                     trak[it].keyout, keyold, keyin );*/</span>
01057 
01058           <span class="comment">/* make sure new keyout points to keyin or to a msg's first-byte; */</span>
01059           <span class="comment">/* if not, we've been lapped, so set keyout to keyold             */</span>
01060              ir    = trak[it].<a class="code" href="structMSG__TRACK.html#m3">keyout</a>;
01061              tmphd = (<a class="code" href="structTPORT__HEAD.html">TPORT_HEAD</a> *) &amp;ring[ir];
01062              <span class="keywordflow">if</span> ( trak[it].keyout == keyin   ||
01063                   (keyin-trak[it].keyout)%shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> == 0 )
01064              {
01065 <span class="comment">/*DEBUG*/</span>       <span class="comment">/*printf("tport_copyfrom:  Intermed:  keyout=%10u  same as keyin\n",</span>
01066 <span class="comment">                        trak[it].keyout );*/</span>
01067                 trak[it].keyout = keyin;
01068              }
01069              <span class="keywordflow">else</span> <span class="keywordflow">if</span>( tmphd-&gt;<a class="code" href="structTPORT__HEAD.html#m0">start</a> != <a class="code" href="transport_8h.html#a3">FIRST_BYTE</a> )
01070              {
01071 <span class="comment">/*DEBUG*/</span>       <span class="comment">/*printf("tport_copyfrom:  Intermed:  keyout=%10u  does not point to FIRST_BYTE\n",</span>
01072 <span class="comment">                        trak[it].keyout );*/</span>
01073                 trak[it].keyout = keyold;
01074                 lapped = 1;
01075              }
01076 
01077           <span class="comment">/* else, make sure keyout's value is between keyold and keyin */</span>
01078              <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( trak[it].keyout &lt; keyold )
01079              {
01080                 <span class="keywordflow">do</span> {
01081                     trak[it].keyout += shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01082                 } <span class="keywordflow">while</span> ( trak[it].keyout &lt; keyold );
01083              }
01084 <span class="comment">/*DEBUG*/</span>    <span class="comment">/*printf("tport_copyfrom:     Reset:  keyout=%10u    keyold=%10u  keyin=%10u\n",</span>
01085 <span class="comment">                     trak[it].keyout, keyold, keyin );*/</span>
01086          }
01087       }
01088     <span class="comment">/*fprintf( stdout,</span>
01089 <span class="comment">          "NOTICE: tport_copyfrom; keyin wrapped, keyout(s) reset; Region %ld\n",</span>
01090 <span class="comment">           region-&gt;key );*/</span>
01091 
01092       <span class="keywordflow">goto</span> findkey;
01093    }
01094 
01095 
01096 <span class="comment">/**** Find next message from requested type, module, instid ****/</span>
01097 
01098 nextmsg:
01099 
01100    <span class="keywordflow">while</span> ( keyget &lt; keyin )
01101    {
01102    <span class="comment">/* make sure you haven't been lapped by tport_copyto or tport_putmsg */</span>
01103        <span class="keywordflow">if</span> ( keyget &lt; shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> ) {
01104           keyget = shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a>;
01105           lapped = 1;
01106        }
01107 
01108    <span class="comment">/* load next header; make sure you weren't lapped */</span>
01109        ir = keyget % shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01110        <span class="keywordflow">for</span> ( ih=0 ; ih &lt; <span class="keyword">sizeof</span>(TPORT_HEAD) ; ih++ )
01111        {
01112           <span class="keywordflow">if</span> ( ir &gt;= shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> )  ir -= shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01113           h[ih] = ring[ir++];
01114        }
01115        <span class="keywordflow">if</span> ( keyget &lt; shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> ) <span class="keywordflow">continue</span>;  <span class="comment">/*added 960612:ldd*/</span>
01116 
01117    <span class="comment">/* make sure it starts at beginning of a header */</span>
01118        <span class="keywordflow">if</span> ( hd.<a class="code" href="structTPORT__HEAD.html#m0">start</a> != <a class="code" href="transport_8h.html#a3">FIRST_BYTE</a> )
01119        {
01120           fprintf( stdout,
01121                   <span class="stringliteral">"ERROR: tport_copyfrom; keyget not at FIRST_BYTE, Region %ld\n"</span>,
01122                    region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> );
01123           exit( 1 );
01124        }
01125        keyget += <span class="keyword">sizeof</span>(TPORT_HEAD) + hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a>;
01126 
01127    <span class="comment">/* see if this msg matches any requested type */</span>
01128        <span class="keywordflow">for</span> ( j=0 ; j &lt; nget ; j++ )
01129        {
01130           <span class="keywordflow">if</span>((getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a>   == hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   || getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a> == <a class="code" href="transport_8h.html#a0">WILD</a>) &amp;&amp;
01131              (getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>    == hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    || getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>  == <a class="code" href="transport_8h.html#a0">WILD</a>) &amp;&amp;
01132              (getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a> == hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> || getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a> == <a class="code" href="transport_8h.html#a0">WILD</a>) )
01133           {
01134 
01135 <span class="comment">/**** Found a message of requested logo; retrieve it! ****/</span>
01136         <span class="comment">/* complain if retreived msg is too big */</span>
01137              <span class="keywordflow">if</span> ( hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a> &gt; maxsize )
01138              {
01139                *logo   = hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>;
01140                *length = hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a>;
01141                *seq    = hd.<a class="code" href="structTPORT__HEAD.html#m3">seq</a>;
01142                 status = <a class="code" href="transport_8h.html#a12">GET_TOOBIG</a>;
01143                 <span class="keywordflow">goto</span> trackit;    <span class="comment">/*changed 960612:ldd*/</span>
01144              }
01145         <span class="comment">/* copy message by chunks to caller's address */</span>
01146              nwrap = ir + hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a> - shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01147              <span class="keywordflow">if</span> ( nwrap &lt;= 0 )
01148              {
01149                 memcpy( (<span class="keywordtype">void</span> *) msg, (<span class="keywordtype">void</span> *) &amp;ring[ir], hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a> );
01150              }
01151              <span class="keywordflow">else</span>
01152              {
01153                 nfill = hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a> - nwrap;
01154                 memcpy( (<span class="keywordtype">void</span> *) &amp;msg[0],     (<span class="keywordtype">void</span> *) &amp;ring[ir], nfill );
01155                 memcpy( (<span class="keywordtype">void</span> *) &amp;msg[nfill], (<span class="keywordtype">void</span> *) &amp;ring[0],  nwrap );
01156              }
01157         <span class="comment">/* see if we got lapped by tport_copyto or tport_putmsg while copying msg */</span>
01158         <span class="comment">/* if we did, go back and try to get a msg cleanly          */</span>
01159              keyold = shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a>;
01160              <span class="keywordflow">if</span> ( keyold &gt;= keyget )
01161              {
01162                 keyget = keyold;
01163                 lapped = 1;
01164                 <span class="keywordflow">goto</span> nextmsg;
01165              }
01166 
01167         <span class="comment">/* set other returned variables */</span>
01168             *logo   = hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>;
01169             *length = hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a>;
01170             *seq    = hd.<a class="code" href="structTPORT__HEAD.html#m3">seq</a>;
01171 
01172 trackit:
01173         <span class="comment">/* find logo in tracked list */</span>
01174              <span class="keywordflow">for</span> ( it=0 ; it &lt; nlogo ; it++ )
01175              {
01176                 <span class="keywordflow">if</span> ( region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>    != trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a>      )  <span class="keywordflow">continue</span>;
01177                 <span class="keywordflow">if</span> ( hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   )  <span class="keywordflow">continue</span>;
01178                 <span class="keywordflow">if</span> ( hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    )  <span class="keywordflow">continue</span>;
01179                 <span class="keywordflow">if</span> ( hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> != trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> )  <span class="keywordflow">continue</span>;
01180                 <span class="comment">/* activate sequence tracking if 1st msg */</span>
01181                 <span class="keywordflow">if</span> ( !trak[it].<a class="code" href="structMSG__TRACK.html#m4">active</a> )
01182                 {
01183                     trak[it].<a class="code" href="structMSG__TRACK.html#m2">seq</a>    = hd.<a class="code" href="structTPORT__HEAD.html#m3">seq</a>;
01184                     trak[it].<a class="code" href="structMSG__TRACK.html#m4">active</a> = 1;
01185                 }
01186                 <span class="keywordflow">goto</span> sequence;
01187              }
01188         <span class="comment">/* new logo, track it if there's room */</span>
01189              <span class="keywordflow">if</span> ( nlogo == <a class="code" href="transport_8h.html#a2">NTRACK_GET</a> )
01190              {
01191                 fprintf( stdout,
01192                      <span class="stringliteral">"ERROR: tport_copyfrom; exceeded NTRACK_GET\n"</span>);
01193                 <span class="keywordflow">if</span>( status != <a class="code" href="transport_8h.html#a12">GET_TOOBIG</a> ) status = <a class="code" href="transport_8h.html#a11">GET_NOTRACK</a>; <span class="comment">/*changed 960612:ldd*/</span>
01194                 <span class="keywordflow">goto</span> wrapup;
01195              }
01196              it = nlogo;
01197              trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a> = region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>;
01198              trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>   = hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>;
01199              trak[it].<a class="code" href="structMSG__TRACK.html#m2">seq</a>    = hd.<a class="code" href="structTPORT__HEAD.html#m3">seq</a>;
01200              trak[it].<a class="code" href="structMSG__TRACK.html#m4">active</a> = 1;      <span class="comment">/*960618:ldd*/</span>
01201              nlogo++;
01202 
01203 sequence:
01204         <span class="comment">/* check if sequence #'s match; update sequence # */</span>
01205              <span class="keywordflow">if</span> ( status == <a class="code" href="transport_8h.html#a12">GET_TOOBIG</a>   )  <span class="keywordflow">goto</span> wrapup; <span class="comment">/*added 960612:ldd*/</span>
01206              <span class="keywordflow">if</span> ( hd.<a class="code" href="structTPORT__HEAD.html#m3">seq</a> != trak[it].<a class="code" href="structMSG__TRACK.html#m2">seq</a> )
01207              {
01208                 <span class="keywordflow">if</span> (lapped)  status = <a class="code" href="transport_8h.html#a13">GET_MISS_LAPPED</a>;
01209                 <span class="keywordflow">else</span>         status = <a class="code" href="transport_8h.html#a14">GET_MISS_SEQGAP</a>;
01210                 trak[it].<a class="code" href="structMSG__TRACK.html#m2">seq</a> = hd.<a class="code" href="structTPORT__HEAD.html#m3">seq</a>;
01211              }
01212              trak[it].<a class="code" href="structMSG__TRACK.html#m2">seq</a>++;
01213 
01214         <span class="comment">/* Ok, we're finished grabbing this one */</span>
01215              <span class="keywordflow">goto</span> wrapup;
01216 
01217           } <span class="comment">/* end if of logo &amp; getlogo match */</span>
01218        }    <span class="comment">/* end for over getlogo */</span>
01219    }        <span class="comment">/* end while over ring */</span>
01220 
01221 <span class="comment">/**** If you got here, there were no messages of requested logo(s) ****/</span>
01222 
01223    status = <a class="code" href="transport_8h.html#a9">GET_NONE</a>;
01224 
01225 <span class="comment">/**** update outpointer (-&gt;msg after retrieved one) for all requested logos ****/</span>
01226 
01227 wrapup:
01228    <span class="keywordflow">for</span> ( it=0 ; it &lt; nlogo ; it++ )  <span class="comment">/* for all message logos we're tracking */</span>
01229    {
01230        <span class="keywordflow">if</span> ( trak[it].<a class="code" href="structMSG__TRACK.html#m0">memkey</a> != region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> ) <span class="keywordflow">continue</span>;
01231        <span class="keywordflow">for</span> ( j=0 ; j &lt; nget ; j++ )  <span class="comment">/* for all requested message logos */</span>
01232        {
01233           <span class="keywordflow">if</span>((getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a>   == trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m0">type</a>   || getlogo[j].<a class="code" href="structMSG__LOGO.html#m0">type</a>==<a class="code" href="transport_8h.html#a0">WILD</a>) &amp;&amp;
01234              (getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>    == trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    || getlogo[j].<a class="code" href="structMSG__LOGO.html#m1">mod</a>==<a class="code" href="transport_8h.html#a0">WILD</a>)  &amp;&amp;
01235              (getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a> == trak[it].<a class="code" href="structMSG__TRACK.html#m1">logo</a>.<a class="code" href="structMSG__LOGO.html#m2">instid</a> || getlogo[j].<a class="code" href="structMSG__LOGO.html#m2">instid</a>==<a class="code" href="transport_8h.html#a0">WILD</a>) )
01236           {
01237              trak[it].<a class="code" href="structMSG__TRACK.html#m3">keyout</a> = keyget;
01238           }
01239        }
01240     }
01241 
01242    <span class="keywordflow">return</span>( status );
01243 
01244 }
01245 
01246 
01247 <span class="comment">/*********************** function tport_copyto ***********************/</span>
01248 <span class="comment">/*           Puts a message into a shared memory region.             */</span>
01249 <span class="comment">/*    Preserves the sequence number (passed as argument) as the      */</span>
01250 <span class="comment">/*                transport layer sequence number                    */</span>
01251 <span class="comment">/*********************************************************************/</span>
01252 
<a name="l01253"></a><a class="code" href="transport_8c.html#a26">01253</a> <span class="keywordtype">int</span> <a class="code" href="transport_8c.html#a26">tport_copyto</a>( <a class="code" href="structSHM__INFO.html">SHM_INFO</a>    *region,  <span class="comment">/* info structure for memory region     */</span>
01254                   <a class="code" href="structMSG__LOGO.html">MSG_LOGO</a>    *putlogo, <span class="comment">/* type, module, instid of incoming msg */</span>
01255                   <span class="keywordtype">long</span>         length,  <span class="comment">/* size of incoming message             */</span>
01256                   <span class="keywordtype">char</span>        *msg,     <span class="comment">/* pointer to incoming message          */</span>
01257                   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> seq )   <span class="comment">/* preserve as sequence# in TPORT_HEAD  */</span>
01258 {
01259    <a class="code" href="structSHM__HEAD.html">SHM_HEAD</a>         *shm;              <span class="comment">/* pointer to start of memory region   */</span>
01260    <span class="keywordtype">char</span>             *ring;             <span class="comment">/* pointer to ring part of memory      */</span>
01261    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     ir;               <span class="comment">/* index into memory ring              */</span>
01262    <span class="keywordtype">long</span>              nfill;            <span class="comment">/* # bytes from ir to ring's last-byte */</span>
01263    <span class="keywordtype">long</span>              nwrap;            <span class="comment">/* # bytes to wrap to front of ring    */</span>
01264    <a class="code" href="structTPORT__HEAD.html">TPORT_HEAD</a>        hd;               <span class="comment">/* transport layer header to put       */</span>
01265    <span class="keywordtype">char</span>             *h;                <span class="comment">/* pointer to transport layer header   */</span>
01266    <a class="code" href="structTPORT__HEAD.html">TPORT_HEAD</a>        old;              <span class="comment">/* transport header of oldest msg      */</span>
01267    <span class="keywordtype">char</span>             *o;                <span class="comment">/* pointer to oldest transport header  */</span>
01268    <span class="keywordtype">int</span> j;
01269    <span class="keywordtype">int</span> retval = <a class="code" href="transport_8h.html#a5">PUT_OK</a>;                <span class="comment">/* return value for this function      */</span>
01270 
01271 <span class="comment">/**** First time around, initialize semaphore controls ****/</span>
01272 
01273    <span class="keywordflow">if</span> (Copyto_Init)
01274    {
01275        <a class="code" href="transport_8c.html#a3">Copyto_Init</a>  = 0;
01276    }
01277 
01278 <span class="comment">/**** Set up pointers for shared memory, etc. ****/</span>
01279 
01280    shm  = region-&gt;<a class="code" href="structSHM__INFO.html#m0">addr</a>;
01281    ring = (<span class="keywordtype">char</span> *) shm + <span class="keyword">sizeof</span>(SHM_HEAD);
01282    h    = (<span class="keywordtype">char</span> *) (&amp;hd);
01283    o    = (<span class="keywordtype">char</span> *) (&amp;old);
01284 
01285 <span class="comment">/**** First, see if the incoming message will fit in the memory region ****/</span>
01286 
01287    <span class="keywordflow">if</span> ( length + <span class="keyword">sizeof</span>(TPORT_HEAD) &gt; shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> )
01288    {
01289       fprintf( stdout,
01290               <span class="stringliteral">"ERROR: tport_copyto; message too large (%ld) for Region %ld\n"</span>,
01291                length, region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a>);
01292       <span class="keywordflow">return</span>( PUT_TOOBIG );
01293    }
01294 
01295 <span class="comment">/**** Change semaphore to let others know you're using memory ****/</span>
01296 
01297    WaitForSingleObject( region-&gt;hMutex, INFINITE );
01298 
01299 <span class="comment">/**** Store everything you need in the transport header ****/</span>
01300 
01301    hd.<a class="code" href="structTPORT__HEAD.html#m0">start</a> = <a class="code" href="transport_8h.html#a3">FIRST_BYTE</a>;
01302    hd.<a class="code" href="structTPORT__HEAD.html#m1">size</a>  = length;
01303    hd.<a class="code" href="structTPORT__HEAD.html#m2">logo</a>  = *putlogo;
01304    hd.<a class="code" href="structTPORT__HEAD.html#m3">seq</a>   = seq;
01305 
01306 <span class="comment">/**** First see if keyin will wrap; if so, reset both keyin and keyold ****/</span>
01307 
01308    <span class="keywordflow">if</span> ( shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a> + <span class="keyword">sizeof</span>(TPORT_HEAD) + length  &lt;  shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> )
01309    {
01310        shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a>  = shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a>  % shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01311        shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> = shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> % shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01312        <span class="keywordflow">if</span> ( shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a> &lt;= shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> ) shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a> += shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01313      <span class="comment">/*fprintf( stdout,</span>
01314 <span class="comment">               "NOTICE: tport_copyto; keyin wrapped &amp; reset; Region %ld\n",</span>
01315 <span class="comment">                region-&gt;key );*/</span>
01316    }
01317 
01318 <span class="comment">/**** Then see if there's enough room for new message in shared memory ****/</span>
01319 <span class="comment">/****      If not, "delete" oldest messages until there's room         ****/</span>
01320 
01321    <span class="keywordflow">while</span>( shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a> + <span class="keyword">sizeof</span>(TPORT_HEAD) + length - shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> &gt; shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> )
01322    {
01323       ir = shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> % shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01324       <span class="keywordflow">if</span> ( ring[ir] != <a class="code" href="transport_8h.html#a3">FIRST_BYTE</a> )
01325       {
01326           fprintf( stdout,
01327                   <span class="stringliteral">"ERROR: tport_copyto; keyold not at FIRST_BYTE, Region %ld\n"</span>,
01328                    region-&gt;<a class="code" href="structSHM__INFO.html#m1">key</a> );
01329           retval = <a class="code" href="transport_8h.html#a4">TPORT_FATAL</a>;
01330           <span class="keywordflow">goto</span> release_semaphore; 
01331       }
01332       <span class="keywordflow">for</span> ( j=0 ; j &lt; <span class="keyword">sizeof</span>(TPORT_HEAD) ; j++ )
01333       {
01334          <span class="keywordflow">if</span> ( ir &gt;= shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> )   ir -= shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01335          o[j] = ring[ir++];
01336       }
01337       shm-&gt;<a class="code" href="structSHM__HEAD.html#m3">keyold</a> += <span class="keyword">sizeof</span>(TPORT_HEAD) + old.<a class="code" href="structTPORT__HEAD.html#m1">size</a>;
01338    }
01339 
01340 <span class="comment">/**** Now copy transport header into shared memory by chunks... ****/</span>
01341 
01342    ir = shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a> % shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01343    nwrap = ir + <span class="keyword">sizeof</span>(TPORT_HEAD) - shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01344    <span class="keywordflow">if</span> ( nwrap &lt;= 0 )
01345    {
01346          memcpy( (<span class="keywordtype">void</span> *) &amp;ring[ir], (<span class="keywordtype">void</span> *) h, <span class="keyword">sizeof</span>(<a class="code" href="structTPORT__HEAD.html">TPORT_HEAD</a>) );
01347    }
01348    <span class="keywordflow">else</span>
01349    {
01350          nfill = <span class="keyword">sizeof</span>(TPORT_HEAD) - nwrap;
01351          memcpy( (<span class="keywordtype">void</span> *) &amp;ring[ir], (<span class="keywordtype">void</span> *) &amp;h[0],     nfill );
01352          memcpy( (<span class="keywordtype">void</span> *) &amp;ring[0],  (<span class="keywordtype">void</span> *) &amp;h[nfill], nwrap );
01353    }
01354    ir += <span class="keyword">sizeof</span>(TPORT_HEAD);
01355    <span class="keywordflow">if</span> ( ir &gt;= shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a> )  ir -= shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01356 
01357 <span class="comment">/**** ...and copy message into shared memory by chunks ****/</span>
01358 
01359    nwrap = ir + length - shm-&gt;<a class="code" href="structSHM__HEAD.html#m1">keymax</a>;
01360    <span class="keywordflow">if</span> ( nwrap &lt;= 0 )
01361    {
01362          memcpy( (<span class="keywordtype">void</span> *) &amp;ring[ir], (<span class="keywordtype">void</span> *) msg, length );
01363    }
01364    <span class="keywordflow">else</span>
01365    {
01366          nfill = length - nwrap;
01367          memcpy( (<span class="keywordtype">void</span> *) &amp;ring[ir], (<span class="keywordtype">void</span> *) &amp;msg[0],     nfill );
01368          memcpy( (<span class="keywordtype">void</span> *) &amp;ring[0],  (<span class="keywordtype">void</span> *) &amp;msg[nfill], nwrap );
01369    }
01370    shm-&gt;<a class="code" href="structSHM__HEAD.html#m2">keyin</a> += <span class="keyword">sizeof</span>(TPORT_HEAD) + length;
01371 
01372 <span class="comment">/**** Finished with shared memory, let others know via semaphore ****/</span>
01373 
01374 release_semaphore:
01375    ReleaseMutex(region-&gt;hMutex);
01376 
01377    <span class="keywordflow">if</span>( retval == <a class="code" href="transport_8h.html#a4">TPORT_FATAL</a> ) exit( 1 );
01378    <span class="keywordflow">return</span>( retval ); 
01379 }
01380 
01381 
01382 <span class="comment">/************************* tport_buferror ***************************/</span>
01383 <span class="comment">/*  Build an error message and put it in the public memory region   */</span>
01384 <span class="comment">/********************************************************************/</span>
<a name="l01385"></a><a class="code" href="transport_8c.html#a14">01385</a> <span class="keywordtype">void</span> <a class="code" href="transport_8c.html#a14">tport_buferror</a>( <span class="keywordtype">short</span>  ierr,       <span class="comment">/* 2-byte error word       */</span>
01386                      <span class="keywordtype">char</span>  *note  )     <span class="comment">/* string describing error */</span>
01387 {
01388         <a class="code" href="structMSG__LOGO.html">MSG_LOGO</a>    logo;
01389         <span class="keywordtype">char</span>        msg[256];
01390         <span class="keywordtype">long</span>        size;
01391         time_t      t;
01392 
01393         logo.<a class="code" href="structMSG__LOGO.html#m2">instid</a> = <a class="code" href="transport_8c.html#a11">MyInstid</a>;
01394         logo.<a class="code" href="structMSG__LOGO.html#m1">mod</a>    = <a class="code" href="transport_8c.html#a10">MyModuleId</a>;
01395         logo.<a class="code" href="structMSG__LOGO.html#m0">type</a>   = <a class="code" href="transport_8c.html#a12">TypeError</a>;
01396 
01397         time( &amp;t );
01398         sprintf( msg, <span class="stringliteral">"%ld %hd %s\n"</span>, t, ierr, note );
01399         size = strlen( msg );   <span class="comment">/* don't include the null byte in the message */</span>
01400 
01401         <span class="keywordflow">if</span> ( <a class="code" href="transport_8c.html#a19">tport_putmsg</a>( (<a class="code" href="structSHM__INFO.html">SHM_INFO</a> *) PubRegion, &amp;logo, size, msg ) != <a class="code" href="transport_8h.html#a5">PUT_OK</a> )
01402         {
01403             printf(<span class="stringliteral">"tport_bufthr:  Error sending error:%hd for module:%d.\n"</span>,
01404                     ierr, MyModuleId );
01405         }
01406         <span class="keywordflow">return</span>;
01407 }
01408 
01409 
01410 <span class="comment">/************************ function tport_syserr **********************/</span>
01411 <span class="comment">/*                 Print a system error and terminate.               */</span>
01412 <span class="comment">/*********************************************************************/</span>
01413 
<a name="l01414"></a><a class="code" href="transport_8c.html#a13">01414</a> <span class="keywordtype">void</span> <a class="code" href="transport_8c.html#a13">tport_syserr</a>( <span class="keywordtype">char</span> *msg,   <span class="comment">/* message to print (which routine had an error) */</span>
01415                    <span class="keywordtype">long</span>  key )  <span class="comment">/* identifies which memory region had the error  */</span>
01416 {
01417    <span class="keyword">extern</span> <span class="keywordtype">int</span>   sys_nerr;
01418    <span class="keyword">extern</span> <span class="keywordtype">char</span> *sys_errlist[];
01419 
01420    <span class="keywordtype">long</span> err = GetLastError();   <span class="comment">/* Override with per thread err */</span>
01421 
01422    fprintf( stdout, <span class="stringliteral">"ERROR: %s (%d"</span>, msg, err );
01423    fprintf( stdout, <span class="stringliteral">"; %s) Region: %ld\n"</span>, strerror(err), key);
01424 
01425 <span class="comment">/*   if ( err &gt; 0 &amp;&amp; err &lt; sys_nerr )</span>
01426 <span class="comment">      fprintf( stdout,"; %s) Region: %ld\n", sys_errlist[err], key );</span>
01427 <span class="comment">   else</span>
01428 <span class="comment">      fprintf( stdout, ") Region: %ld\n", key ); */</span>
01429 
01430    exit( 1 );
01431 }
01432 
</pre></div><hr><address style="align: right;"><small>Generated on Tue May 6 09:16:12 2003 for Earthworm Libs by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc3 </small></address>
</body>
</html>
