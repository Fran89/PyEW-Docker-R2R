<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>geo_to_km.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>geo_to_km.c</h1><a href="geo__to__km_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00002 <span class="preprocessor">#include &lt;math.h&gt;</span>
00003 
00004 <span class="comment">/* value below fixed by Alex 6/6/1 */</span>
<a name="l00005"></a><a class="code" href="geo__to__km_8c.html#a0">00005</a> <span class="preprocessor">#define PI 3.14159265358979323846</span>
00006 <span class="preprocessor"></span>
<a name="l00007"></a><a class="code" href="geo__to__km_8c.html#a6">00007</a> <span class="keywordtype">int</span> <a class="code" href="geo__to__km_8c.html#a6">geo_to_km</a>(<span class="keywordtype">double</span> lat1,<span class="keywordtype">double</span> lon1,<span class="keywordtype">double</span> lat2,<span class="keywordtype">double</span> lon2,<span class="keywordtype">double</span>* dist,<span class="keywordtype">double</span>* azm) 
00008 {
00009 
00010 <span class="comment">/*</span>
00011 <span class="comment">=====================================================================</span>
00012 <span class="comment"> PURPOSE:  To compute the distance and azimuth between locations.</span>
00013 <span class="comment">=====================================================================</span>
00014 <span class="comment"> INPUT ARGUMENTS:</span>
00015 <span class="comment">    lat1:     Event latitude in decimal degrees, North positive. [r]</span>
00016 <span class="comment">    lon1:     Event longitude, East positive. [r]</span>
00017 <span class="comment">    lat2:     station latitude. [r]</span>
00018 <span class="comment">    lon2:     station longitude. [r]</span>
00019 <span class="comment">=====================================================================</span>
00020 <span class="comment"> OUTPUT ARGUMENTS:</span>
00021 <span class="comment">    DIST:    epicentral distance in km. [r]</span>
00022 <span class="comment">    AZM:      azimuth in degrees. [r]</span>
00023 <span class="comment">=====================================================================</span>
00024 <span class="comment">*/</span>
00025 <span class="comment">/*</span>
00026 <span class="comment">Calculations are based upon the reference spheroid of 1968 and</span>
00027 <span class="comment">are defined by the major radius (RAD) and the flattening (FL).</span>
00028 <span class="comment">*/</span>
00029 
00030       <span class="keywordtype">double</span> a, b;
00031       <span class="keywordtype">double</span> semi_major=a=6378.160;
00032       <span class="keywordtype">double</span> semi_minor=b=6356.775;   
00033       <span class="keywordtype">double</span> torad, todeg;
00034       <span class="keywordtype">double</span> aa, bb, cc, dd, top, bottom, lambda12, az, temp;
00035       <span class="keywordtype">double</span> v1, v2;
00036       <span class="keywordtype">double</span> fl, e, e2, eps, eps0;
00037       <span class="keywordtype">double</span> b0, x2, y2, z2, z1, u1p, u2p, xdist;
00038       <span class="keywordtype">double</span> lat1rad, lat2rad, lon1rad, lon2rad;
00039       <span class="keywordtype">double</span> coslon1, sinlon1, coslon2, sinlon2;
00040       <span class="keywordtype">double</span> coslat1, sinlat1, coslat2, sinlat2;
00041       <span class="keywordtype">double</span> tanlat1, tanlat2, cosazm, sinazm;
00042 
00043       <span class="keywordtype">double</span> c0, c2, c4, c6;
00044 
00045       <span class="keywordtype">double</span> c00=1.0, c01=0.25, c02=-0.046875, c03=0.01953125;
00046       <span class="keywordtype">double</span> c21=-0.125, c22=0.03125, c23=-0.014648438;
00047       <span class="keywordtype">double</span> c42=-0.00390625, c43=0.0029296875;
00048       <span class="keywordtype">double</span> c63=-0.0003255208;
00049 
00050 <span class="comment">/*  Check for special conditions */</span>
00051      <span class="keywordflow">if</span>( lat1 == lat2 &amp;&amp; lon1 == lon2 ) {
00052          *azm = 0.0;
00053          *<a class="code" href="geo__to__km_8c.html#a3">dist</a>= 0.0;
00054          <span class="keywordflow">return</span>(1);
00055      }
00056 <span class="comment">/* - Initialize.             */</span>
00057 
00058       torad = <a class="code" href="geo__to__km_8c.html#a0">PI</a> / 180.0;
00059       todeg = 1.0 / torad;
00060       fl = ( a - b ) / a;
00061       e2 = 2.0*fl - fl*fl;
00062       e  = sqrt(e2);
00063       eps = e2 / ( 1.0 - e2);
00064 <span class="comment">/*</span>
00065 <span class="comment">* - Convert event location to radians.</span>
00066 <span class="comment">*   (Equations are unstable for latidudes of exactly 0 degrees.)</span>
00067 <span class="comment">*/</span>
00068       temp=lat1;
00069       <span class="keywordflow">if</span>(temp == 0.) temp=1.0e-08;
00070       lat1rad=torad*temp;
00071       lon1rad=torad*lon1;
00072 
00073       temp=lat2;
00074       <span class="keywordflow">if</span>(temp == 0.) temp=1.0e-08;
00075       lat2rad=torad*temp;
00076       lon2rad=torad*lon2;
00077 
00078 <span class="comment">/*</span>
00079 <span class="comment">      Compute some of the easier and often used terms.</span>
00080 <span class="comment">*/</span>
00081       coslon1 = cos(lon1rad);
00082       sinlon1 = sin(lon1rad);
00083       coslon2 = cos(lon2rad);
00084       sinlon2 = sin(lon2rad);
00085       tanlat1 = tan(lat1rad);
00086       tanlat2 = tan(lat2rad);
00087       sinlat1 = sin(lat1rad);
00088       coslat1 = cos(lat1rad);
00089       sinlat2 = sin(lat2rad);
00090       coslat2 = cos(lat2rad);
00091 <span class="comment">/*</span>
00092 <span class="comment">    The radii of curvature are compute from an equation defined in</span>
00093 <span class="comment">    GEODESY by Bomford, Appendix A (page 647).</span>
00094 <span class="comment">    v = semi_major/sqrt(1-e*e*sin(lat)*sin(lat))</span>
00095 <span class="comment">*/</span>
00096       v1 = a / sqrt( 1.0 - e2*sinlat1*sinlat1 );  <span class="comment">/* radii of curvature  */</span>
00097       v2 = a / sqrt( 1.0 - e2*sinlat2*sinlat2 );  <span class="comment">/* radii of curvature  */</span>
00098       aa = tanlat2 / ((1.0+eps)*tanlat1);
00099       bb = e2*(v1*coslat1)/(v2*coslat2);
00100       lambda12 = aa + bb;
00101       top = sinlon2*coslon1 - coslon2*sinlon1;
00102       bottom = lambda12*sinlat1-coslon2*coslon1*sinlat1-sinlon2*sinlon1*sinlat1;
00103       az = atan2(top,bottom)*todeg;
00104       <span class="keywordflow">if</span>( az &lt; 0.0 ) az = 360 + az;
00105       *azm = az;
00106       az = az * torad;
00107       cosazm = cos(az);
00108       sinazm = sin(az);
00109 
00110 <span class="comment">/*</span>
00111 <span class="comment">   Now compute the distance using the equations on page 121 in GEODESY by</span>
00112 <span class="comment">   Bomford (2.15 Reverse formulae).  There is some numerical problem with </span>
00113 <span class="comment">   the following formulae.</span>
00114 <span class="comment">   If the station is in the southern hemisphere and the event is in the</span>
00115 <span class="comment">   northern, these equations give the longer, not the shorter distance between</span>
00116 <span class="comment">   the two locations.  Since the equations are messy, the simplist solution</span>
00117 <span class="comment">   is to reverse the order of the lat,lon pairs.  This means that the azimuth</span>
00118 <span class="comment">   must also be recomputed to get the correct distance.</span>
00119 <span class="comment">*/</span>
00120       <span class="keywordflow">if</span>( lat2rad &lt; 0.0 ) {
00121           temp = lat1rad;
00122           lat1rad = lat2rad;
00123           lat2rad = temp;
00124           temp = lon1rad;
00125           lon1rad = lon2rad;
00126           lon2rad = temp;
00127 
00128           coslon1 = cos(lon1rad);
00129           sinlon1 = sin(lon1rad);
00130           coslon2 = cos(lon2rad);
00131           sinlon2 = sin(lon2rad);
00132           tanlat1 = tan(lat1rad);
00133           tanlat2 = tan(lat2rad);
00134           sinlat1 = sin(lat1rad);
00135           coslat1 = cos(lat1rad);
00136           sinlat2 = sin(lat2rad);
00137           coslat2 = cos(lat2rad);
00138 
00139           v1 = a / sqrt( 1.0 - e2*sinlat1*sinlat1 );  
00140           v2 = a / sqrt( 1.0 - e2*sinlat2*sinlat2 );  
00141 
00142           aa = tanlat2 / ((1.0+eps)*tanlat1);
00143           bb = e2*(v1*coslat1)/(v2*coslat2);
00144           lambda12 = aa + bb;
00145 
00146           top = sinlon2*coslon1 - coslon2*sinlon1;
00147           bottom =lambda12*sinlat1-coslon2*coslon1*sinlat1-
00148                   sinlon2*sinlon1*sinlat1;
00149           az = atan2(top,bottom);
00150           cosazm = cos(az);
00151           sinazm = sin(az);
00152             
00153        }
00154 
00155        eps0 = eps * ( coslat1*coslat1*cosazm*cosazm + sinlat1*sinlat1 );
00156        b0 = (v1/(1.0+eps0)) * sqrt(1.0+eps*coslat1*coslat1*cosazm*cosazm);
00157      
00158        x2 = v2*coslat2*(coslon2*coslon1+sinlon2*sinlon1);
00159        y2 = v2*coslat2*(sinlon2*coslon1-coslon2*sinlon1);
00160        z2 = v2*(1.0-e2)*sinlat2;
00161        z1 = v1*(1.0-e2)*sinlat1;
00162 
00163        c0 = c00 + c01*eps0 + c02*eps0*eps0 + c03*eps0*eps0*eps0;
00164        c2 =       c21*eps0 + c22*eps0*eps0 + c23*eps0*eps0*eps0;
00165        c4 =                  c42*eps0*eps0 + c43*eps0*eps0*eps0;
00166        c6 =                                  c63*eps0*eps0*eps0;
00167 
00168        bottom = cosazm*sqrt(1.0+eps0);
00169        u1p = atan2(tanlat1,bottom);
00170           
00171        top = v1*sinlat1+(1.0+eps0)*(z2-z1);
00172        bottom = (x2*cosazm-y2*sinlat1*sinazm)*sqrt(1.0+eps0);
00173        u2p = atan2(top,bottom);
00174 
00175        aa = c0*(u2p-u1p);
00176        bb = c2*(sin(2.0*u2p)-sin(2.0*u1p));
00177        cc = c4*(sin(4.0*u2p)-sin(4.0*u1p));
00178        dd = c6*(sin(6.0*u2p)-sin(6.0*u1p));
00179 
00180        xdist = fabs(b0*(aa+bb+cc+dd));
00181        *<a class="code" href="geo__to__km_8c.html#a3">dist</a> = xdist;
00182            <span class="keywordflow">return</span>(1);
00183 }
00184 
00185 
00186 
<a name="l00187"></a><a class="code" href="geo__to__km_8c.html#a7">00187</a> <span class="keywordtype">int</span>     <a class="code" href="geo__to__km_8c.html#a7">geo_to_km_deg</a> (<span class="keywordtype">double</span> lat1, <span class="keywordtype">double</span> lon1, <span class="keywordtype">double</span> lat2, <span class="keywordtype">double</span> lon2,
00188                                         <span class="keywordtype">double</span> *dist, <span class="keywordtype">double</span> *xdeg, <span class="keywordtype">double</span> *azm)
00189 {
00190 
00191 <span class="comment">/*</span>
00192 <span class="comment">=====================================================================</span>
00193 <span class="comment"> PURPOSE:  To compute the distance and azimuth between locations.</span>
00194 <span class="comment">=====================================================================</span>
00195 <span class="comment"> INPUT ARGUMENTS:</span>
00196 <span class="comment">    lat1:     Event latitude in decimal degrees, North positive. [r]</span>
00197 <span class="comment">    lon1:     Event longitude, East positive. [r]</span>
00198 <span class="comment">    lat2:     Array of station latitudes. [r]</span>
00199 <span class="comment">    lon2:     Array of station longitudes. [r]</span>
00200 <span class="comment">=====================================================================</span>
00201 <span class="comment"> OUTPUT ARGUMENTS:</span>
00202 <span class="comment">    DIST:    epicentral distance in km. [r]</span>
00203 <span class="comment">    XDEG:    epicentral distance in degrees. [r]</span>
00204 <span class="comment">    AXM:     azimuth in degrees. [r]</span>
00205 <span class="comment">=====================================================================</span>
00206 <span class="comment">*/</span>
00207 <span class="comment">/*</span>
00208 <span class="comment">Calculations are based upon the reference spheroid of 1968 and</span>
00209 <span class="comment">are defined by the major radius (RAD) and the flattening (FL).</span>
00210 <span class="comment">*/</span>
00211 
00212       <span class="keywordtype">double</span> a, b;
00213       <span class="keywordtype">double</span> semi_major=a=6378.160;
00214       <span class="keywordtype">double</span> semi_minor=b=6356.775;
00215       <span class="keywordtype">double</span> torad, todeg;
00216       <span class="keywordtype">double</span> aa, bb, cc, dd, top, bottom, lambda12, az, temp;
00217       <span class="keywordtype">double</span> v1, v2;
00218       <span class="keywordtype">double</span> fl, e, e2, eps, eps0;
00219       <span class="keywordtype">double</span> b0, x2, y2, z2, z1, u1p, u2p, xdist;
00220       <span class="keywordtype">double</span> lat1rad, lat2rad, lon1rad, lon2rad;
00221       <span class="keywordtype">double</span> coslon1, sinlon1, coslon2, sinlon2;
00222       <span class="keywordtype">double</span> coslat1, sinlat1, coslat2, sinlat2;
00223       <span class="keywordtype">double</span> tanlat1, tanlat2, cosazm, sinazm;
00224           <span class="keywordtype">double</span> onemec2;
00225           <span class="keywordtype">double</span> aa2, bb2, cc2, dd2, ee2, ff2, aa3, bb3, cc3, dd3, ee3, ff3;
00226           <span class="keywordtype">double</span> aminus, bminus, cminus, aplus, bplus, cplus;
00227           <span class="keywordtype">double</span> thg, sd, sc, deg;
00228 
00229       <span class="keywordtype">double</span> c0, c2, c4, c6;
00230 
00231       <span class="keywordtype">double</span> c00=1.0, c01=0.25, c02=-0.046875, c03=0.01953125;
00232       <span class="keywordtype">double</span> c21=-0.125, c22=0.03125, c23=-0.014648438;
00233       <span class="keywordtype">double</span> c42=-0.00390625, c43=0.0029296875;
00234       <span class="keywordtype">double</span> c63=-0.0003255208;
00235 
00236 <span class="comment">/*  Check for special conditions                                  */</span>
00237 
00238      <span class="keywordflow">if</span>( lat1 == lat2 &amp;&amp; lon1 == lon2 ) {
00239          *azm = 0.0;
00240          *<a class="code" href="geo__to__km_8c.html#a3">dist</a>= 0.0;
00241          <span class="keywordflow">return</span>(0);
00242      }
00243 <span class="comment">/* - Initialize.             */</span>
00244 
00245       torad = <a class="code" href="geo__to__km_8c.html#a0">PI</a> / 180.0;
00246       todeg = 1.0 / torad;
00247       fl = ( a - b ) / a;
00248       e2 = 2.0*fl - fl*fl;
00249       e  = sqrt(e2);
00250       eps = e2 / ( 1.0 - e2);
00251       onemec2 = 1.0 - e2;
00252 <span class="comment">/*</span>
00253 <span class="comment">* - Convert event location to radians.</span>
00254 <span class="comment">*   (Equations are unstable for latidudes of exactly 0 degrees.)</span>
00255 <span class="comment">*/</span>
00256 
00257       temp=lat1;
00258       <span class="keywordflow">if</span>(temp == 0.) temp=1.0e-08;
00259       lat1rad=torad*temp;
00260       lon1rad=torad*lon1;
00261 
00262       temp=lat2;
00263       <span class="keywordflow">if</span>(temp == 0.) temp=1.0e-08;
00264       lat2rad=torad*temp;
00265       lon2rad=torad*lon2;
00266 
00267 <span class="comment">/*</span>
00268 <span class="comment">      Compute some of the easier and often used terms.</span>
00269 <span class="comment">*/</span>
00270       coslon1 = cos(lon1rad);
00271       sinlon1 = sin(lon1rad);
00272       coslon2 = cos(lon2rad);
00273       sinlon2 = sin(lon2rad);
00274       tanlat1 = tan(lat1rad);
00275       tanlat2 = tan(lat2rad);
00276       sinlat1 = sin(lat1rad);
00277       coslat1 = cos(lat1rad);
00278       sinlat2 = sin(lat2rad);
00279       coslat2 = cos(lat2rad);
00280 
00281 <span class="comment">/*</span>
00282 <span class="comment">    The radii of curvature are compute from an equation defined in</span>
00283 <span class="comment">    GEODESY by Bomford, Appendix A (page 647).</span>
00284 <span class="comment">    v = semi_major/sqrt(1-e*e*sin(lat)*sin(lat))</span>
00285 <span class="comment">*/</span>
00286       v1 = a / sqrt( 1.0 - e2*sinlat1*sinlat1 );  <span class="comment">/* radii of curvature  */</span>
00287       v2 = a / sqrt( 1.0 - e2*sinlat2*sinlat2 );  <span class="comment">/* radii of curvature  */</span>
00288 
00289       aa = tanlat2 / ((1.0+eps)*tanlat1);
00290       bb = e2*(v1*coslat1)/(v2*coslat2);
00291       lambda12 = aa + bb;
00292 
00293       top = sinlon2*coslon1 - coslon2*sinlon1;
00294       bottom = lambda12*sinlat1-coslon2*coslon1*sinlat1-sinlon2*sinlon1*sinlat1;
00295       az = atan2(top,bottom)*todeg;
00296       <span class="keywordflow">if</span>( az &lt; 0.0 ) az = 360 + az;
00297       *azm = az;
00298       az = az * torad;
00299       cosazm = cos(az);
00300       sinazm = sin(az);
00301 
00302 <span class="comment">/*</span>
00303 <span class="comment">   Now compute the distance using the equations on page 121 in GEODESY by</span>
00304 <span class="comment">   Bomford (2.15 Reverse formulae).  There is some numerical problem with</span>
00305 <span class="comment">   the following formulae.</span>
00306 <span class="comment">   If the station is in the southern hemisphere and the event is in the</span>
00307 <span class="comment">   northern, these equations give the longer, not the shorter distance between</span>
00308 <span class="comment">   the two locations.  Since the equations are messy, the simplist solution</span>
00309 <span class="comment">   is to reverse the order of the lat,lon pairs.  This means that the azimuth</span>
00310 <span class="comment">   must also be recomputed to get the correct distance.</span>
00311 <span class="comment">*/</span>
00312 
00313       <span class="keywordflow">if</span>( lat2rad &lt; 0.0 ) {
00314           temp = lat1rad;
00315           lat1rad = lat2rad;
00316           lat2rad = temp;
00317           temp = lon1rad;
00318           lon1rad = lon2rad;
00319           lon2rad = temp;
00320 
00321           coslon1 = cos(lon1rad);
00322           sinlon1 = sin(lon1rad);
00323           coslon2 = cos(lon2rad);
00324           sinlon2 = sin(lon2rad);
00325           tanlat1 = tan(lat1rad);
00326           tanlat2 = tan(lat2rad);
00327           sinlat1 = sin(lat1rad);
00328           coslat1 = cos(lat1rad);
00329           sinlat2 = sin(lat2rad);
00330           coslat2 = cos(lat2rad);
00331 
00332           v1 = a / sqrt( 1.0 - e2*sinlat1*sinlat1 );
00333           v2 = a / sqrt( 1.0 - e2*sinlat2*sinlat2 );
00334 
00335           aa = tanlat2 / ((1.0+eps)*tanlat1);
00336           bb = e2*(v1*coslat1)/(v2*coslat2);
00337           lambda12 = aa + bb;
00338 
00339           top = sinlon2*coslon1 - coslon2*sinlon1;
00340           bottom =lambda12*sinlat1-coslon2*coslon1*sinlat1-
00341                   sinlon2*sinlon1*sinlat1;
00342           az = atan2(top,bottom);
00343           cosazm = cos(az);
00344           sinazm = sin(az);
00345 
00346        }
00347 
00348        eps0 = eps * ( coslat1*coslat1*cosazm*cosazm + sinlat1*sinlat1 );
00349        b0 = (v1/(1.0+eps0)) * sqrt(1.0+eps*coslat1*coslat1*cosazm*cosazm);
00350 
00351        x2 = v2*coslat2*(coslon2*coslon1+sinlon2*sinlon1);
00352        y2 = v2*coslat2*(sinlon2*coslon1-coslon2*sinlon1);
00353        z2 = v2*(1.0-e2)*sinlat2;
00354        z1 = v1*(1.0-e2)*sinlat1;
00355 
00356        c0 = c00 + c01*eps0 + c02*eps0*eps0 + c03*eps0*eps0*eps0;
00357        c2 =       c21*eps0 + c22*eps0*eps0 + c23*eps0*eps0*eps0;
00358        c4 =                  c42*eps0*eps0 + c43*eps0*eps0*eps0;
00359        c6 =                                  c63*eps0*eps0*eps0;
00360 
00361        bottom = cosazm*sqrt(1.0+eps0);
00362        u1p = atan2(tanlat1,bottom);
00363 
00364        top = v1*sinlat1+(1.0+eps0)*(z2-z1);
00365        bottom = (x2*cosazm-y2*sinlat1*sinazm)*sqrt(1.0+eps0);
00366        u2p = atan2(top,bottom);
00367 
00368        aa = c0*(u2p-u1p);
00369        bb = c2*(sin(2.0*u2p)-sin(2.0*u1p));
00370        cc = c4*(sin(4.0*u2p)-sin(4.0*u1p));
00371        dd = c6*(sin(6.0*u2p)-sin(6.0*u1p));
00372 
00373        xdist = fabs(b0*(aa+bb+cc+dd));
00374        *<a class="code" href="geo__to__km_8c.html#a3">dist</a> = xdist;
00375 
00376 <span class="comment">/* compute the distance in degrees                                */</span>
00377                 thg=atan(onemec2*tan(lat1rad));
00378                 dd2=sin(lon1rad);
00379                 ee2=-cos(lon1rad);
00380                 ff2=-cos(thg);
00381                 cc2=sin(thg);
00382                 aa2= ff2*ee2;
00383                 bb2=-ff2*dd2;
00384 
00385 <span class="comment">/* -- Calculate some trig constants.          */</span>
00386 
00387                 thg=atan(onemec2*tan(lat2rad));
00388                 dd3=sin(lon2rad);
00389                 ee3=-cos(lon2rad);
00390                 ff3=-cos(thg);
00391                 cc3=sin(thg);
00392                 aa3=ff3*ee3;
00393                 bb3=-ff3*dd3;
00394                 sc=aa2*aa3+bb2*bb3+cc2*cc3;
00395 
00396 <span class="comment">/* - Spherical trig relationships used to compute angles.       */</span>
00397 
00398         aminus = aa2 - aa3;
00399                 bminus = bb2 - bb3;
00400                 cminus = cc2 - cc3;
00401                 aplus  = aa2 + aa3;
00402                 bplus  = bb2 + bb3;
00403                 cplus  = cc2 + cc3;
00404 
00405                 sd=0.5*sqrt((aminus*aminus + bminus*bminus+cminus*cminus)*(aplus*aplus
00406                         + bplus*bplus + cplus*cplus));
00407                 deg=atan2(sd,sc)*todeg;
00408                 *xdeg = deg;
00409 
00410            <span class="keywordflow">return</span>(1);
00411 }
00412 
00413 <a class="code" href="c__geo__to__km_8h.html#a2">distaz_geo</a>(olat,olon,dist,azimuth,lat,lon)
<a name="l00414"></a><a class="code" href="geo__to__km_8c.html#a1">00414</a> <span class="keywordtype">double</span> olat, <a class="code" href="geo__to__km_8c.html#a1">olon</a>, <a class="code" href="geo__to__km_8c.html#a2">azimuth</a>, <a class="code" href="geo__to__km_8c.html#a3">dist</a>, *<a class="code" href="geo__to__km_8c.html#a4">lat</a>, *<a class="code" href="geo__to__km_8c.html#a5">lon</a>;
00415 {
00416 
00417 <span class="comment">/*</span>
00418 <span class="comment">=====================================================================</span>
00419 <span class="comment"> PURPOSE:  To compute latitude and longitude given a distance and</span>
00420 <span class="comment">            azimuth from a geographic point (olat,olon).</span>
00421 <span class="comment">=====================================================================</span>
00422 <span class="comment"> INPUT ARGUMENTS:</span>
00423 <span class="comment">    olat:    latitude in decimal degrees, North positive.</span>
00424 <span class="comment">    olon:    longitude in decimal degrees, East positive.</span>
00425 <span class="comment">    dist:    distance from point (olat,olon) in kms.</span>
00426 <span class="comment">    azimuth: azimuath between point (olat,olon) and (lat,lon) in degrees.</span>
00427 <span class="comment">=====================================================================</span>
00428 <span class="comment"> OUTPUT ARGUMENTS:</span>
00429 <span class="comment">    lat:    latitude in decimal degrees, North positive.</span>
00430 <span class="comment">    lon:    longitude in decimal degrees, East positive.</span>
00431 <span class="comment">=====================================================================</span>
00432 <span class="comment">*/</span>
00433 
00434       <span class="keywordtype">double</span> C, C_sqr;
00435       <span class="keywordtype">double</span> torad, todeg;
00436       <span class="keywordtype">double</span> a, b, aa, bb, a0, b0;
00437       <span class="keywordtype">double</span> g0, g2, g4, g6;
00438       <span class="keywordtype">double</span> latrad, lonrad, azmrad;
00439       <span class="keywordtype">double</span> ec, ec2, eps, eps0, eps2, fl;
00440       <span class="keywordtype">double</span> tanu1p, tanmu, sinu1, sinu2;
00441       <span class="keywordtype">double</span> tanlat, coslat, sinlat, tanazm, sinazm, cosazm;
00442       <span class="keywordtype">double</span> v1, u2, u1p, u2p, u1pbot, x2, y2, z2, ztop, zbot;
00443       <span class="keywordtype">double</span> arg, temp, delta, mu, sd, sig1, sig2;
00444 
00445 <span class="comment">/*</span>
00446 <span class="comment">Calculations are based upon the reference spheroid of 1967.</span>
00447 <span class="comment">See GEODESY by Bomford for definitions and reference values.</span>
00448 <span class="comment">Reference spheriod is found in GEODESY by Bomford (page 426).  Definitions</span>
00449 <span class="comment">for flattening, eccentricity and second eccentricity are found in</span>
00450 <span class="comment">Appendix A (page 646).</span>
00451 <span class="comment">*/</span>
00452 
00453       <span class="keywordtype">double</span> semi_major=a=6378.16, semi_minor=b=6356.775;
00454       <span class="keywordtype">double</span> a1=0.25, b1=-0.125, c1=-0.0078125;
00455       <span class="keywordtype">double</span> g00=1.0, g01=-0.25, g02=0.109375, g03=-0.058139535;
00456       <span class="keywordtype">double</span> g21=0.125, g22=-0.06250, g23=0.034667969;
00457       <span class="keywordtype">double</span> g42=0.01953125, g43=-0.01953125;
00458       <span class="keywordtype">double</span> g63=0.004720052;
00459 
00460 <span class="comment">/* - Initialize.             */</span>
00461 
00462       fl = (a - b)/a;             <span class="comment">/* earth flattening                 */</span>
00463       ec2 = 2.0*fl-fl*fl;         <span class="comment">/* square of eccentricity           */</span>
00464       ec = sqrt(ec2);             <span class="comment">/* eccentricity                     */</span>
00465       eps = ec2/(1.0-ec2);        <span class="comment">/* second eccentricity e'*e' = eps  */</span>
00466       torad = <a class="code" href="geo__to__km_8c.html#a0">PI</a> / 180.0;
00467       todeg = 1.0 / torad;
00468 
00469 <span class="comment">/* - Convert event location to radians.                                    */</span>
00470 
00471       temp=olat;
00472       <span class="keywordflow">if</span>(temp == 0.) temp=1.0e-08;
00473       latrad=torad*temp;
00474       lonrad=torad*<a class="code" href="geo__to__km_8c.html#a1">olon</a>;
00475       azmrad=<a class="code" href="geo__to__km_8c.html#a2">azimuth</a>*torad;
00476 
00477 <span class="comment">/*  Compute some of the easier terms               */</span>
00478 
00479       coslat = cos(latrad);
00480       sinlat = sin(latrad);
00481       cosazm = cos(azmrad);
00482       sinazm = sin(azmrad);
00483       tanazm = tan(azmrad);
00484       tanlat = tan(latrad);
00485 
00486       C_sqr = coslat*coslat*cosazm*cosazm+ sinlat*sinlat;
00487       C = sqrt(C_sqr);
00488       eps0 = C_sqr * eps;
00489       v1 = a/sqrt(1.0-ec2*sinlat*sinlat);          <span class="comment">/* Radii of curvature    */</span>
00490       b0 = v1*sqrt(1.0+eps*coslat*coslat*cosazm*cosazm)/(1.0+eps0);
00491 
00492       g0 = g00 + g01*eps0 + g02*eps0*eps0 + g03*eps0*eps0*eps0;
00493       g2 =       g21*eps0 + g22*eps0*eps0 + g23*eps0*eps0*eps0;
00494       g4 =                  g42*eps0*eps0 + g43*eps0*eps0*eps0;
00495       g6 =                                  g63*eps0*eps0*eps0;
00496 
00497 
00498       tanu1p = tanlat / (cosazm*sqrt(1.0+eps0));
00499       u1pbot = cosazm * sqrt(1.0+eps0);
00500       u1p=atan2(tanlat,u1pbot);
00501       sig1 = 0.5*( 2.0*u1p-(a1*eps0+b1*eps0*eps0)*sin(2.0*u1p)+
00502                  c1*eps0*eps0*sin(4.0*u1p));
00503 <span class="comment">/*</span>
00504 <span class="comment">      aa = ( sig2 - sig1 ) page 117, GEODESY</span>
00505 <span class="comment">      bb = ( sig1 + sig2 ) page 117, GEODESY</span>
00506 <span class="comment">*/</span>
00507       aa =  (<a class="code" href="geo__to__km_8c.html#a3">dist</a>*g0)/b0;
00508       bb = 2.0 * sig1 + aa;
00509       u2p=u1p+aa+2.0*g2*sin(aa)*cos(bb)+2.0*g4*sin(2.*aa)*cos(2.*bb)+
00510           2.*g6*sin(3.*aa)*cos(3.*bb);
00511       sinu1=tanlat/sqrt(1.0+eps+tanlat*tanlat);
00512       sinu2 = ((b0*C)/b)*sin(u2p)-((eps-eps0)/(1+eps0))*sinu1;
00513       u2 = asin(sinu2);
00514 
00515 <span class="comment">/*  This calculation of latitude is based on Rudoe's formulation, which has</span>
00516 <span class="comment">    not been tested  */</span>
00517 <span class="comment">/*      arg = sinu2/sqrt(1.0-eps*eps*cos(u2)*cos(u2));                       */</span>
00518 <span class="comment">/*    *lat = asin(arg)*todeg;                                                */</span>
00519 
00520       a0 = b0*sqrt(1.0+eps0);
00521       tanmu = sinlat*tanazm;
00522       mu = atan(tanmu);
00523 
00524 <span class="comment">/*  This calculation of longitude is based on Ruloe's formulation, which has</span>
00525 <span class="comment">    not been tested  */</span>
00526 <span class="comment">/*    arg = (a0*cos(u2p))/(a*cos(u2));                                       */</span>
00527 <span class="comment">/*    delta = acos(arg)-mu;                                                  */</span>
00528 <span class="comment">/*    *lon = (lonrad + delta)*todeg;                                         */</span>
00529 
00530 <span class="comment">/*</span>
00531 <span class="comment">   This calculation of latitude and longitude is an alternative to Rudoe's</span>
00532 <span class="comment">   formulation.  See GEODESY by Bomford (page 118).</span>
00533 <span class="comment">*/</span>
00534       sd=(ec2*v1*sinlat*coslat*sinazm)/(1.-ec2*coslat*coslat*sinazm*sinazm);
00535       x2=a0*cos(u2p)*cos(mu)+b0*sin(u2p)*sin(mu)*coslat*sinazm+
00536          sd*sinlat*sinazm;
00537       y2=-a0*cos(u2p)*sin(mu)+b0*sin(u2p)*cos(mu)*coslat*sinazm+
00538          sd*cosazm;
00539       z2=b0*C*sin(u2p)-(sd*coslat*sinazm)/(1.0+eps);
00540       ztop = (1.0+eps)*z2;
00541       zbot = sqrt(x2*x2+y2*y2);
00542       *<a class="code" href="geo__to__km_8c.html#a4">lat</a> = atan2(ztop,zbot)*todeg;
00543       *<a class="code" href="geo__to__km_8c.html#a5">lon</a> = (atan(y2/x2)+lonrad)*todeg;
00544       <span class="keywordflow">if</span>((atan(y2/x2)+lonrad)&lt;0.0) *<a class="code" href="geo__to__km_8c.html#a5">lon</a>=((atan(y2/x2)+lonrad)*todeg);
00545       arg = atan2(y2,x2)*todeg;
00546 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue May 6 09:16:01 2003 for Earthworm Libs by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc3 </small></address>
</body>
</html>
