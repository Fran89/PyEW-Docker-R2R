<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gma.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gma.c</h1><a href="gma_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *   THIS FILE IS UNDER RCS - DO NOT MODIFY UNLESS YOU HAVE</span>
00003 <span class="comment"> *   CHECKED IT OUT USING THE COMMAND CHECKOUT.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *    $Id: gma_8c-source.html 2161 2006-05-19 16:55:03Z paulf $</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *    Revision history:</span>
00008 <span class="comment"> *     $Log$
00008 <span class="comment"> *     Revision 1.1  2006/05/19 16:55:02  paulf
00008 <span class="comment"> *     first inclusion
00008 <span class="comment"> *</span>
00009 <span class="comment"> *     Revision 1.1  2002/02/28 17:00:39  lucky</span>
00010 <span class="comment"> *     Initial revision</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> */</span>
00014 
00015 <span class="comment">/* gma.c: Routines for the ground motion analyzer: compute PGA, PGV, PGD *</span>
00016 <span class="comment"> *        and spectral response, using spectral techniques               */</span>
00017 
00018 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00019 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00020 <span class="preprocessor">#include &lt;string.h&gt;</span>
00021 <span class="preprocessor">#include &lt;math.h&gt;</span>
00022 <span class="preprocessor">#include &lt;<a class="code" href="fft__prep_8h.html">fft_prep.h</a>&gt;</span>
00023 <span class="preprocessor">#include &lt;<a class="code" href="fft99_8h.html">fft99.h</a>&gt;</span>
00024 <span class="preprocessor">#include &lt;<a class="code" href="transfer_8h.html">transfer.h</a>&gt;</span>
00025 <span class="preprocessor">#include &lt;<a class="code" href="gma_8h.html">gma.h</a>&gt;</span>
00026 
<a name="l00027"></a><a class="code" href="gma_8c.html#a0">00027</a> <span class="preprocessor">#define MAXLINE 80</span>
00028 <span class="preprocessor"></span>
<a name="l00029"></a><a class="code" href="gma_8c.html#a1">00029</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="gma_8c.html#a1">Debug</a> = 0;
00030 
00031 <span class="comment">/* Internal Function Prototypes */</span>
00032 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gma_8c.html#a2">makeInt</a>(<span class="keywordtype">long</span> nfft, <span class="keywordtype">double</span> deltat, <span class="keywordtype">double</span> *fIntI);
00033 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="gma_8c.html#a3">makePsa</a>(<span class="keywordtype">double</span>, <span class="keywordtype">double</span>, <a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *);
00034 
00035 <span class="keywordtype">void</span> <a class="code" href="gma_8c.html#a4">cmpmax</a>(<span class="keywordtype">long</span> kug, <span class="keywordtype">double</span> *ug, <span class="keywordtype">double</span> w, <span class="keywordtype">double</span> damp, <span class="keywordtype">double</span> delta, 
00036             <span class="keywordtype">double</span> *zd, <span class="keywordtype">double</span> *zv, <span class="keywordtype">double</span> *za);
00037 
00038 
00039 <span class="comment">/*</span>
00040 <span class="comment"> * gma: converts a waveform (time series) from its original response</span>
00041 <span class="comment"> *              function to a new response function. This conversion is done</span>
00042 <span class="comment"> *              in the frequency domain. The frequency response of the </span>
00043 <span class="comment"> *              transfer function may be tapered. The input data will be</span>
00044 <span class="comment"> *              padded in the time-domain. The amount of padding is determined</span>
00045 <span class="comment"> *              automatically unless the user provides her own pad length.</span>
00046 <span class="comment"> * Arguments: input: array of data for preocessing</span>
00047 <span class="comment"> *             npts: number of data points to process</span>
00048 <span class="comment"> *           deltat: time interval between samples, in seconds</span>
00049 <span class="comment"> *           origRS: structure defining process that generated the input data</span>
00050 <span class="comment"> *                   that is, the response function to be removed</span>
00051 <span class="comment"> *           fTaper: array of four frequencies (f0, f1, f2, f3) defining the</span>
00052 <span class="comment"> *                   taper to be applied to the frequency response function</span>
00053 <span class="comment"> *                   before it is convolved with the data. Below f0 and above</span>
00054 <span class="comment"> *                   f3, the taper is 0; between f2 and f3 the taper is 1;</span>
00055 <span class="comment"> *                   between f0-f1 and f2-f3 is a cosine taper.</span>
00056 <span class="comment"> *           tTaper: length of cosine taper in seconds to be applied at</span>
00057 <span class="comment"> *                   both ends of the input data to provide a smooth</span>
00058 <span class="comment"> *                   transition into the zero-padded area.</span>
00059 <span class="comment"> *           padlen: The pad length to be applied to data before transforming</span>
00060 <span class="comment"> *                   to frequency domain. If padlen &lt; 0, pad length will be</span>
00061 <span class="comment"> *                   estimated here and the value chosen will be returned</span>
00062 <span class="comment"> *                   in this return-value parameter.</span>
00063 <span class="comment"> *             nfft: The size of the FFT chosen, based on npts + *padlen</span>
00064 <span class="comment"> *                   If the returned value of nfft + padlen is less than</span>
00065 <span class="comment"> *                   npts, then convertWave had to effectively truncate the </span>
00066 <span class="comment"> *                   raw trace in order to fit the processed trace in</span>
00067 <span class="comment"> *                   the limit of outBufLen.</span>
00068 <span class="comment"> *         spectPer: array of periods at which the Spectral Response is</span>
00069 <span class="comment"> *                   to be calculated</span>
00070 <span class="comment"> *              nsp; number of periods in spectPer</span>
00071 <span class="comment"> *        spectDamp: array of damping values at which the Spectral Response</span>
00072 <span class="comment"> *                   is to be calculated</span>
00073 <span class="comment"> *              nsd; number of damping values in spectDamp</span>
00074 <span class="comment"> *           output: array of the six sets of values output from the analysis.</span>
00075 <span class="comment"> *                   This array must be allocated by the caller, of length</span>
00076 <span class="comment"> *                   outBufLen * (3 + nsd * nsf).</span>
00077 <span class="comment"> *        outBufLen: size of one of the `output' arrays.</span>
00078 <span class="comment"> *             work: a work array that must be allocated by the caller.</span>
00079 <span class="comment"> *                   It's size must be outBufLen * 3.</span>
00080 <span class="comment"> *          workFFT: a work array for the FFT routines. It's size must be</span>
00081 <span class="comment"> *                   outBufLen * (2 + nsf * nsd).</span>
00082 <span class="comment"> *</span>
00083 <span class="comment"> * Returns: 0 on success</span>
00084 <span class="comment"> *         -1 on out-of-memory errors                   </span>
00085 <span class="comment"> *         -2 on too-small impulse response</span>
00086 <span class="comment"> *         -3 on invalid arguments</span>
00087 <span class="comment"> */</span>
00088 
<a name="l00089"></a><a class="code" href="gma_8c.html#a5">00089</a> <span class="keywordtype">int</span> <a class="code" href="gma_8h.html#a0">gma</a>(<span class="keywordtype">double</span> input[], <span class="keywordtype">long</span> npts, <span class="keywordtype">double</span> deltat, <a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *origRS, 
00090         <span class="keywordtype">double</span> fTaper[4], <span class="keywordtype">double</span> tTaper, <span class="keywordtype">long</span> *pPadLen, <span class="keywordtype">long</span> *pnfft, 
00091         <span class="keywordtype">double</span> spectPer[], <span class="keywordtype">int</span> nsp, <span class="keywordtype">double</span> spectDamp[], <span class="keywordtype">int</span> nsd, 
00092         <span class="keywordtype">double</span> output[], <span class="keywordtype">long</span> outBufLen, <span class="keywordtype">double</span> *work, <span class="keywordtype">double</span> *workFFT)
00093 {
00094   <span class="keyword">static</span> <a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> accRS, psaRS;
00095   <a class="code" href="struct__FACT.html">FACT</a> *pfact;
00096   <span class="keywordtype">double</span> *acc, *vel, *disp, *psa;
00097   <span class="keywordtype">double</span> *fAccR, *fAccI, *fIntR, *fIntI;
00098   <span class="keywordtype">double</span> *fPsaR, *fPsaI;
00099   <span class="keywordtype">double</span> dre, dim;   <span class="comment">/* temporary values */</span>
00100   <span class="keywordtype">double</span> delfreq, f, rnfft, tpr, accr, acci, minDamp, maxPeriod;
00101   <span class="keywordtype">long</span> flen, i, ii, retval = 0;
00102   <span class="keywordtype">long</span> nfft, nfreq, trial_nfft, psaPadLen, ntaper;
00103   <span class="keywordtype">int</span> nz, np, isd, isp, isdp;
00104   
00105   <span class="comment">/* Some handy pointers for all our arrays */</span>
00106   acc = output;
00107   vel = &amp;output[outBufLen];
00108   disp = &amp;output[outBufLen * 2];
00109   flen = outBufLen/2;
00110   fAccR = work;           
00111   fAccI = &amp;work[flen];    
00112   fIntR = &amp;work[flen * 2];  <span class="comment">/* We never use this; it is treated as zero */</span>
00113   fIntI = &amp;work[flen * 3];
00114   fPsaR = &amp;work[flen * 4];
00115   fPsaI = &amp;work[flen * 5];
00116   
00117   <span class="comment">/* Validate arguments */</span>
00118   <span class="keywordflow">if</span> (origRS == (<a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *)NULL || npts &lt; 2 || deltat &lt;= 0.0 || 
00119       fTaper == (<span class="keywordtype">double</span> *)NULL || outBufLen &lt; npts)
00120   {
00121     <span class="keywordflow">return</span> -3;
00122   }
00123   <span class="keywordflow">if</span> (fTaper[0] &gt; fTaper[1] || fTaper[1] &gt;= fTaper[2] || 
00124       fTaper[2] &gt; fTaper[3] || origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a> == 0.0 )
00125   {
00126     <span class="keywordflow">return</span> -3;
00127   }
00128   
00129   <span class="comment">/* Adjust the input response function to get ground acceleration *</span>
00130 <span class="comment">   * Input units: nanometers of displacement                       *</span>
00131 <span class="comment">   * Output units: acceleration in cm/sec/sec                      */</span>
00132 
00133   accRS.<a class="code" href="struct__ResponseStruct.html#m0">dGain</a> = 1.0 / (1.0e+7 * origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a>);
00134 
00135   accRS.<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a> = origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>; 
00136   accRS.<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a> = origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a> + 2; <span class="comment">/* Differentiate to acceleration */</span>
00137 
00138   <span class="keywordflow">if</span> ( (accRS.<a class="code" href="struct__ResponseStruct.html#m3">Poles</a> = (<a class="code" href="struct__PZNum.html">PZNum</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="struct__PZNum.html">PZNum</a>) * accRS.<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>)) == 
00139        (<a class="code" href="struct__PZNum.html">PZNum</a> *)NULL ||
00140        (accRS.<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a> = (<a class="code" href="struct__PZNum.html">PZNum</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="struct__PZNum.html">PZNum</a>) *accRS.<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>)) ==
00141        (<a class="code" href="struct__PZNum.html">PZNum</a> *)NULL)
00142   {
00143     retval = -1;
00144     <span class="keywordflow">goto</span> exit;
00145   }
00146 
00147 
00148   <span class="comment">/* Copy the poles and zeros, using structure copy */</span>
00149   np = nz = 0;
00150 
00151   <span class="keywordflow">for</span> (i = 0; i &lt; origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>; i++)
00152     accRS.<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[nz++] = origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[i];
00153 
00154   <span class="keywordflow">for</span> (i = 0; i &lt; origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>; i++)
00155     accRS.<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[np++] = origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[i];
00156 
00157   <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++)
00158   {
00159     accRS.<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[nz].<a class="code" href="struct__PZNum.html#m0">dReal</a> = 0.0;
00160     accRS.<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[nz].<a class="code" href="struct__PZNum.html#m1">dImag</a> = 0.0;
00161     nz++;
00162   }
00163   
00164   <span class="comment">/* Remove any cancelling poles and zeros */</span>
00165   <a class="code" href="transfer_8c.html#a10">pzCancel</a>(&amp;accRS, 1.0e-5);
00166   
00167   <span class="comment">/* Determine how much padding we need, unless the caller told us. */</span>
00168   <span class="keywordflow">if</span> ( *pPadLen &lt; 0)
00169   {
00170     <span class="keywordflow">if</span> ( (*pPadLen = <a class="code" href="transfer_8h.html#a10">respLen</a>( &amp;accRS, deltat, fTaper)) &lt; 0)
00171     {
00172       <span class="comment">/* Some error occured */</span>
00173       retval = *pPadLen;
00174       <span class="keywordflow">if</span> (Debug)
00175         <a class="code" href="logit_8c.html#a18">logit</a> (<span class="stringliteral">""</span>, <span class="stringliteral">"\nrespLen error: %ld\n"</span>, *pPadLen);
00176       <span class="keywordflow">goto</span> exit;
00177     }
00178 
00179     <span class="comment">/*</span>
00180 <span class="comment">     * Find the length in samples for the lightly damped PSA oscillator</span>
00181 <span class="comment">     * to decay to 1% of it's maximum: a measure of the length of its</span>
00182 <span class="comment">     * convolution filter. Use the longest period for this.</span>
00183 <span class="comment">     */</span>
00184     <span class="comment">/* Find the minumum damping and maximum period, to get the longest decay */</span>
00185     minDamp = spectDamp[0];
00186     <span class="keywordflow">for</span> (isd = 1; isd &lt; nsd; isd++)
00187       <span class="keywordflow">if</span> (minDamp &gt; spectDamp[isd]) minDamp = spectDamp[isd];
00188     maxPeriod = spectPer[0];
00189     <span class="keywordflow">for</span> (isp = 1; isp &lt; nsp; isp++)
00190       <span class="keywordflow">if</span> (maxPeriod &lt; spectPer[isp]) maxPeriod = spectPer[isp];
00191     
00192     psaPadLen = (long)( -1.0 * maxPeriod * log(0.01) / 
00193                         (minDamp * 2.0 * <a class="code" href="geo__to__km_8c.html#a0">PI</a> * deltat));
00194     <span class="keywordflow">if</span> (*pPadLen &lt; psaPadLen)
00195       *pPadLen = psaPadLen;
00196     <span class="keywordflow">if</span> (Debug)
00197       <a class="code" href="logit_8c.html#a18">logit</a> (<span class="stringliteral">""</span>, <span class="stringliteral">"estimated pad length: %ld\n"</span>, *pPadLen);
00198   }
00199 
00200   <span class="comment">/* Find a convenient FFT size for our data plus padding that will fit in</span>
00201 <span class="comment">   *  outBuf */</span>
00202   trial_nfft = *pPadLen + npts;
00203   <span class="keywordflow">while</span> ( (nfft = <a class="code" href="fft__prep_8c.html#a7">prepFFT</a>(trial_nfft, &amp;pfact)) &gt; outBufLen - <a class="code" href="fft99_8h.html#a1">FFT_EXTRA</a>)
00204   {
00205     <span class="keywordflow">if</span> (nfft &lt; 0)
00206     {
00207       <span class="comment">/* Out of memory */</span>
00208       retval = nfft;
00209       <span class="keywordflow">goto</span> exit;
00210     }
00211     trial_nfft -= 100;  <span class="comment">/* Try a liitle bit smaller */</span>
00212   }
00213 
00214   <span class="keywordflow">if</span> (nfft - *pPadLen &lt; npts)
00215     npts = nfft - *pPadLen;   <span class="comment">/* Chop some off the end if it won't fit */</span>
00216   <span class="comment">/* We aren't passing this new value of npts back to our caller; she'll</span>
00217 <span class="comment">   * have to figure it out from the values of pPadLen and nfft passed back */</span>
00218 
00219   nfreq = nfft / 2;
00220 
00221   <span class="comment">/* Copy the input data into the acc array in preparation for FFT */</span>
00222   <span class="keywordflow">for</span> (i = 0; i &lt; npts; i++)
00223     acc[i] = input[i];
00224   <span class="keywordflow">for</span> (i = npts; i &lt; nfft + <a class="code" href="fft99_8h.html#a1">FFT_EXTRA</a>; i++)  <span class="comment">/* Do the null-padding */</span>
00225     acc[i] = 0.0;
00226 
00227 
00228   <span class="comment">/* Taper the data into the zero-padded area */</span>
00229   ntaper = (long)(tTaper / deltat);
00230   <a class="code" href="transfer_8c.html#a11">taper</a>(acc, npts, ntaper);
00231 
00232   <span class="comment">/* Transform the padded data into frequency domain */</span>
00233   <a class="code" href="fft99_8c.html#a10">fft991</a>(acc, workFFT, pfact-&gt;<a class="code" href="struct__FACT.html#m2">trigs</a>, pfact-&gt;<a class="code" href="struct__FACT.html#m3">ifax</a>, 1, nfft, nfft, 1, -1);
00234 
00235   <span class="comment">/* Fill in all the transfer functions */</span>
00236   <a class="code" href="transfer_8c.html#a5">response</a>(nfft, deltat, &amp;accRS, fAccR, fAccI);
00237   <a class="code" href="gma_8c.html#a2">makeInt</a>(nfft, deltat, fIntI);
00238 
00239   <span class="comment">/* Compute acceleration, velocity and displacement output data in the </span>
00240 <span class="comment">     frequency domain */</span>
00241   rnfft = 1.0 / (2*nfft);
00242 
00243   acc[0] = 0.0;   <span class="comment">/* Remove the mean, if there is any */</span>
00244   vel[0] = 0.0;
00245   disp[0] = 0.0;
00246   acc[1] = 0.0;
00247   vel[1] = 0.0;
00248   disp[1] = 0.0;
00249   
00250   delfreq = 1.0 / (nfft * deltat);
00251   <span class="keywordflow">for</span> (i = 1; i &lt; nfreq; i++)
00252   {
00253     ii = i+i;
00254     f = i * delfreq;
00255     tpr = <a class="code" href="transfer_8c.html#a7">ftaper</a>(f, fTaper[1], fTaper[0]) * <a class="code" href="transfer_8c.html#a7">ftaper</a>(f, fTaper[2], fTaper[3]);
00256     dre = acc[ii];   <span class="comment">/* Real part of transformed data */</span>
00257     dim = acc[ii+1]; <span class="comment">/* Imaginary part of transformed data */</span>
00258     <span class="comment">/* The acceleration */</span>
00259     <span class="comment">/* WAS: scaled by 1 * rnfft */</span>
00260     accr = (dre * fAccR[i] - dim * fAccI[i]) * tpr;
00261     acci = (dre * fAccI[i] + dim * fAccR[i]) * tpr;
00262     acc[ii] = accr;
00263     acc[ii+1] = acci;
00264     <span class="comment">/* Integrate once to get velocity */</span>
00265     vel[ii] = fIntI[i] * acci;
00266     vel[ii+1] = -fIntI[i] * accr;
00267     <span class="comment">/* Integrate again to get displacement */</span>
00268     disp[ii] = -fIntI[i] * vel[ii+1];
00269     disp[ii+1] = fIntI[i] * vel[ii];
00270   }
00271   <span class="comment">/* Remove the Nyquist frequency component */</span>
00272   acc[nfft] = 0.0;
00273   vel[nfft] = 0.0;
00274   disp[nfft] = 0.0;
00275 
00276   <span class="comment">/* Compute the Spectral Responses for all their periods and dampings */</span>
00277   isdp = -1;
00278   <span class="keywordflow">for</span> (isp = 0; isp &lt; nsp; isp++)
00279   {
00280     <span class="keywordflow">for</span> (isd = 0; isd &lt; nsd; isd++)
00281     {
00282       isdp++;
00283       psa = &amp;output[outBufLen * (3 + isdp)];
00284       <span class="keywordflow">if</span> ( (retval = <a class="code" href="gma_8c.html#a3">makePsa</a>(spectPer[isp], spectDamp[isd], &amp;psaRS)) &lt; 0)
00285         <span class="keywordflow">goto</span> exit;
00286       <a class="code" href="transfer_8c.html#a5">response</a>(nfft, deltat, &amp;psaRS, fPsaR, fPsaI);
00287       
00288       psa[0] = 0.0;
00289       psa[1] = 0.0;
00290 
00291       <span class="keywordflow">for</span> (i = 1; i &lt; nfreq; i++)
00292       {
00293         ii = i+i;
00294         accr = acc[ii];
00295         acci = acc[ii+1];
00296         <span class="comment">/* The spectral response accelerations */</span>
00297         psa[ii] = accr * fPsaR[i] - acci * fPsaI[i] + accr;
00298         psa[ii+1] = accr * fPsaI[i] + acci * fPsaR[i] + acci;
00299       }
00300       <span class="comment">/* Remove the Nyquist frequency component */</span>
00301       psa[nfft] = 0.0;
00302       psa[nfft+1] = 0.0;
00303 
00304       <a class="code" href="transfer_8c.html#a13">cleanPZ</a>( &amp;psaRS );
00305     }
00306   }
00307 
00308   <span class="comment">/* Transform the whole output array back to time domain */</span>
00309   <a class="code" href="fft99_8c.html#a10">fft991</a>(output, workFFT, pfact-&gt;<a class="code" href="struct__FACT.html#m2">trigs</a>, pfact-&gt;<a class="code" href="struct__FACT.html#m3">ifax</a>, 1, outBufLen, nfft, 
00310          3 + isd * isp, +1);
00311 
00312   <span class="comment">/* We're done! Give the data back to the caller */</span>
00313   *pnfft = nfft;
00314   
00315  exit:
00316   <span class="comment">/* Clean up before we go home */</span>
00317   <a class="code" href="transfer_8c.html#a13">cleanPZ</a>( &amp;accRS );
00318   <a class="code" href="transfer_8c.html#a13">cleanPZ</a>( &amp;psaRS );
00319 
00320   <span class="keywordflow">return</span> retval;
00321 }
00322 
00323 <span class="comment">/*</span>
00324 <span class="comment"> * makeInt: make a `response' function for integrating once with respect</span>
00325 <span class="comment"> *          to time. This function is simply `i' times the frequency;</span>
00326 <span class="comment"> *          or the response function for a single zero at the origin.</span>
00327 <span class="comment"> */</span>
<a name="l00328"></a><a class="code" href="gma_8c.html#a2">00328</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="gma_8c.html#a2">makeInt</a>(<span class="keywordtype">long</span> nfft, <span class="keywordtype">double</span> deltat, <span class="keywordtype">double</span> *fIntI)
00329 {
00330   <span class="keywordtype">double</span> delomg, omega;
00331   <span class="keywordtype">long</span> i, ntr;
00332   
00333   ntr = nfft / 2;
00334   delomg = 2.0 * <a class="code" href="geo__to__km_8c.html#a0">PI</a> / (nfft * deltat);
00335 
00336   fIntI[0] = 0.0;
00337   <span class="keywordflow">for</span> (i = 1; i &lt; ntr; i++)
00338   {
00339     omega = delomg * i;
00340     fIntI[i] = 1.0 / omega;
00341   }
00342   <span class="keywordflow">return</span>;
00343 }
00344 
00345 <span class="comment">/*</span>
00346 <span class="comment"> * makePsa: Generate the acceleration response function in pole-zero-gain</span>
00347 <span class="comment"> *          form for a simple oscillator with given free period and damping.</span>
00348 <span class="comment"> */</span>
<a name="l00349"></a><a class="code" href="gma_8c.html#a3">00349</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="gma_8c.html#a3">makePsa</a>(<span class="keywordtype">double</span> period, <span class="keywordtype">double</span> damp, <a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *rs)
00350 {
00351   <span class="keywordtype">double</span> mu, omega;
00352   
00353   omega = 2.0 * <a class="code" href="geo__to__km_8c.html#a0">PI</a> / period;
00354   mu = sqrt(1.0 - damp * damp);
00355 
00356   rs-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a> = 2;
00357   rs-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a> = 2;
00358   <span class="keywordflow">if</span> ( (rs-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a> = (<a class="code" href="struct__PZNum.html">PZNum</a> *)malloc(2 * <span class="keyword">sizeof</span>(<a class="code" href="struct__PZNum.html">PZNum</a>))) == (<a class="code" href="struct__PZNum.html">PZNum</a> *)0 ||
00359        (rs-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a> = (<a class="code" href="struct__PZNum.html">PZNum</a> *)malloc(2 * <span class="keyword">sizeof</span>(<a class="code" href="struct__PZNum.html">PZNum</a>))) == (<a class="code" href="struct__PZNum.html">PZNum</a> *)0 )
00360     <span class="keywordflow">return</span> -1;
00361   
00362   rs-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[0].<a class="code" href="struct__PZNum.html#m0">dReal</a> = rs-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[0].<a class="code" href="struct__PZNum.html#m1">dImag</a> = 0.0;
00363   rs-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[1].<a class="code" href="struct__PZNum.html#m0">dReal</a> = rs-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[1].<a class="code" href="struct__PZNum.html#m1">dImag</a> = 0.0;
00364   
00365   rs-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a> = -1.0;
00366 
00367   rs-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[0].<a class="code" href="struct__PZNum.html#m0">dReal</a> = - omega * damp;
00368   rs-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[0].<a class="code" href="struct__PZNum.html#m1">dImag</a> = omega * mu;
00369   rs-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[1].<a class="code" href="struct__PZNum.html#m0">dReal</a> = - omega * damp;
00370   rs-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[1].<a class="code" href="struct__PZNum.html#m1">dImag</a> = - omega * mu;
00371   
00372   <span class="keywordflow">return</span> 0;
00373 }
00374   
<a name="l00375"></a><a class="code" href="gma_8c.html#a6">00375</a> <span class="keywordtype">void</span> <a class="code" href="gma_8c.html#a6">gmaDebug</a>( <span class="keywordtype">int</span> level )
00376 {
00377   <a class="code" href="gma_8c.html#a1">Debug</a> = level;
00378   <span class="keywordflow">return</span>;
00379 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue May 6 09:16:03 2003 for Earthworm Libs by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc3 </small></address>
</body>
</html>
