<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>transfer.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>transfer.c</h1><a href="transfer_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *   THIS FILE IS UNDER RCS - DO NOT MODIFY UNLESS YOU HAVE</span>
00003 <span class="comment"> *   CHECKED IT OUT USING THE COMMAND CHECKOUT.</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> *    $Id:</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> *    Revision history:</span>
00008 <span class="comment"> *     $Log:</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> */</span>
00013 
00014 <span class="comment">/* transfer.c: Routines for dealing with instrument transfer functions */</span>
00015 
00016 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00017 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00018 <span class="preprocessor">#include &lt;string.h&gt;</span>
00019 <span class="preprocessor">#include &lt;math.h&gt;</span>
00020 <span class="preprocessor">#include &lt;<a class="code" href="fft__prep_8h.html">fft_prep.h</a>&gt;</span>
00021 <span class="preprocessor">#include &lt;<a class="code" href="fft99_8h.html">fft99.h</a>&gt;</span>
00022 <span class="preprocessor">#include &lt;<a class="code" href="transfer_8h.html">transfer.h</a>&gt;</span>
00023 
<a name="l00024"></a><a class="code" href="transfer_8c.html#a0">00024</a> <span class="preprocessor">#define MAXLINE 80</span>
<a name="l00025"></a><a class="code" href="transfer_8c.html#a3">00025</a> <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="transfer_8c.html#a3">Debug</a> = 0;
00026 
00027 <span class="comment">/* Internal Function Prototypes */</span>
00028 <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="transfer_8c.html#a4">drop</a>(<a class="code" href="struct__PZNum.html">PZNum</a> *, <span class="keywordtype">int</span> *, <span class="keywordtype">int</span>);
00029 
00030 <span class="comment">/*</span>
00031 <span class="comment"> * response: compute frequency response from the pole-zero-gain information.</span>
00032 <span class="comment"> *  arguments:  nfft: the number of points that will be used in the FFT</span>
00033 <span class="comment"> *            deltat: the time interval between data points in the time-domain</span>
00034 <span class="comment"> *               pRS: pointer to the Response Structure holding the poles,</span>
00035 <span class="comment"> *                    zeros and gain information for the desired function</span>
00036 <span class="comment"> *               tfr: pointer to the real part of the frequency response</span>
00037 <span class="comment"> *               tfi: pointer to the imaginary part of the frequency </span>
00038 <span class="comment"> *                    response. Both tfr and tfi must be allocated</span>
00039 <span class="comment"> *                    by the caller to contain at least nfft/2+1 values.</span>
00040 <span class="comment"> */</span>
<a name="l00041"></a><a class="code" href="transfer_8c.html#a5">00041</a> <span class="keywordtype">void</span> <a class="code" href="transfer_8c.html#a5">response</a>(<span class="keywordtype">long</span> nfft, <span class="keywordtype">double</span> deltat, <a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *pRS, 
00042               <span class="keywordtype">double</span> *tfr, <span class="keywordtype">double</span> *tfi)
00043 {
00044   <span class="keywordtype">double</span> delomg, omega, mag2;
00045   <span class="keywordtype">double</span> sr, si, srn, sin, srd, sid, sr0, si0;
00046   <span class="keywordtype">long</span> i, j, ntr;
00047   
00048   ntr = nfft / 2 + 1;
00049   delomg = 2.0 * <a class="code" href="geo__to__km_8c.html#a0">PI</a> / (nfft * deltat);
00050   
00051   <span class="comment">/* The (almost) zero frequency term */</span>
00052   <span class="comment">/* The zeros, in the numerator */</span>
00053   srn = 1.0;
00054   sin = 0.0;
00055   omega = delomg * 0.001;
00056   <span class="keywordflow">for</span> (j = 0; j &lt; pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>; j++)
00057   {
00058     sr = - pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[j].<a class="code" href="struct__PZNum.html#m0">dReal</a>;
00059     si = omega - pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[j].<a class="code" href="struct__PZNum.html#m1">dImag</a>;
00060     sr0 = srn * sr - sin * si;
00061     si0 = srn * si + sin * sr;
00062     srn = sr0;
00063     sin = si0;
00064   }
00065   
00066   <span class="comment">/* The poles; in the denominator */</span>
00067   srd = 1.0;
00068   sid = 0.0;
00069   
00070   <span class="keywordflow">for</span> (j = 0; j &lt; pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>; j++)
00071   {
00072     sr = - pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[j].<a class="code" href="struct__PZNum.html#m0">dReal</a>;
00073     si = omega - pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[j].<a class="code" href="struct__PZNum.html#m1">dImag</a>;
00074     sr0 = srd * sr - sid * si;
00075     si0 = srd * si + sid * sr;
00076     srd = sr0;
00077     sid = si0;
00078   }
00079   
00080   <span class="comment">/* Combine numerator, denominator and gain using complex arithemetic */</span>
00081   mag2 = pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a> / (srd * srd + sid * sid);
00082   tfr[0] = mag2 * (srn * srd + sin * sid);
00083   tfi[0] = 0.0; <span class="comment">/* Actually the Nyqust part; we don't want it */</span>
00084   
00085   <span class="comment">/* The non-zero frequency parts */</span>
00086   <span class="keywordflow">for</span> (i = 1; i &lt; ntr; i++)
00087   {
00088     <span class="comment">/* The zeros, in the numerator */</span>
00089     srn = 1.0;
00090     sin = 0.0;
00091     omega = delomg * i;
00092     <span class="keywordflow">for</span> (j = 0; j &lt; pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>; j++)
00093     {
00094       sr = - pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[j].<a class="code" href="struct__PZNum.html#m0">dReal</a>;
00095       si = omega - pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[j].<a class="code" href="struct__PZNum.html#m1">dImag</a>;
00096       sr0 = srn * sr - sin * si;
00097       si0 = srn * si + sin * sr;
00098       srn = sr0;
00099       sin = si0;
00100     }
00101     
00102     <span class="comment">/* The poles; in the denominator */</span>
00103     srd = 1.0;
00104     sid = 0.0;
00105     
00106     <span class="keywordflow">for</span> (j = 0; j &lt; pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>; j++)
00107     {
00108       sr = - pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[j].<a class="code" href="struct__PZNum.html#m0">dReal</a>;
00109       si = omega - pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[j].<a class="code" href="struct__PZNum.html#m1">dImag</a>;
00110       sr0 = srd * sr - sid * si;
00111       si0 = srd * si + sid * sr;
00112       srd = sr0;
00113       sid = si0;
00114     }
00115     
00116     <span class="comment">/* Combine numerator, denominator and gain using complex arithemetic */</span>
00117     mag2 = pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a> / (srd * srd + sid * sid);
00118     tfr[i] = mag2 * (srn * srd + sin * sid);
00119     tfi[i] = mag2 * (sin * srd - srn * sid);
00120   }
00121   <span class="keywordflow">return</span>;
00122 }
00123 
00124 
00125 <span class="comment">/*</span>
00126 <span class="comment"> * readPZ: read a SAC-format pole-zero file.</span>
00127 <span class="comment"> * Arguments: pzfile: the name of the pole-zero file to read</span>
00128 <span class="comment"> *               pRS: pointer to the response structure to be filled in</span>
00129 <span class="comment"> *                    The calling program must allocate the ResponseStruct;</span>
00130 <span class="comment"> *                    the individual pole and zero structures will be </span>
00131 <span class="comment"> *                    allocated here.</span>
00132 <span class="comment"> *            </span>
00133 <span class="comment"> *            Pole-zero-gain files must be for input displacement in </span>
00134 <span class="comment"> *            nanometers, output in digital counts, poles and zeros of</span>
00135 <span class="comment"> *            the LaPlace transform, frequency in radians per second.</span>
00136 <span class="comment"> * returns: 0 on success</span>
00137 <span class="comment"> *         -1 on out-of-memory error</span>
00138 <span class="comment"> *         -2 if unable to read or parse the file</span>
00139 <span class="comment"> *         -3 for invalid arguments</span>
00140 <span class="comment"> *         -4 error opeing file</span>
00141 <span class="comment"> */</span>
<a name="l00142"></a><a class="code" href="transfer_8c.html#a6">00142</a> <span class="keywordtype">int</span> <a class="code" href="transfer_8c.html#a6">readPZ</a>( <span class="keywordtype">char</span> *pzfile, <a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *pRS )
00143 {
00144   FILE *pzFILE;
00145   <span class="keywordtype">int</span> retval = 0, status = 0;
00146   <span class="keywordtype">int</span> i, nz = 0, np = 0;
00147   <span class="keywordtype">char</span> line[<a class="code" href="gma_8c.html#a0">MAXLINE</a>], word[21];
00148   <span class="keyword">enum</span> states {Key, Pole, Zero};
00149   <span class="keyword">enum</span> states state = Key;
00150   
00151   <span class="keywordflow">if</span> ( pzfile == (<span class="keywordtype">char</span> *)NULL || strlen(pzfile) == 0)
00152   {
00153     <span class="comment">/* empty or missing file name */</span>
00154     <span class="keywordflow">return</span> -3;
00155   }
00156   
00157   <span class="keywordflow">if</span> ( (pzFILE = fopen(pzfile, <span class="stringliteral">"r"</span>)) == (FILE *)NULL)
00158   {
00159     <span class="comment">/* Error opening file */</span>
00160     <span class="keywordflow">return</span> -4;
00161   }
00162 
00163   <span class="keywordflow">while</span> ( fgets( line, MAXLINE, pzFILE) != (<span class="keywordtype">char</span> *)NULL)
00164   {
00165     <span class="comment">/* if (line[strlen(line)-1] == '\n')</span>
00166 <span class="comment">       line[strlen(line)-1] = '\0';*/</span>
00167     
00168     <span class="keywordflow">switch</span> (state)
00169     {
00170     <span class="keywordflow">case</span> Key:  <span class="comment">/* Looking for next keyword */</span>
00171       <span class="keywordflow">if</span> (sscanf(line, <span class="stringliteral">"%20s"</span>, word) == 0)
00172         <span class="keywordflow">continue</span>;
00173       <span class="keywordflow">if</span> ( word[0] == <span class="charliteral">'*'</span> || word[0] == <span class="charliteral">'#'</span>) <span class="keywordflow">continue</span>;  <span class="comment">/* a comment line */</span>
00174       
00175       <span class="keywordflow">if</span> ( strcmp(word, <span class="stringliteral">"CONSTANT"</span>) == 0)
00176       {
00177         <span class="keywordflow">if</span> (sscanf(line, <span class="stringliteral">"%*s %lf"</span>, &amp;pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a>) == 0 )
00178         {
00179           retval = -2;
00180           <span class="keywordflow">goto</span> abort;
00181         }
00182         status |= 1;  <span class="comment">/* Found the constant or gain */</span>
00183       }
00184       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( strcmp(word, <span class="stringliteral">"ZEROS"</span>) == 0)
00185       {
00186         <span class="keywordflow">if</span> (sscanf(line, <span class="stringliteral">"%*s %d"</span>, &amp;pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>) == 0 || pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a> &lt; 0)
00187         {
00188           <span class="comment">/* invalid or missing number after ZEROS keyword */</span>
00189           retval = -2;
00190           <span class="keywordflow">goto</span> abort;
00191         }
00192         <span class="keywordflow">if</span> (pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a> &gt; 0)
00193         {
00194           <span class="keywordflow">if</span> ( (pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a> = (<a class="code" href="struct__PZNum.html">PZNum</a> *)malloc(pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a> * <span class="keyword">sizeof</span>(<a class="code" href="struct__PZNum.html">PZNum</a>))) 
00195                == (<a class="code" href="struct__PZNum.html">PZNum</a> *)0 )
00196           {
00197             retval = -1;
00198             <span class="keywordflow">goto</span> abort;
00199           }
00200           <span class="keywordflow">for</span> (i = 0; i &lt; pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>; i++)
00201           {
00202             pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[i].<a class="code" href="struct__PZNum.html#m0">dReal</a> = 0.0;
00203             pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[i].<a class="code" href="struct__PZNum.html#m1">dImag</a> = 0.0;
00204           }
00205                     
00206           state = Zero;  <span class="comment">/* There are some zeros; go find them */</span>
00207           <span class="keywordflow">continue</span>;
00208         }
00209         status |= 2;  <span class="comment">/* Got the number of zeros: none */</span>
00210       }
00211       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( strcmp(word, <span class="stringliteral">"POLES"</span>) == 0)
00212       {
00213         <span class="keywordflow">if</span> (sscanf(line, <span class="stringliteral">"%*s %d"</span>, &amp;pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>) == 0 || pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a> &lt; 0)
00214         {
00215           <span class="comment">/* invalid or missing number after POLES keyword */</span>
00216           retval = -2;
00217           <span class="keywordflow">goto</span> abort;
00218         }
00219         <span class="keywordflow">if</span> (pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a> &gt; 0)
00220         {
00221           <span class="keywordflow">if</span> ( (pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a> = (<a class="code" href="struct__PZNum.html">PZNum</a> *)malloc(pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a> * <span class="keyword">sizeof</span>(<a class="code" href="struct__PZNum.html">PZNum</a>))) 
00222                == (<a class="code" href="struct__PZNum.html">PZNum</a> *)0 )
00223           {
00224             retval = -1;
00225             <span class="keywordflow">goto</span> abort;
00226           }
00227           <span class="keywordflow">for</span> (i = 0; i &lt; pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>; i++)
00228           {
00229             pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[i].<a class="code" href="struct__PZNum.html#m0">dReal</a> = 0.0;
00230             pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[i].<a class="code" href="struct__PZNum.html#m1">dImag</a> = 0.0;
00231           }
00232           
00233           state = Pole;  <span class="comment">/* There are some poles; go find them */</span>
00234           <span class="keywordflow">continue</span>;
00235         }
00236         status |= 4;  <span class="comment">/* Got the number of poles: none */</span>
00237       }
00238       <span class="keywordflow">else</span>
00239       {
00240         <span class="comment">/* Invalid keyword */</span>
00241         retval = -2;
00242         <span class="keywordflow">goto</span> abort;
00243       }
00244       <span class="keywordflow">break</span>;
00245     <span class="keywordflow">case</span> Zero:
00246       <span class="comment">/* Looking for Zeros */</span>
00247       <span class="keywordflow">if</span> (nz &gt;= pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>)
00248       {
00249         <span class="comment">/* Too many zeros! */</span>
00250         retval = -2;
00251         <span class="keywordflow">goto</span> abort;
00252       }
00253       <span class="keywordflow">if</span> (sscanf(line, <span class="stringliteral">"%lf %lf"</span>, 
00254                  &amp;pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[nz].<a class="code" href="struct__PZNum.html#m0">dReal</a>, &amp;pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[nz].<a class="code" href="struct__PZNum.html#m1">dImag</a>) != 2)
00255       {
00256         <span class="comment">/* Couldn't read a line of zeros */</span>
00257         retval = -2;
00258         <span class="keywordflow">goto</span> abort;
00259       }
00260       <span class="keywordflow">if</span> (++nz == pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>)
00261       {
00262         <span class="comment">/* Found all the zeros we expected */</span>
00263         status |= 2;
00264         state = Key;
00265         <span class="keywordflow">continue</span>;
00266       }
00267       <span class="keywordflow">break</span>;
00268     <span class="keywordflow">case</span> Pole:
00269       <span class="comment">/* Looking for poles */</span>
00270       <span class="keywordflow">if</span> (np &gt;= pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>)
00271       {
00272         <span class="comment">/* Too many poles! */</span>
00273         retval = -2;
00274         <span class="keywordflow">goto</span> abort;
00275       }
00276       <span class="keywordflow">if</span> (sscanf(line, <span class="stringliteral">"%lf %lf"</span>, 
00277                  &amp;pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[np].<a class="code" href="struct__PZNum.html#m0">dReal</a>, &amp;pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[np].<a class="code" href="struct__PZNum.html#m1">dImag</a>) != 2)
00278       {
00279         <span class="comment">/* Couldn't read a line of poles */</span>
00280         retval = -2;
00281         <span class="keywordflow">goto</span> abort;
00282       }
00283       <span class="keywordflow">if</span> (++np == pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>)
00284       {
00285         <span class="comment">/* Found all the poles we expected */</span>
00286         status |= 4;
00287         state = Key;
00288         <span class="keywordflow">continue</span>;
00289       }
00290       <span class="keywordflow">break</span>;
00291     }
00292   }
00293 
00294   <span class="keywordflow">if</span> (status != 7)
00295   {
00296     <span class="comment">/* One of the keywords was missing */</span>
00297     retval = -2;
00298   }
00299   
00300  abort:
00301   <span class="keywordflow">if</span> (retval != 0)
00302   {
00303     <span class="comment">/* Something went wrong; clean up the mess */</span>
00304     <a class="code" href="transfer_8c.html#a13">cleanPZ</a>(pRS);
00305   }
00306   fclose(pzFILE);
00307   
00308   <span class="keywordflow">return</span> retval;
00309 }
00310 
00311 
00312 <span class="comment">/*</span>
00313 <span class="comment"> * ftaper: produce a cosine taper between unity (beyond fon) and zero</span>
00314 <span class="comment"> *        (beyond foff). The cosine taper is between fon and foff.</span>
00315 <span class="comment"> * Arguments: freq: the frequency at which the taper value is desired</span>
00316 <span class="comment"> *             fon: the unity end of the taper</span>
00317 <span class="comment"> *            foff: the zero end of the taper</span>
00318 <span class="comment"> *    if fon and foff are equal, then taper returns 1.0, the all-pass filter.</span>
00319 <span class="comment"> * returns: the value of the taper</span>
00320 <span class="comment"> */</span>
<a name="l00321"></a><a class="code" href="transfer_8c.html#a7">00321</a> <span class="keywordtype">double</span> <a class="code" href="transfer_8c.html#a7">ftaper</a>(<span class="keywordtype">double</span> freq, <span class="keywordtype">double</span> fon, <span class="keywordtype">double</span> foff)
00322 {
00323   <span class="keywordtype">double</span> t, pi = <a class="code" href="geo__to__km_8c.html#a0">PI</a>;
00324   
00325   <span class="keywordflow">if</span> (fon &gt; foff)
00326   {   <span class="comment">/* high-pass taper */</span>
00327     <span class="keywordflow">if</span> (freq &lt; foff)
00328       t = 0.0;
00329     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (freq &gt; fon)
00330       t = 1.0;
00331     <span class="keywordflow">else</span>
00332       t = 0.5 * (1.0 - cos(pi * (freq - foff) / (fon - foff)));
00333   }
00334   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fon &lt; foff)
00335   {   <span class="comment">/* low-pass case */</span>
00336     <span class="keywordflow">if</span> (freq &lt; fon)
00337       t = 1.0;
00338     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (freq &gt; foff)
00339       t = 0.0;
00340     <span class="keywordflow">else</span>
00341       t = 0.5 * (1.0 + cos(pi * (freq - fon) / (foff - fon)));
00342   }
00343   <span class="keywordflow">else</span>
00344     t = 1.0;
00345   
00346   <span class="keywordflow">return</span> t;
00347 }
00348 
00349 <span class="comment">/*</span>
00350 <span class="comment"> * convertWave: converts a waveform (time series) from its original response</span>
00351 <span class="comment"> *              function to a new response function. This conversion is done</span>
00352 <span class="comment"> *              in the frequency domain. The frequency response of the </span>
00353 <span class="comment"> *              transfer function may be tapered. The input data will be</span>
00354 <span class="comment"> *              padded in the time-domain. The amount of padding is determined</span>
00355 <span class="comment"> *              automatically unless the user provides her own pad length.</span>
00356 <span class="comment"> * Arguments: input: array of data for preocessing</span>
00357 <span class="comment"> *             npts: number of data points to process</span>
00358 <span class="comment"> *           deltat: time interval between samples, in seconds</span>
00359 <span class="comment"> *           origRS: structure defining process that generated the input data</span>
00360 <span class="comment"> *                   that is, the response function to be removed</span>
00361 <span class="comment"> *          finalRS: structure defining desired response function</span>
00362 <span class="comment"> *             freq: array of four frequencies (f0, f1, f2, f3) defining the</span>
00363 <span class="comment"> *                   taper to be applied to the frequency response function</span>
00364 <span class="comment"> *                   before it is convolved with the data. Below f0 and above</span>
00365 <span class="comment"> *                   f3, the taper is 0; between f2 and f3 the taper is 1;</span>
00366 <span class="comment"> *                   between f0-f1 and f2-f3 is a cosine taper.</span>
00367 <span class="comment"> *            retFD: flag to return result in frequency-domain (if retFD == 1)</span>
00368 <span class="comment"> *                   or in time-domain (if retFD == 0)</span>
00369 <span class="comment"> *                   If the output is to stay in the frequency domain,</span>
00370 <span class="comment"> *                   be sure you understand how the results are laid out. </span>
00371 <span class="comment"> *                   See the comments in the FFT package: currently sing.c</span>
00372 <span class="comment"> *           padlen: The pad length to be applied to data before transforming</span>
00373 <span class="comment"> *                   to frequency domain. If padlen &lt; 0, pad length will be</span>
00374 <span class="comment"> *                   estimated here and the value chosen will be returned</span>
00375 <span class="comment"> *                   in this return-value parameter.</span>
00376 <span class="comment"> *             nfft: The size of the FFT chosen, based on npts + *padlen</span>
00377 <span class="comment"> *                   If the returned value of nfft + padlen is less than</span>
00378 <span class="comment"> *                   npts, then convertWave had to effectively truncate the </span>
00379 <span class="comment"> *                   raw trace in order to fit the processed trace in</span>
00380 <span class="comment"> *                   the limit of outBufLen.</span>
00381 <span class="comment"> *           output: array of values output from the conversion</span>
00382 <span class="comment"> *                   This array must be allocated by the caller. </span>
00383 <span class="comment"> *        outBufLen: size of `output' array.</span>
00384 <span class="comment"> *             work: a work array that must be allocated by the caller.</span>
00385 <span class="comment"> *                   Its size must be outBufLen+2</span>
00386 <span class="comment"> *          workFFT: a work array needed by fft99. </span>
00387 <span class="comment"> *                   Its size must be outBufLen+1</span>
00388 <span class="comment"> *</span>
00389 <span class="comment"> * Returns: 0 on success</span>
00390 <span class="comment"> *         -1 on out-of-memory errors                   </span>
00391 <span class="comment"> *         -2 on too-small impulse response</span>
00392 <span class="comment"> *         -3 on invalid arguments</span>
00393 <span class="comment"> *         -4 on FFT error</span>
00394 <span class="comment"> */</span>
00395 
<a name="l00396"></a><a class="code" href="transfer_8c.html#a8">00396</a> <span class="keywordtype">int</span> <a class="code" href="transfer_8h.html#a9">convertWave</a>(<span class="keywordtype">double</span> input[], <span class="keywordtype">long</span> npts, <span class="keywordtype">double</span> deltat, 
00397                 <a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *origRS, <a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *finalRS, 
00398                 <span class="keywordtype">double</span> freq[4], <span class="keywordtype">int</span> retFD, <span class="keywordtype">long</span> *pPadLen, <span class="keywordtype">long</span> *pnfft, 
00399                 <span class="keywordtype">double</span> output[], <span class="keywordtype">long</span> outBufLen, <span class="keywordtype">double</span> *work, <span class="keywordtype">double</span> *workFFT)
00400 {
00401   <a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> rs;  <span class="comment">/* the combined response function */</span>
00402   <a class="code" href="struct__FACT.html">FACT</a> *pfact;
00403   <span class="keywordtype">long</span> i, ii, retval = 0;
00404   <span class="keywordtype">int</span> nz = 0, np = 0;
00405   <span class="keywordtype">long</span> nfft, nfreq, trial_nfft;
00406   <span class="keywordtype">double</span> delfreq, tpr, dre, dim, f, delomg, omega;
00407   <span class="keywordtype">double</span> *fre, *fim;
00408   
00409   <span class="comment">/* Validate arguments */</span>
00410   <span class="keywordflow">if</span> (origRS == (<a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *)NULL || finalRS == (<a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *)NULL ||
00411       npts &lt; 2 || deltat &lt;= 0.0 || freq == (<span class="keywordtype">double</span> *)NULL || outBufLen &lt; npts)
00412   {
00413     <span class="keywordflow">return</span> -3;
00414   }
00415   <span class="keywordflow">if</span> (freq[0] &gt; freq[1] || freq[1] &gt;= freq[2] || freq[2] &gt; freq[3] ||
00416       origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a> == 0.0 || finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a> == 0.0)
00417   {
00418     <span class="keywordflow">return</span> -3;
00419   }
00420   
00421 
00422   <span class="comment">/* Combine the response functions into one: finalRS / origRS */</span>
00423   rs.<a class="code" href="struct__ResponseStruct.html#m0">dGain</a> = finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a> / origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a>;
00424   rs.<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a> = finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a> + origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>;
00425   rs.<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a> = finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a> + origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>;
00426   <span class="keywordflow">if</span> ( (rs.<a class="code" href="struct__ResponseStruct.html#m3">Poles</a> = (<a class="code" href="struct__PZNum.html">PZNum</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="struct__PZNum.html">PZNum</a>) * rs.<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>)) == 
00427        (<a class="code" href="struct__PZNum.html">PZNum</a> *)NULL ||
00428        (rs.<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a> = (<a class="code" href="struct__PZNum.html">PZNum</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code" href="struct__PZNum.html">PZNum</a>) *rs.<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>)) ==
00429        (<a class="code" href="struct__PZNum.html">PZNum</a> *)NULL)
00430   {
00431     retval = -1;
00432     <span class="keywordflow">goto</span> exit;
00433   }
00434   <span class="comment">/* Copy the poles and zeros, using structure copy */</span>
00435   <span class="keywordflow">for</span> (i = 0; i &lt; origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>; i++)
00436     rs.<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[nz++] = origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[i];
00437   <span class="keywordflow">for</span> (i = 0; i &lt; origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>; i++)
00438     rs.<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[np++] = origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[i];
00439   <span class="keywordflow">for</span> (i = 0; i &lt; finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>; i++)
00440     rs.<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[np++] = finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[i];
00441   <span class="keywordflow">for</span> (i = 0; i &lt; finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>; i++)
00442     rs.<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[nz++] = finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[i];
00443   
00444   <span class="keywordflow">if</span> (<a class="code" href="transfer_8c.html#a3">Debug</a> &amp; <a class="code" href="transfer_8h.html#a0">TR_DBG_PZG</a>)
00445   {
00446     printf(<span class="stringliteral">"Input response function: gain %10.3e\n"</span>, origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a>);
00447     printf(<span class="stringliteral">"Poles: %d\n"</span>, origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>);
00448     <span class="keywordflow">for</span> (i = 0; i &lt; origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>; i++)
00449       printf(<span class="stringliteral">"%10.3e   %10.3e\n"</span>, origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[i].<a class="code" href="struct__PZNum.html#m0">dReal</a>, 
00450              origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[i].<a class="code" href="struct__PZNum.html#m1">dImag</a>);
00451     printf(<span class="stringliteral">"\nZeros: %d\n"</span>, origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>);
00452     <span class="keywordflow">for</span> (i = 0; i &lt; origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>; i++)
00453       printf(<span class="stringliteral">"%10.3e   %10.3e\n"</span>, origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[i].<a class="code" href="struct__PZNum.html#m0">dReal</a>, 
00454              origRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[i].<a class="code" href="struct__PZNum.html#m1">dImag</a>);
00455     printf(<span class="stringliteral">"\nOutput response function: gain %10.3e\n"</span>, finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a>);
00456     printf(<span class="stringliteral">"Poles: %d\n"</span>, finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>);
00457     <span class="keywordflow">for</span> (i = 0; i &lt; finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>; i++)
00458       printf(<span class="stringliteral">"%10.3e   %10.3e\n"</span>, finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[i].<a class="code" href="struct__PZNum.html#m0">dReal</a>, 
00459              finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[i].<a class="code" href="struct__PZNum.html#m1">dImag</a>);
00460     printf(<span class="stringliteral">"\nZeros: %d\n"</span>, finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>);
00461     <span class="keywordflow">for</span> (i = 0; i &lt; finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>; i++)
00462       printf(<span class="stringliteral">"%10.3e   %10.3e\n"</span>, finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[i].<a class="code" href="struct__PZNum.html#m0">dReal</a>, 
00463              finalRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[i].<a class="code" href="struct__PZNum.html#m1">dImag</a>);
00464   }
00465 
00466   <span class="comment">/* Determine how much padding we need, unless the caller told us. */</span>
00467   <span class="keywordflow">if</span> ( *pPadLen &lt; 0)
00468   {
00469     <span class="keywordflow">if</span> ( (*pPadLen = <a class="code" href="transfer_8h.html#a10">respLen</a>( &amp;rs, deltat, freq)) &lt; 0)
00470     {
00471       <span class="comment">/* Some error occured */</span>
00472       retval = *pPadLen;
00473       <span class="keywordflow">if</span> (Debug)
00474         printf(<span class="stringliteral">"\nrespLen error: %ld\n"</span>, *pPadLen);
00475       <span class="keywordflow">goto</span> exit;
00476     }
00477     <span class="keywordflow">if</span> (Debug)
00478       printf(<span class="stringliteral">"estimated pad length: %ld\n"</span>, *pPadLen);
00479   }
00480   
00481   <span class="comment">/* Find a convenient FFT size for our data plus padding that will fit in</span>
00482 <span class="comment">   *  outBuf */</span>
00483   trial_nfft = *pPadLen + npts;
00484   <span class="keywordflow">while</span> ( (nfft = <a class="code" href="fft__prep_8c.html#a7">prepFFT</a>(trial_nfft, &amp;pfact)) &gt; outBufLen)
00485   {
00486     <span class="keywordflow">if</span> (nfft &lt; 0)
00487     {
00488       <span class="comment">/* Out of memory */</span>
00489       retval = nfft;
00490       <span class="keywordflow">goto</span> exit;
00491     }
00492     trial_nfft -= 100;  <span class="comment">/* Try a liitle bit smaller */</span>
00493   }
00494   <span class="keywordflow">if</span> (nfft - *pPadLen &lt; npts)
00495     npts = nfft - *pPadLen;   <span class="comment">/* Chop some off the end if it won't fit */</span>
00496   <span class="comment">/* We aren't passing this new value of npts back to our caller; she'll</span>
00497 <span class="comment">   * have to figure it out from the values of pPadLen and nfft passed back */</span>
00498 
00499   nfreq = nfft / 2 + 1;
00500   fre = work;
00501   fim = work + 1 + outBufLen/2;
00502 
00503   <span class="keywordflow">for</span> (i = 0; i &lt; npts; i++)
00504     output[i] = input[i];
00505   <span class="comment">/* Fill the remainder of output buffer with zeros.                 *</span>
00506 <span class="comment">   * For fft99, we must fill two slots past the normal end of output *</span>
00507 <span class="comment">   * buffer; this space must be allocated in initBufs().             */</span>
00508   <span class="keywordflow">for</span> (i = outBufLen + <a class="code" href="fft99_8h.html#a1">FFT_EXTRA</a>; i &lt; nfft; i++)
00509     output[i] = 0.0;
00510   
00511   <span class="comment">/* Transform the padded data into frequency domain */</span>
00512   <a class="code" href="fft99_8c.html#a10">fft991</a>(output, workFFT, pfact-&gt;<a class="code" href="struct__FACT.html#m2">trigs</a>, pfact-&gt;<a class="code" href="struct__FACT.html#m3">ifax</a>, 1, nfft, nfft, 1, -1);
00513 
00514   <a class="code" href="transfer_8c.html#a5">response</a>(nfft, deltat, &amp;rs, fre, fim);
00515   
00516   <span class="comment">/* Convolve the tapered frequency response with the data. Since we  *</span>
00517 <span class="comment">   * are in the frequency domain, convolution becomes `multiply'.     *</span>
00518 <span class="comment">   * We skip the zero-frequency part; this only affects the mean      *</span>
00519 <span class="comment">   * of the data, which should have been removed long ago.            */</span>
00520   delfreq = 1.0 / (nfft * deltat);
00521   output[0] = 0.0;   <span class="comment">/* Remove the mean, if there is any */</span>
00522   <span class="keywordflow">for</span> (i = 1; i &lt; nfreq - 1; i++)
00523   {
00524     ii = i+i;
00525     f = i * delfreq;
00526     tpr = <a class="code" href="transfer_8c.html#a7">ftaper</a>(f, freq[1], freq[0]) * <a class="code" href="transfer_8c.html#a7">ftaper</a>(f, freq[2], freq[3]);
00527     dre = output[ii];   <span class="comment">/* Real part of transformed data */</span>
00528     dim = output[ii+1]; <span class="comment">/* Imaginary part of transformed data */</span>
00529     output[ii] = (dre * fre[i] - dim * fim[i]) * tpr;
00530     output[ii+1] = (dre * fim[i] + dim * fre[i]) * tpr;
00531   }
00532   f = i * delfreq;
00533   tpr = <a class="code" href="transfer_8c.html#a7">ftaper</a>(f, freq[1], freq[0]) * <a class="code" href="transfer_8c.html#a7">ftaper</a>(f, freq[2], freq[3]);
00534   dre = output[nfft];  <span class="comment">/* Real part of transformed data; imaginary part is 0 */</span>
00535   output[nfft] = dre * fre[i] * tpr;
00536 
00537   <span class="keywordflow">if</span> (<a class="code" href="transfer_8c.html#a3">Debug</a> &amp; <a class="code" href="transfer_8h.html#a2">TR_DBG_ARS</a>)
00538   {
00539     delomg = 2.0 * <a class="code" href="geo__to__km_8c.html#a0">PI</a> / (nfft * deltat);
00540     printf(<span class="stringliteral">"    omega        tapered\n"</span>);
00541     printf(<span class="stringliteral">"%4ld  %10.3e  %10.3e  %10.3e\n"</span>, 0L, 0.0, 0.0, 0.0);
00542     <span class="keywordflow">for</span> (i = 1; i &lt; nfreq - 1; i++ )
00543     {
00544       omega = i * delomg;
00545       printf(<span class="stringliteral">"%4ld  %10.3e  %10.3e  %10.3e\n"</span>, i, omega, fre[i], fim[i]);
00546     }
00547   }
00548   
00549   <span class="comment">/* If the user wants data in the time domain, transform it now */</span>
00550   <span class="keywordflow">if</span> (!retFD)
00551     <a class="code" href="fft99_8c.html#a10">fft991</a>(output, workFFT, pfact-&gt;<a class="code" href="struct__FACT.html#m2">trigs</a>, pfact-&gt;<a class="code" href="struct__FACT.html#m3">ifax</a>, 1, nfft, nfft, 1, +1);
00552 
00553   <span class="comment">/* We're done! Give the data back to the caller */</span>
00554   *pnfft = nfft;
00555 
00556   exit:
00557     <span class="comment">/* Clean up before we quit: free any memory that was allocated */</span>
00558   <a class="code" href="transfer_8c.html#a13">cleanPZ</a>( &amp;rs );
00559   <span class="keywordflow">return</span> retval;
00560 }
00561 
00562 <span class="comment">/* NFFT_TEST is the size of the iFFT used for estimated the pad length. *</span>
00563 <span class="comment"> * The value of NFFT_TEST MUST be a multiple of 2, 3, and/or 5.         */</span>
<a name="l00564"></a><a class="code" href="transfer_8c.html#a1">00564</a> <span class="preprocessor">#define NFFT_TEST 1024</span>
00565 <span class="preprocessor"></span><span class="comment">/*</span>
00566 <span class="comment"> * ALIAS_CUTOFF is the fraction of the maximum of the impulse response</span>
00567 <span class="comment"> * function used for testing pad length. The length (in points) of the</span>
00568 <span class="comment"> * impulse response that is above this threshold is the pad length</span>
00569 <span class="comment"> */</span>
<a name="l00570"></a><a class="code" href="transfer_8c.html#a2">00570</a> <span class="preprocessor">#define ALIAS_CUTOFF 0.01</span>
00571 <span class="preprocessor"></span>
00572 <span class="comment">/*</span>
00573 <span class="comment"> * respLen: estimate the length of the impulse response (the number of</span>
00574 <span class="comment"> *          points where it is greater than some throshold) so we know</span>
00575 <span class="comment"> *          how much padding we need for the convolution.      </span>
00576 <span class="comment"> *          This is a trial algorithm that may or may not work.</span>
00577 <span class="comment"> *          We assume the the impulse response looks something like a</span>
00578 <span class="comment"> *          broadened and shifted impulse. We asssume that the width of</span>
00579 <span class="comment"> *          its peak is independent of the number of points used in</span>
00580 <span class="comment"> *          this trial FFT, as long as the peak isn't too broad.  </span>
00581 <span class="comment"> *  Returns: the length of the peak (in data points) on success</span>
00582 <span class="comment"> *           NFFT_TEST when impulse response never drops below threshold</span>
00583 <span class="comment"> *          -1 when out of memory</span>
00584 <span class="comment"> *          -2 when impulse response is too small to analyze</span>
00585 <span class="comment"> *          -4 on FFT failure</span>
00586 <span class="comment"> *          -NFFT_TEST when search tp left of peak finds drop-off</span>
00587 <span class="comment"> *           but search to right doesn't find drop-off: logic error.</span>
00588 <span class="comment"> *    Exits if NFFT_TEST is not a multiple of powers of 2, 3, 5</span>
00589 <span class="comment"> *          That would be a coding error only.</span>
00590 <span class="comment"> */</span>
<a name="l00591"></a><a class="code" href="transfer_8c.html#a9">00591</a> <span class="keywordtype">int</span> <a class="code" href="transfer_8h.html#a10">respLen</a>( <a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *rs, <span class="keywordtype">double</span> deltat, <span class="keywordtype">double</span> freq[4])
00592 {
00593   <a class="code" href="struct__FACT.html">FACT</a> *pfact;
00594   <span class="keywordtype">double</span> fre[<a class="code" href="transfer_8c.html#a1">NFFT_TEST</a>/2+1], fim[<a class="code" href="transfer_8c.html#a1">NFFT_TEST</a>/2+1], data[<a class="code" href="transfer_8c.html#a1">NFFT_TEST</a> + 2];
00595   <span class="keywordtype">double</span> work[<a class="code" href="transfer_8c.html#a1">NFFT_TEST</a>+1];
00596   <span class="keywordtype">long</span> i, ii, nf_test, nfreq;
00597   <span class="keywordtype">double</span> imp_max, thresh, delfreq, f, tpr, delomg, omega;
00598   <span class="keywordtype">long</span> imax, left_lim, right_lim;
00599   
00600   <span class="comment">/*</span>
00601 <span class="comment">   * Determine how much padding we need.</span>
00602 <span class="comment">   * We do this by computing the frequency response for a small number of</span>
00603 <span class="comment">   * points, getting the impulse response (iFFT of freq. response),</span>
00604 <span class="comment">   * and measuring the length the non-zero part of the response.</span>
00605 <span class="comment">   */</span>
00606   <span class="keywordflow">if</span> ( (nf_test = <a class="code" href="fft__prep_8c.html#a7">prepFFT</a>( NFFT_TEST, &amp;pfact)) &lt; 0)
00607   {
00608     <span class="comment">/* Out of memory */</span>
00609     <span class="keywordflow">return</span> -1;
00610   }
00611   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nf_test != <a class="code" href="transfer_8c.html#a1">NFFT_TEST</a>)
00612   {
00613     fprintf(stderr, <span class="stringliteral">"respLen fatal error: NFFT_TEST (%d) not factorable by 2, 3, 5\n"</span>,
00614             NFFT_TEST);
00615     <span class="keywordflow">return</span> -1;
00616   }
00617   nfreq = nf_test/2+1;
00618   
00619   <a class="code" href="transfer_8c.html#a5">response</a>(nf_test, deltat, rs, fre, fim);
00620   
00621   delfreq = 1.0 / (nf_test * deltat);
00622 
00623   <span class="keywordflow">if</span> (<a class="code" href="transfer_8c.html#a3">Debug</a> &amp; <a class="code" href="transfer_8h.html#a1">TR_DBG_TRS</a>)
00624   {   <span class="comment">/* Print the values while they are available */</span>
00625     delomg = 2.0 * <a class="code" href="geo__to__km_8c.html#a0">PI</a> / (nf_test * deltat);
00626     printf(<span class="stringliteral">"\nTest response function in Frequency Domain\n"</span>);
00627     printf(<span class="stringliteral">"  i      omega             raw                   tapered\n"</span>);
00628     f = 0.0;
00629     tpr = <a class="code" href="transfer_8c.html#a7">ftaper</a>(f, freq[1], freq[0]);
00630     data[0] = fre[0] * tpr;
00631     data[1] = 0.0;
00632     omega = 0.001 * delomg;
00633     printf(<span class="stringliteral">"%4ld  %10.3e  %10.3e  %10.3e  %10.3e  %10.3e\n"</span>, 0L, omega, fre[0],
00634            0.0, data[0], 0.0);
00635     <span class="keywordflow">for</span> (i = 1; i &lt; nfreq - 1; i++ )
00636     {
00637       ii = i+i;
00638       f = i * delfreq;
00639       tpr = <a class="code" href="transfer_8c.html#a7">ftaper</a>(f, freq[1], freq[0]) * <a class="code" href="transfer_8c.html#a7">ftaper</a>(f, freq[2], freq[3]);
00640       data[ii] = fre[i] * tpr;
00641       data[ii+1] = fim[i] * tpr;
00642       omega = i * delomg;
00643       printf(<span class="stringliteral">"%4ld  %10.3e  %10.3e  %10.3e  %10.3e  %10.3e\n"</span>, i, omega, 
00644              fre[i], fim[i], data[ii], data[ii+1]);
00645     }
00646     data[nf_test] = 0.0;
00647     data[nf_test+1] = 0.0;
00648   }
00649   <span class="keywordflow">else</span>
00650   {  <span class="comment">/* Don't print, just calculate quickly with no /if/ inside the loops */</span>
00651     f = 0.0;
00652     tpr = <a class="code" href="transfer_8c.html#a7">ftaper</a>(f, freq[1], freq[0]);
00653     data[0] = fre[0] * tpr;
00654     data[1] = 0.0;
00655     <span class="keywordflow">for</span> (i = 1; i &lt; nfreq - 1; i++ )
00656     {
00657       ii = i+i;
00658       f = i * delfreq;
00659       tpr = <a class="code" href="transfer_8c.html#a7">ftaper</a>(f, freq[1], freq[0]) * <a class="code" href="transfer_8c.html#a7">ftaper</a>(f, freq[2], freq[3]);
00660       data[ii] = fre[i] * tpr;
00661       data[ii+1] = fim[i] * tpr;
00662     }
00663     data[nf_test] = 0.0;
00664     data[nf_test+1] = 0.0;
00665   }
00666   
00667   <span class="comment">/* Transform test response function into time domain */</span>
00668   <a class="code" href="fft99_8c.html#a10">fft991</a>(data, work, pfact-&gt;<a class="code" href="struct__FACT.html#m2">trigs</a>, pfact-&gt;<a class="code" href="struct__FACT.html#m3">ifax</a>, 1, nf_test, nf_test, 1, +1);
00669 
00670   
00671   <span class="keywordflow">if</span> (<a class="code" href="transfer_8c.html#a3">Debug</a> &amp; <a class="code" href="transfer_8h.html#a1">TR_DBG_TRS</a>)
00672   {
00673     printf(<span class="stringliteral">"\nTest response function in TD\n"</span>);
00674     <span class="keywordflow">for</span> (i = 0; i &lt; nf_test; i++)
00675     {
00676       printf(<span class="stringliteral">"%5ld  %10.3e\n"</span>, i, data[i]);
00677     }
00678   }
00679  
00680   <span class="comment">/*</span>
00681 <span class="comment">   * We assume that the impulse response has a peak somewhere and </span>
00682 <span class="comment">   * falls off on both sides of that peak, allowing for wrap-around.</span>
00683 <span class="comment">   * So we locate the peak and set a threshold of ALIAS_CUTOFF (currently 1%)</span>
00684 <span class="comment">   * of the peak. If the response does not drop off below this threshold</span>
00685 <span class="comment">   * for any values of i, then we're screwed. Some other measure will have</span>
00686 <span class="comment">   * to be dreamed for preventing time-domain aliasing in our convolution.</span>
00687 <span class="comment">   */</span>
00688   imp_max = 0.0;
00689   <span class="keywordflow">for</span> (i = 0; i &lt; nf_test; i++)
00690   {
00691     <span class="keywordflow">if</span> (fabs(data[i]) &gt; imp_max)
00692     {
00693       imp_max = fabs(data[i]);  <span class="comment">/* the extremal value */</span>
00694       imax = i;                 <span class="comment">/* the location of the extremum */</span>
00695     }
00696   }
00697   
00698   <span class="keywordflow">if</span> (imp_max &gt; 0.001 * rs-&gt;<a class="code" href="struct__ResponseStruct.html#m0">dGain</a>)
00699   {   <span class="comment">/* make sure the response isn't too small to measure */</span>
00700     thresh = imp_max * <a class="code" href="transfer_8c.html#a2">ALIAS_CUTOFF</a>;
00701     <span class="comment">/* Start searching to the left from the peak to find where we drop   *</span>
00702 <span class="comment">     * below the threshold. This point will be left_lim; we may have to  *</span>
00703 <span class="comment">     * wrap the search around to the right end. If this earch continues  *</span>
00704 <span class="comment">     * all the way back to the peak, then the peak is too broad and this *</span>
00705 <span class="comment">     * algorithm fails.                                                  */</span>
00706     right_lim = left_lim = imax;
00707     <span class="keywordflow">for</span> (i = imax; i &gt;= 0; i--)
00708     {
00709       <span class="keywordflow">if</span> ( fabs(data[i]) &lt; thresh)
00710       {
00711         left_lim = i;
00712         <span class="keywordflow">break</span>;
00713       }
00714     }
00715     <span class="keywordflow">if</span> (left_lim == imax) <span class="comment">/* Didn't find it; wrap around */</span>
00716     {
00717       <span class="keywordflow">for</span> (i = nf_test - 1; i &gt; imax; i--)
00718       {
00719         <span class="keywordflow">if</span> ( fabs(data[i]) &lt; thresh)
00720         {
00721           left_lim = i;
00722           <span class="keywordflow">break</span>;
00723         }
00724       }
00725       <span class="keywordflow">if</span> (left_lim == imax)
00726       {   <span class="comment">/* Still didn't find it; peak doesn't drop of anywhere */</span>
00727         <span class="keywordflow">return</span> <a class="code" href="transfer_8c.html#a1">NFFT_TEST</a>;
00728       }
00729     }
00730     <span class="comment">/* Now search to the right for right_lim; may have to wrap around */</span>
00731     <span class="keywordflow">for</span> (i = imax; i &lt; nf_test; i++)
00732     {
00733       <span class="keywordflow">if</span> ( fabs(data[i]) &lt; thresh)
00734       {
00735         right_lim = i;
00736         <span class="keywordflow">break</span>;
00737       }
00738     }
00739     <span class="keywordflow">if</span> (right_lim == imax)
00740     {  <span class="comment">/* Didn't find it; wrap around to the left side */</span>
00741       <span class="keywordflow">for</span> (i = 0; i &lt; imax; i++)
00742       {
00743         <span class="keywordflow">if</span> ( fabs(data[i]) &lt; thresh)
00744         {
00745           right_lim = i;
00746           <span class="keywordflow">break</span>;
00747         }
00748       }
00749       <span class="keywordflow">if</span> (right_lim == imax)
00750       {   <span class="comment">/* How come we found left_lim but not right_lim: shouldn't happen! */</span>
00751         <span class="keywordflow">return</span> -<a class="code" href="transfer_8c.html#a1">NFFT_TEST</a>;
00752       }
00753     }
00754     <span class="keywordflow">if</span> (left_lim &lt; right_lim)
00755       <span class="keywordflow">return</span> (right_lim - left_lim + 1);
00756     <span class="keywordflow">else</span>
00757       <span class="keywordflow">return</span> (right_lim - left_lim + nf_test + 1);
00758   }
00759   <span class="comment">/* Impulse response is too small to analyze */</span>
00760   <span class="keywordflow">return</span> -2;
00761 }
00762 
00763 <span class="comment">/*</span>
00764 <span class="comment"> * pzCancel: Remove cancelling pole-zero pairs from a response structure.</span>
00765 <span class="comment"> *           Search for pairs of poles and zeros whose real and imaginary</span>
00766 <span class="comment"> *           parts are within `tol' of each other. Remove any such pairs.</span>
00767 <span class="comment"> *           This will remove useless computations from the calculation</span>
00768 <span class="comment"> *           of the frequency response function in response().</span>
00769 <span class="comment"> */</span>
<a name="l00770"></a><a class="code" href="transfer_8c.html#a10">00770</a> <span class="keywordtype">void</span> <a class="code" href="transfer_8c.html#a10">pzCancel</a>(<a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *rs, <span class="keywordtype">double</span> tol)
00771 {
00772   <span class="keywordtype">int</span> ip, iz, mz;
00773   
00774   <span class="keywordflow">if</span> (rs-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a> == 0 || rs-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a> == 0)
00775     <span class="keywordflow">return</span>;
00776   
00777   <span class="keywordflow">for</span> (ip = 0; ip &lt; rs-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>; ip++)
00778   {
00779     mz = -1;
00780     <span class="keywordflow">for</span> (iz = 0; iz &lt; rs-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>; iz++)
00781     {
00782       <span class="keywordflow">if</span> (fabs(rs-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[ip].<a class="code" href="struct__PZNum.html#m0">dReal</a> - rs-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[iz].<a class="code" href="struct__PZNum.html#m0">dReal</a>) &lt; tol &amp;&amp;
00783           fabs(rs-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>[ip].<a class="code" href="struct__PZNum.html#m1">dImag</a> - rs-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>[iz].<a class="code" href="struct__PZNum.html#m1">dImag</a>) &lt; tol)
00784       {
00785         mz = iz;
00786         <span class="keywordflow">break</span>;
00787       }
00788     }
00789     <span class="keywordflow">if</span> (mz != -1)
00790     {
00791       <span class="comment">/* Found a match; remove the pole and the zero; move the other *</span>
00792 <span class="comment">       * poles and zeros into those empty slots.                     */</span>
00793       <a class="code" href="transfer_8c.html#a4">drop</a>(rs-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a>, &amp;rs-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a>, ip);
00794       <a class="code" href="transfer_8c.html#a4">drop</a>(rs-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a>, &amp;rs-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a>, mz);
00795       ip--;  <span class="comment">/* We have to look at this pole slot again */</span>
00796       iz--;  <span class="comment">/* and also this zero slot */</span>
00797     }
00798   }
00799   <span class="keywordflow">return</span>;
00800 }
00801 
00802 <span class="comment">/*</span>
00803 <span class="comment"> * drop: remove the `ipz' pole or zero from the PZNum array;</span>
00804 <span class="comment"> *       update the pNumPZ counter.</span>
00805 <span class="comment"> */</span>
<a name="l00806"></a><a class="code" href="transfer_8c.html#a4">00806</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="transfer_8c.html#a4">drop</a>(<a class="code" href="struct__PZNum.html">PZNum</a> *pPZ, <span class="keywordtype">int</span> *pNumPZ, <span class="keywordtype">int</span> ipz)
00807 {
00808   <span class="keywordtype">int</span> i;
00809   
00810   (*pNumPZ)--;
00811   <span class="keywordflow">for</span> (i = ipz; i &lt; *pNumPZ; i++)
00812   {
00813     pPZ[i] = pPZ[i+1];   <span class="comment">/* structure copy */</span>
00814   }
00815   <span class="keywordflow">return</span>;
00816 }
00817 
00818 
00819 <span class="comment">/* </span>
00820 <span class="comment"> * taper: Apply a cosine taper to a data series.</span>
00821 <span class="comment"> * Arguments:  data: array of data to be tapered</span>
00822 <span class="comment"> *             npts: number of points in data array</span>
00823 <span class="comment"> *             tLen: width of taper (at each end) in number of points</span>
00824 <span class="comment"> *      The end of the taper (where it has 0 value) is assumed to occur </span>
00825 <span class="comment"> *      at the first point before the start and after the end of the data;</span>
00826 <span class="comment"> *      these data points are not modified here. There are `tLen' points</span>
00827 <span class="comment"> *      that have taper values between 0 and 1 exclusive at each end of</span>
00828 <span class="comment"> *      the data.</span>
00829 <span class="comment"> *      If tLen is less then half of npts, this function returns</span>
00830 <span class="comment"> *      silently without applying the taper.</span>
00831 <span class="comment"> */</span>
<a name="l00832"></a><a class="code" href="transfer_8c.html#a11">00832</a> <span class="keywordtype">void</span> <a class="code" href="transfer_8c.html#a11">taper</a>(<span class="keywordtype">double</span> *data, <span class="keywordtype">long</span> npts, <span class="keywordtype">long</span> tLen)
00833 {
00834   <span class="keywordtype">long</span> i, jb, je;
00835   <span class="keywordtype">double</span> tap, omega;
00836   
00837   tLen++;
00838   <span class="keywordflow">if</span> (tLen &lt; 2 || tLen &gt; npts / 2)
00839     <span class="keywordflow">return</span>;
00840   
00841   omega = <a class="code" href="geo__to__km_8c.html#a0">PI</a> / tLen;
00842   
00843   <span class="keywordflow">for</span> (i = 1; i &lt; tLen; i++)
00844   {
00845     jb = i - 1;
00846     je = npts - i;
00847     tap = 0.5 * (1.0 - cos(omega * i));
00848     data[jb] *= tap;
00849     data[je] *= tap;
00850   }
00851   <span class="keywordflow">return</span>;
00852 }
00853 
00854 
<a name="l00855"></a><a class="code" href="transfer_8c.html#a12">00855</a> <span class="keywordtype">void</span> <a class="code" href="transfer_8c.html#a12">deMean</a>( <span class="keywordtype">double</span> *data, <span class="keywordtype">long</span> npts, <span class="keywordtype">double</span> *mean)
00856 {
00857   <span class="keywordtype">long</span> i;
00858   <span class="keywordtype">double</span> sum = 0.0;
00859   
00860   <span class="keywordflow">if</span> (npts &lt; 1)
00861   {
00862     *mean = 0.0;
00863     <span class="keywordflow">return</span>;
00864   }
00865   
00866   <span class="keywordflow">for</span> (i = 0; i &lt; npts; i++)
00867     sum += data[i];
00868   
00869   sum /= (double)npts;
00870   <span class="keywordflow">for</span> (i = 0; i &lt; npts; i++)
00871     data[i] -= sum;
00872   
00873   *mean = sum;
00874   <span class="keywordflow">return</span>;
00875 }
00876 
00877   
<a name="l00878"></a><a class="code" href="transfer_8c.html#a13">00878</a> <span class="keywordtype">void</span> <a class="code" href="transfer_8c.html#a13">cleanPZ</a>( <a class="code" href="struct__ResponseStruct.html">ResponseStruct</a> *pRS)
00879 {
00880   <span class="keywordflow">if</span> (pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a> != (<a class="code" href="struct__PZNum.html">PZNum</a> *)NULL)
00881   {
00882     free( pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a> );
00883     pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m4">Zeros</a> = (<a class="code" href="struct__PZNum.html">PZNum</a> *)NULL;
00884   }
00885   <span class="keywordflow">if</span> (pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a> != (<a class="code" href="struct__PZNum.html">PZNum</a> *)NULL)
00886   {
00887     free( pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a> );
00888     pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m3">Poles</a> = (<a class="code" href="struct__PZNum.html">PZNum</a> *)NULL;
00889   }
00890   pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m1">iNumPoles</a> = 0;
00891   pRS-&gt;<a class="code" href="struct__ResponseStruct.html#m2">iNumZeros</a> = 0;
00892   <span class="keywordflow">return</span>;
00893 }
00894 
<a name="l00895"></a><a class="code" href="transfer_8c.html#a14">00895</a> <span class="keywordtype">void</span> <a class="code" href="transfer_8c.html#a14">transferDebug</a>( <span class="keywordtype">int</span> level )
00896 {
00897   <a class="code" href="transfer_8c.html#a3">Debug</a> = level;
00898   <span class="keywordflow">return</span>;
00899 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue May 6 09:16:12 2003 for Earthworm Libs by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc3 </small></address>
</body>
</html>
